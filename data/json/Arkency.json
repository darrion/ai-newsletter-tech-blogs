{
  "company": "Arkency",
  "title": "Arkency",
  "xmlUrl": "http://blog.arkency.com/atom.xml",
  "htmlUrl": "http://blog.arkency.com/",
  "content": "\n\n\n\n\n\nRepository implementation on ActiveRecord | Arkency Blog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArticles\nTopics\nAll Articles\nDomain-Driven Design\nTesting\nRuby on Rails\nReact JS\nAsync Remote\n\n\n\n\n\n\n\n\nPawe\u0142 Pacana\n\n  December 28, 2023\n\nimprove this article\n\n\n\nrails\n\n\n\nRepository implementation on ActiveRecord\n\u2026 and check why 5600+ Rails engineers read also this \n\n\nRepository implementation on ActiveRecord\nIn its essence, a Repository separates domain objects from how they\u2019re persisted and provides a limited interface to access them. It\u2019s a tactical pattern described with far more words by Fowler and Evans than I\u2019d like to include in this introduction.\nIt stands in complete opposition to what ActiveRecord pattern promotes. Why bother transforming one into another?  \nThe problem with ActiveRecord pattern comes from its greatest strength. It\u2019s a double-edged sword. Immensely useful in rapid prototyping for a \u201csolopreneur\u201d. Flexible for a well-knit and disciplined team. Spiralling out of control in a wide organisation with multiple teams working on a relatively big legacy application.\nAs of now bare ActiveRecord::Base begins with 350 instance methods on its public interface. Add to that 496 methods of ActiveRecord::Relation that one usually interacts with. Performing a larger refactoring that covers all possible usage patterns of such ActiveRecord models becomes a nightmare. Initial checklist includes:\n\nvast query API\ncallbacks\nrelations, its extensions and the conventional behaviour\ngems in the Gemfile that extend ActiveRecord::Base \u2014 adding new methods and altering behaviours\n\nThat\u2019s a significant scope to cover. It translates to a certain cost of time, energy and confidence to pull out any change on it in a production system that earns money.\nI remember a few past attempts from my colleagues to control the scope of ActiveRecord surfaced in larger codebases.\nThere was the not_activerecord to help express the boundaries. There were various approaches to query objects that addressed the read part.\nI also vaguely recall a quote from Adam Pohorecki on a DRUG meetup that you can get 80% benefits out of Repository by putting 20% effort into shaping ActiveRecord like this:\nclass Transaction\n  def self.of_id(id)\n    find(id)\n  end\n\n  def self.last_not_pending_of_user_id(user_id)\n    where.not(status: \"pending\").where(user_id: user_id).order(:id).last\n  end\nend\n\nIt relies very much on the discipline of team \u2014 to treat ActiveRecord::Base methods as \u201cprivate\u201d and only access the model by the application-specific class methods.\nThis the repository I\u2019d make today, without any external dependencies in the framework you already have:\nclass TransactionRepository\n  class Record < ActiveRecord::Base\n    self.table_name = \"transactions\"\n  end\n  private_constant :Record\n\n  Transaction = Data.define(Record.attribute_names.map(&:to_sym))\n\n  class << self\n    def of_id(id)\n      as_struct(Record.find(id))\n    end\n\n    def last_not_pending_of_user_id(user_id)\n      as_struct(Record.where.not(status: \"pending\").where(user_id: user_id).order(:id).last)\n    end\n\n    private\n\n    def as_struct(record)\n      Transaction.new(**record.attributes.symbolize_keys)\n    end\n  end\nend\n\nLet\u2019s dissect this sample a bit.\n\nTransactionRepository and its public methods form the API. Since it takes no dependencies and carries no state within its lifecycle, the methods are on the singleton. These are the only ways to access the data and the surface is very limited.\nTransactionRepository::Record is the ActiveRecord class. We have to point to its database table with self.table_name, since its namespace is \u201cunconventional\u201d to the framework mechanics. We may use Record within the repository and to implement its functionality. This constant is not available outside the repository \u2014 encapsulation is fulfilled.\nReturn values of repository queries are immutable structs. They\u2019re not ActiveRecord::Relation. They\u2019re not ActiveRecord::Base instances either.\n\nDoes this approach have drawbacks? It certainly does. Like everything else it\u2019s an art of choice. We\u2019re trading convenience off in one area for predictability and maintainability in the other. YMMV.\nWhere vast ActiveRecord surface shines the most is the view layer and the numerous framework helpers built on top of it. We don\u2019t get that benefits with our structs. We might get back some of them by including ActiveModel::Naming behaviours.\nDoes this approach have any alternatives? The CQRS \u2014 a separation of write and read models, where there was previously one, could be a viable option for some. Given that writes and reads are implemented and optimised differently, the ActiveRecord fits the read part perfectly. It is my preferred vehicle to implement Read Model on top of denormalised SQL database tables in Rails.\n\n\n\n\n\n\n\nYou might also like\n\n\nFew static analysis tricks to bulletproof your application\n\nPiotr Jurewicz\n\n  April 28, 2023\n\n\n\n\nThe most important boundary in your app\n\nPiotr Jurewicz\n\n  April 17, 2023\n\n\n\n\nTracking down not resolving constants in Ruby with parser\n\nPiotr Jurewicz\n\n  March 2, 2023\n\n\n\n\n\n\n\n\n\nKeep in touch\n\n\n\n\n\n\n\n\n\n\n\n              Share your email so Arkency can send you stories about everyday struggles and solutions for building maintainable Rails apps.\n\n             \n\n\n\n\n\n\n\nProducts\nReact Experts as a\n            Service\nReact Component\n            Review\n\nReact.js Stationary\n            Training\nDDD Stationary\n            Training\nDomain-Driven Rails\n            Video\n            Course\nJunior Rails\n            Developer\n            Course\nHands-on Ruby, TDD and\n            DDD\nCode Mentoring\nBook Publishing\n\nthe Fuckups app\nRuby job offers at our\n            Arkency blog\n\nPainless search pages in\n            Rails and\n            React.js course\n\n\nBooks\nAsync Remote\nReact.js by Example\n\nRails Meets React.js\n\nFrontend\n            Friendly Rails\n\nFearless Refactoring: Rails\n            Controllers\nResponsible Rails:\n            Trustworthy\n            Developers\nBlogging for Busy\n            Programmers\nDomain Driven\n            Rails\n\n\nOpen Source\nruby_event_store\nrails_event_store\ncommand_bus\nReact.js Koans\nhttp_event_store\neventing-bus\narkency.js\nhexagonal.js\nYouAreDaBomb\n\nDevSnap\n\n\nConnect\nBlog\nReact Kung Fu\nRails Refactoring\n            Podcast\nYouTube\nTwitter\nGithub\nFacebook\nSnapchat\n\n\nWork with us\nHire us!\nJoin our team\n\n\nDomain-Driven Rails Workshops\n\nAmsterdam,\n          Barcelona,\n          Berlin,\n          Bern,\n          Bratislava,\n          Brussels,\n          Budapest,\n          Copenhagen,\n          Dublin,\n          Edinburgh,\n          Helsinki,\n          Kiev,\n          Lisbon,\n          London,\n          Madrid,\n          Minsk,\n          Moscow,\n          Oslo,\n          Paris,\n          Prague,\n          Rome,\n          Stockholm,\n          Vienna\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "latestPost": {
    "id": "tag:blog.arkency.com,2023-12-28:/activerecord-repository/",
    "guidislink": true,
    "link": "https://blog.arkency.com/activerecord-repository/",
    "title": "Repository implementation on ActiveRecord",
    "title_detail": {
      "type": "text/html",
      "language": null,
      "base": "https://blog.arkency.com/",
      "value": "Repository implementation on ActiveRecord"
    },
    "published": "2023-12-28T15:00:00Z",
    "published_parsed": [
      2023,
      12,
      28,
      15,
      0,
      0,
      3,
      362,
      0
    ],
    "updated": "2023-12-28T15:00:00Z",
    "updated_parsed": [
      2023,
      12,
      28,
      15,
      0,
      0,
      3,
      362,
      0
    ],
    "links": [
      {
        "rel": "alternate",
        "href": "https://blog.arkency.com/activerecord-repository/",
        "type": "text/html"
      }
    ],
    "content": [
      {
        "type": "text/html",
        "language": null,
        "base": "https://blog.arkency.com/",
        "value": "<h1 id=\"repository_implementation_on_activerecord\">Repository implementation on ActiveRecord</h1>\n<p>In its essence, a Repository separates domain objects from how they&rsquo;re persisted and provides a limited interface to access them. It&rsquo;s a tactical pattern described with far more words by <a href=\"https://martinfowler.com/eaaCatalog/repository.html\">Fowler</a> and <a href=\"https://www.domainlanguage.com\">Evans</a> than I&rsquo;d like to include in this introduction.\nIt stands in complete opposition to what <a href=\"https://www.martinfowler.com/eaaCatalog/activeRecord.html\">ActiveRecord</a> pattern promotes. Why bother transforming one into another?  </p>\n\n<p>The problem with ActiveRecord pattern comes from its greatest strength. It&rsquo;s a double-edged sword. Immensely useful in rapid prototyping for a &ldquo;solopreneur&rdquo;. Flexible for a well-knit and disciplined team. Spiralling out of control in a wide organisation with multiple teams working on a relatively big legacy application.</p>\n\n<p>As of now bare <code>ActiveRecord::Base</code> begins with 350 instance methods on its public interface. Add to that 496 methods of <code>ActiveRecord::Relation</code> that one usually interacts with. Performing a larger refactoring that covers all possible usage patterns of such ActiveRecord models becomes a nightmare. Initial checklist includes:</p>\n\n<ul>\n<li>vast query API</li>\n<li>callbacks</li>\n<li>relations, its extensions and the conventional behaviour</li>\n<li>gems in the <code>Gemfile</code> that extend <code>ActiveRecord::Base</code> \u2014 adding new methods and altering behaviours</li>\n</ul>\n\n<p>That&rsquo;s a significant scope to cover. It translates to a certain cost of time, energy and confidence to pull out any change on it in a production system that earns money.</p>\n\n<p>I remember a few past attempts from my colleagues to control the scope of ActiveRecord surfaced in larger codebases.\nThere was the <a href=\"https://github.com/paneq/not_activerecord\">not_activerecord</a> to help express the boundaries. There were various approaches to <a href=\"https://codeclimate.com/blog/7-ways-to-decompose-fat-activerecord-models\">query</a> <a href=\"https://thoughtbot.com/blog/a-case-for-query-objects-in-rails\">objects</a> that addressed the read part.</p>\n\n<p>I also vaguely recall a quote from <a href=\"https://adam.pohorecki.pl/blog/2013/06/27/bogus-talk-at-drug/\">Adam Pohorecki on a DRUG meetup</a> that you can get 80% benefits out of Repository by putting 20% effort into shaping ActiveRecord like this:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">Transaction</span>\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">of_id</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">)</span>\n    <span class=\"n\">find</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">last_not_pending_of_user_id</span><span class=\"p\">(</span><span class=\"n\">user_id</span><span class=\"p\">)</span>\n    <span class=\"n\">where</span><span class=\"p\">.</span><span class=\"nf\">not</span><span class=\"p\">(</span><span class=\"ss\">status: </span><span class=\"s2\">\"pending\"</span><span class=\"p\">).</span><span class=\"nf\">where</span><span class=\"p\">(</span><span class=\"ss\">user_id: </span><span class=\"n\">user_id</span><span class=\"p\">).</span><span class=\"nf\">order</span><span class=\"p\">(</span><span class=\"ss\">:id</span><span class=\"p\">).</span><span class=\"nf\">last</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>It relies very much on the discipline of team \u2014 to treat <code>ActiveRecord::Base</code> methods as &ldquo;private&rdquo; and only access the model by the application-specific class methods.</p>\n\n<p>This the repository I&rsquo;d make today, without any external dependencies in the framework you already have:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">TransactionRepository</span>\n  <span class=\"k\">class</span> <span class=\"nc\">Record</span> <span class=\"o\">&lt;</span> <span class=\"no\">ActiveRecord</span><span class=\"o\">::</span><span class=\"no\">Base</span>\n    <span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"nf\">table_name</span> <span class=\"o\">=</span> <span class=\"s2\">\"transactions\"</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">private_constant</span> <span class=\"ss\">:Record</span>\n\n  <span class=\"no\">Transaction</span> <span class=\"o\">=</span> <span class=\"no\">Data</span><span class=\"p\">.</span><span class=\"nf\">define</span><span class=\"p\">(</span><span class=\"no\">Record</span><span class=\"p\">.</span><span class=\"nf\">attribute_names</span><span class=\"p\">.</span><span class=\"nf\">map</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"ss\">:to_sym</span><span class=\"p\">))</span>\n\n  <span class=\"k\">class</span> <span class=\"o\">&lt;&lt;</span> <span class=\"nb\">self</span>\n    <span class=\"k\">def</span> <span class=\"nf\">of_id</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">)</span>\n      <span class=\"n\">as_struct</span><span class=\"p\">(</span><span class=\"no\">Record</span><span class=\"p\">.</span><span class=\"nf\">find</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">))</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">last_not_pending_of_user_id</span><span class=\"p\">(</span><span class=\"n\">user_id</span><span class=\"p\">)</span>\n      <span class=\"n\">as_struct</span><span class=\"p\">(</span><span class=\"no\">Record</span><span class=\"p\">.</span><span class=\"nf\">where</span><span class=\"p\">.</span><span class=\"nf\">not</span><span class=\"p\">(</span><span class=\"ss\">status: </span><span class=\"s2\">\"pending\"</span><span class=\"p\">).</span><span class=\"nf\">where</span><span class=\"p\">(</span><span class=\"ss\">user_id: </span><span class=\"n\">user_id</span><span class=\"p\">).</span><span class=\"nf\">order</span><span class=\"p\">(</span><span class=\"ss\">:id</span><span class=\"p\">).</span><span class=\"nf\">last</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"kp\">private</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">as_struct</span><span class=\"p\">(</span><span class=\"n\">record</span><span class=\"p\">)</span>\n      <span class=\"no\">Transaction</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"nf\">attributes</span><span class=\"p\">.</span><span class=\"nf\">symbolize_keys</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Let&rsquo;s dissect this sample a bit.</p>\n\n<ol>\n<li><code>TransactionRepository</code> and its public methods form the API. Since it takes no dependencies and carries no state within its lifecycle, the methods are on the singleton. These are the only ways to access the data and the surface is very limited.</li>\n<li><code>TransactionRepository::Record</code> is the ActiveRecord class. We have to point to its database table with <code>self.table_name</code>, since its namespace is &ldquo;unconventional&rdquo; to the framework mechanics. We may use <code>Record</code> within the repository and to implement its functionality. This constant is not available outside the repository \u2014 encapsulation is fulfilled.</li>\n<li>Return values of repository queries are immutable structs. They&rsquo;re not <code>ActiveRecord::Relation</code>. They&rsquo;re not <code>ActiveRecord::Base</code> instances either.</li>\n</ol>\n\n<p>Does this approach have drawbacks? It certainly does. Like everything else it&rsquo;s an art of choice. We&rsquo;re trading convenience off in one area for predictability and maintainability in the other. YMMV.</p>\n\n<p>Where vast ActiveRecord surface shines the most is the view layer and the numerous framework helpers built on top of it. We don&rsquo;t get that benefits with our structs. We might get back some of them by including <code>ActiveModel::Naming</code> behaviours.</p>\n\n<p>Does this approach have any alternatives? The CQRS \u2014 a separation of write and read models, where there was previously one, could be a viable option for some. Given that writes and reads are implemented and optimised differently, the ActiveRecord fits the read part perfectly. It is my preferred vehicle to implement Read Model on top of denormalised SQL database tables in Rails.</p>"
      }
    ],
    "summary": "<h1 id=\"repository_implementation_on_activerecord\">Repository implementation on ActiveRecord</h1>\n<p>In its essence, a Repository separates domain objects from how they&rsquo;re persisted and provides a limited interface to access them. It&rsquo;s a tactical pattern described with far more words by <a href=\"https://martinfowler.com/eaaCatalog/repository.html\">Fowler</a> and <a href=\"https://www.domainlanguage.com\">Evans</a> than I&rsquo;d like to include in this introduction.\nIt stands in complete opposition to what <a href=\"https://www.martinfowler.com/eaaCatalog/activeRecord.html\">ActiveRecord</a> pattern promotes. Why bother transforming one into another?  </p>\n\n<p>The problem with ActiveRecord pattern comes from its greatest strength. It&rsquo;s a double-edged sword. Immensely useful in rapid prototyping for a &ldquo;solopreneur&rdquo;. Flexible for a well-knit and disciplined team. Spiralling out of control in a wide organisation with multiple teams working on a relatively big legacy application.</p>\n\n<p>As of now bare <code>ActiveRecord::Base</code> begins with 350 instance methods on its public interface. Add to that 496 methods of <code>ActiveRecord::Relation</code> that one usually interacts with. Performing a larger refactoring that covers all possible usage patterns of such ActiveRecord models becomes a nightmare. Initial checklist includes:</p>\n\n<ul>\n<li>vast query API</li>\n<li>callbacks</li>\n<li>relations, its extensions and the conventional behaviour</li>\n<li>gems in the <code>Gemfile</code> that extend <code>ActiveRecord::Base</code> \u2014 adding new methods and altering behaviours</li>\n</ul>\n\n<p>That&rsquo;s a significant scope to cover. It translates to a certain cost of time, energy and confidence to pull out any change on it in a production system that earns money.</p>\n\n<p>I remember a few past attempts from my colleagues to control the scope of ActiveRecord surfaced in larger codebases.\nThere was the <a href=\"https://github.com/paneq/not_activerecord\">not_activerecord</a> to help express the boundaries. There were various approaches to <a href=\"https://codeclimate.com/blog/7-ways-to-decompose-fat-activerecord-models\">query</a> <a href=\"https://thoughtbot.com/blog/a-case-for-query-objects-in-rails\">objects</a> that addressed the read part.</p>\n\n<p>I also vaguely recall a quote from <a href=\"https://adam.pohorecki.pl/blog/2013/06/27/bogus-talk-at-drug/\">Adam Pohorecki on a DRUG meetup</a> that you can get 80% benefits out of Repository by putting 20% effort into shaping ActiveRecord like this:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">Transaction</span>\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">of_id</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">)</span>\n    <span class=\"n\">find</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">last_not_pending_of_user_id</span><span class=\"p\">(</span><span class=\"n\">user_id</span><span class=\"p\">)</span>\n    <span class=\"n\">where</span><span class=\"p\">.</span><span class=\"nf\">not</span><span class=\"p\">(</span><span class=\"ss\">status: </span><span class=\"s2\">\"pending\"</span><span class=\"p\">).</span><span class=\"nf\">where</span><span class=\"p\">(</span><span class=\"ss\">user_id: </span><span class=\"n\">user_id</span><span class=\"p\">).</span><span class=\"nf\">order</span><span class=\"p\">(</span><span class=\"ss\">:id</span><span class=\"p\">).</span><span class=\"nf\">last</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>It relies very much on the discipline of team \u2014 to treat <code>ActiveRecord::Base</code> methods as &ldquo;private&rdquo; and only access the model by the application-specific class methods.</p>\n\n<p>This the repository I&rsquo;d make today, without any external dependencies in the framework you already have:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">TransactionRepository</span>\n  <span class=\"k\">class</span> <span class=\"nc\">Record</span> <span class=\"o\">&lt;</span> <span class=\"no\">ActiveRecord</span><span class=\"o\">::</span><span class=\"no\">Base</span>\n    <span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"nf\">table_name</span> <span class=\"o\">=</span> <span class=\"s2\">\"transactions\"</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">private_constant</span> <span class=\"ss\">:Record</span>\n\n  <span class=\"no\">Transaction</span> <span class=\"o\">=</span> <span class=\"no\">Data</span><span class=\"p\">.</span><span class=\"nf\">define</span><span class=\"p\">(</span><span class=\"no\">Record</span><span class=\"p\">.</span><span class=\"nf\">attribute_names</span><span class=\"p\">.</span><span class=\"nf\">map</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"ss\">:to_sym</span><span class=\"p\">))</span>\n\n  <span class=\"k\">class</span> <span class=\"o\">&lt;&lt;</span> <span class=\"nb\">self</span>\n    <span class=\"k\">def</span> <span class=\"nf\">of_id</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">)</span>\n      <span class=\"n\">as_struct</span><span class=\"p\">(</span><span class=\"no\">Record</span><span class=\"p\">.</span><span class=\"nf\">find</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">))</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">last_not_pending_of_user_id</span><span class=\"p\">(</span><span class=\"n\">user_id</span><span class=\"p\">)</span>\n      <span class=\"n\">as_struct</span><span class=\"p\">(</span><span class=\"no\">Record</span><span class=\"p\">.</span><span class=\"nf\">where</span><span class=\"p\">.</span><span class=\"nf\">not</span><span class=\"p\">(</span><span class=\"ss\">status: </span><span class=\"s2\">\"pending\"</span><span class=\"p\">).</span><span class=\"nf\">where</span><span class=\"p\">(</span><span class=\"ss\">user_id: </span><span class=\"n\">user_id</span><span class=\"p\">).</span><span class=\"nf\">order</span><span class=\"p\">(</span><span class=\"ss\">:id</span><span class=\"p\">).</span><span class=\"nf\">last</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"kp\">private</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">as_struct</span><span class=\"p\">(</span><span class=\"n\">record</span><span class=\"p\">)</span>\n      <span class=\"no\">Transaction</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"nf\">attributes</span><span class=\"p\">.</span><span class=\"nf\">symbolize_keys</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Let&rsquo;s dissect this sample a bit.</p>\n\n<ol>\n<li><code>TransactionRepository</code> and its public methods form the API. Since it takes no dependencies and carries no state within its lifecycle, the methods are on the singleton. These are the only ways to access the data and the surface is very limited.</li>\n<li><code>TransactionRepository::Record</code> is the ActiveRecord class. We have to point to its database table with <code>self.table_name</code>, since its namespace is &ldquo;unconventional&rdquo; to the framework mechanics. We may use <code>Record</code> within the repository and to implement its functionality. This constant is not available outside the repository \u2014 encapsulation is fulfilled.</li>\n<li>Return values of repository queries are immutable structs. They&rsquo;re not <code>ActiveRecord::Relation</code>. They&rsquo;re not <code>ActiveRecord::Base</code> instances either.</li>\n</ol>\n\n<p>Does this approach have drawbacks? It certainly does. Like everything else it&rsquo;s an art of choice. We&rsquo;re trading convenience off in one area for predictability and maintainability in the other. YMMV.</p>\n\n<p>Where vast ActiveRecord surface shines the most is the view layer and the numerous framework helpers built on top of it. We don&rsquo;t get that benefits with our structs. We might get back some of them by including <code>ActiveModel::Naming</code> behaviours.</p>\n\n<p>Does this approach have any alternatives? The CQRS \u2014 a separation of write and read models, where there was previously one, could be a viable option for some. Given that writes and reads are implemented and optimised differently, the ActiveRecord fits the read part perfectly. It is my preferred vehicle to implement Read Model on top of denormalised SQL database tables in Rails.</p>"
  }
}