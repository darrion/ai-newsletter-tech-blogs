{
  "company": "Latacora",
  "title": "Latacora",
  "xmlUrl": "https://latacora.micro.blog/feed.xml",
  "htmlUrl": "https://latacora.singles/",
  "content": "A Case for Password Hashing With Delegation | Latacora\n\nOpen main menu\n\nProcessFitBlogCareersContactA Case for Password Hashing With DelegationBy Aleksandar KircanskiDecember 22, 2023\n- 9 minutes read\n- 1899 wordsWhen people talk about PBKDFs (Password Based Key Derivation Functions), this\nis usually either in the context of secure password storage, or in the context\nof how to derive cryptographic keys from potentially low-entropy passwords. The\nPassword Hashing Competition (PHC, 2013-2015) was an open competition to derive\nnew password hashing algorithms, resulting in Argon2 hash as its winner. Apart\nfrom achieving general hash security, many of the candidates focused on\nachieving resistance to parallel attacks on available hardware such as GPUs.There exists, however, a somewhat less known password hashing primitive: a\nPBKDF with a special property, called delegation 1. In this blog post, we\nbring this primitive to attention and discuss its applicability in the context\nof End-to-End Encrypted (E2EE) backup systems. The idea is to be able to\noffload hashing computation to a potentially untrusted server.In general, the higher the PBKDF\u2019s work factor is, the more difficult it is to\ncrack a password. Sometimes, however, the work factor is necessarily small;\nthis happens if the system needs to support all devices, including the weakest\nof customer devices. Offloading to an untrusted server may allow increasing the\nwork factor, preventing the factor being dictated by the weakest of customers\u2019\ndevices.Before moving on, let\u2019s first disambiguate: in this blog post, we are not\ntalking about PBKDF2\n, we are talking\nabout any general\nKey Derivation Function\nthat could typically be used for two different purposes. One purpose is to\nconvert passwords to encryption keys and the other is to convert passwords into\npassword hashes (used for authentication). PBKDF2 is just one example of such a\nfunction. Password hashing with delegation could aid both of those use cases,\nbut in this blog post we focus on the encryption key derivation use case.PBKDF with delegation and E2EE backup systemsThe basic scenario in which PBKDF with delegation may be considered is a login\nserver that receives an authentication password and then delegates the password\nhash computation to another, untrusted entity.There is however a scenario that appears to further justify PBKDF delegation\nusage.Recall the Firefox and Chrome \u201csync\u201d features. These features offer users the\noption to save passwords, bookmarks and other browsing information on their\nprovider\u2019s servers. The Firefox sync is E2E encrypted by default, while Chrome\nsaves the password and other data in plaintext on Google\u2019s servers; only if the\nuser modifies a browser setting, encryption is applied. In that case, servers\ndo not get to see the plaintext data.When it comes to the security of browser sync features, see this\nblog post\ntogether with further past\ndiscussions\non the topic. Without going into details on what happens server-side, the\nclient work factors in play when the user\u2019s password is used to derive an\nencryption key are:Firefox sync: 1000 PBKDF2-HMAC-SHA256 roundsChrome sync: scrypt with N=8192, r=8, p=11These parameters are lower than the currently recommended ones: 600000 rounds\nfor\nPBKDF2\nand N=32768 or N=1048576 for\nscrypt\n, depending whether it\nis interactive logins or file encryption. The reason for this is that the hash\nfunction work factors are dictated by the least capable subset of end-user\ndevices; the feature should work on all devices and should not cause any\ndisruption for a large device subset.The E2EE backup system landscapeLet\u2019s take a step back and list some of the E2EE backup systems out there. Such\nsystems will have the client choose or generate a secret, from which a\nsymmetric encryption key is derived. Data is encrypted client-side and sent to\nthe potentially untrusted servers. There\u2019s also the need to authenticate the\nuser for encrypted data retrieval; the same or different secret may be used for\nthat purpose.Let\u2019s try to categorize E2EE backup in terms of the amount of entropy users\u2019\nsecrets have:High-entropy passphrase E2EE backup: Generating a high-entropy passphrase\nin client-side code fully prevents brute-forcing the passwords based on just\nthe ciphertext data. However, this choice does complicate the UX; when\nenrolling new devices, it is necessary to share the complex passphrase\nbetween devices. Moreover, when all devices are lost, the user\u2019s information\nbecomes irrecoverable. An example of a vendor that uses this approach is\n1Password; see pg. 10 of its design\ndocument\n.Potentially low-entropy passphrase E2EE backup: Users choose a password\nand this password is used to derive the symmetric E2EE key. To simplify the\nUX, the same password (but passed through a different KDF process) is used\nfor authentication. On the UX side, if all devices are lost, it is still\npossible to recover data, as long as the user remembers the password. It is\nnot necessary to share keys when new devices are enrolled. Examples here\ninclude\nFirefox sync\nand Chrome syncLow-entropy passphrase E2EE backup: Passphrases could also be, say,\n6-digit PINs. To have that, it is necessary to rely on server-side Trusted\nExecution Environments (TEEs) with hardware-controlled code execution\nenvironments. Brute-forcing the PIN is prevented by code that runs inside\nTEEs and as long as TEE security is not violated in some way, the backup\nsystem has a chance of delivering its security promises. Some representatives\nof this E2EE backup type are\niCloud keychain sync\nand the\nWhatsapp E2E encrypted backup\n.\nOften-times, documentation is very sparse on what exactly is going on inside\nthe backend.Password hashing with delegation would appear to make the most sense in the\nsecond case, that is, in systems that allow users to choose passwords and use\nthose passwords to derive E2EE symmetric keys. In such cases, the (untrusted)\nserver could be delegated to perform the hashing and the hashing work factor\nwould no longer be dictated by the weakest of the client devices.As for the first and the third case, if the passphrase already has high\nentropy, slow hashing is basically unnecessary. If the passphrase has low\nentropy (e.g. is a PIN), trust is already offloaded to the TEEs in the backend.It is worth noting that the delegates in the picture could be owned by the\nbackup provider itself.Makwa, or, the magic of cryptographyThe only hash function that supports delegation known to the author of this\nblog post is the Makwa hash function\n1. It\nwas designed by Thomas Pornin and was a candidate to the Password Hashing\nCompetition (PHC) which ran from 2012 to 2015. During the competition, it was\nfound that a similar construction was independently discussed2 by Adam Back\non the Bitcoin talk forum. Note that in the original Bitcoin talk post actually\nproposes the function for client-side hashing, in the context of so-called\nBitcoin \u201cbrain-wallets\u201d.Here, we only discuss Makwa on a very basic level; there are some formulas\nbelow, but they are for illustration purposes only.The idea is to convert the password into a value less than the RSA modulus\n$N = p\\times q$, blind it with a secret factor and then apply a long sequence\nof Rabin encryptions. Alternatively, one could describe Makwa as a blind RSA\ncomputation with a very large exponent in the form of $e = 2^k$, for some work\nfactor $k$.Taking this into account, let\u2019s do an exercise and try to derive parts of Makwa\non our own. System A attempts to offload the computation to system B. System A\nderives $\\pi$ from the password by using a KDF and salt; we don\u2019t go into\ndetails of that here. The system A chooses a random blinding factor\n$\\alpha\\hspace{1mm}mod\\hspace{1mm}N$ and sends\n$\\alpha \\times \\pi\\hspace{1mm}mod\\hspace{1mm}N$ to system B. Suppose B takes on\nthe work load and returns:$$(\\alpha \\times \\pi)^{2^k}\\hspace{2mm}mod\\hspace{2mm}N$$The problem is that system A now needs to unblind\n$\\alpha^{2^k} \\times {\\pi}^{2^k}\\hspace{1mm}mod\\hspace{1mm}N$. System A could\nperform the unblinding by computing $\\alpha^{2^k}\\hspace{1mm}mod\\hspace{1mm} N$\nand its inverse. However, this would be costly and it would defeat the original\nhash offloading purpose.One could try to pre-compute the inverse of\n$\\alpha^{2^k}\\hspace{1mm}mod\\hspace{1mm}N$ and keep the blinding factor\nconstant, for all offloaded password hashings. This would not work, as it would\nleak information about passwords to the untrusted server.To get around this, Makwa employs a technique based on the following idea.\nGenerate a bunch of blinding factors $\\alpha_i$ for $i = 1\\ldots 300$, and\npre-compute $(\\alpha_i^{2^k})^{-1}\\hspace{1mm}mod\\hspace{1mm}N$ for all of\nthem. Blinding is performed by multiplying $\\pi$ with a randomly chosen subset\nof $\\alpha_i$ values:$$(\\prod_{b_i = 1} \\alpha_i) \\times \\pi\\hspace{1mm}mod\\hspace{1mm}N$$where, for each $i$, $b_i$ is a random bit 0 or 1. System A can now efficiently\nun-blind, by multiplying the result with the corresponding pre-computed\n$\\alpha_i$ values and choosing the $\\alpha_i$ subset randomly makes it so that\nthe blinding factors are unlikely to be repeated.There\u2019s an additional wrinkle to what we\u2019ve been talking about. Squaring is not\ninjective inside the multiplicative group modulo $N$, as both $x$ and $N - x$\nget mapped to the same value. Squaring is injective, however, on the set of\nsquares modulo $N$, if $N$ is a Blum integer, see the Properties section of\nthis page\n.If server B receives the password blinded as described by the previous\nequation, this value may or may not be a square. Server B could compute the\nJacobi symbol\nof the received\nblinded value, despite the fact that the factorization of $N$ is not known.\nThis would leak one bit of information on the indexes used for blinding. This\ndoes not appear to be a serious leak, but for safety and consistency, Makwa\nspecifies that the server A squares both $\\pi$ and the blinding factors before\ncomputing the value on which B will operate.See Makwa\u2019s specification\nfor all the details\non the function.Future research on hashing with delegationSometimes, cryptography lets us achieve \u201cmagical\u201d features that initially\nappeared impossible. This is indeed the case with hashing with delegation and\nMakwa. However, as a bonus, we may end up with additional properties that we\ndon\u2019t necessarily want, at least not in certain use-cases.If factors $p$ and $q$ of $N$ are known, it is possible to rewind the slow hash\ncomputation back and derive the password derivative $p$. Depending on the Makwa\nhashing mode, this would mean either deriving a KDF of the password or the\npassword itself. Also, if the factors are known, the hashing procedure can be\nsped up, making the hashing cost similar to the cost of one RSA private key\noperation.In order to remove this possibility, $p$ and $q$ need to be securely discarded.\nThis could be an obstacle for the E2EE backup setting. Users may question\nwhether they are being backdoored by the E2EE backup provider. There does,\nhowever, exist a long thread of research\non\nmulti-party computation protocols for secure distributed generation of modulus\n$N$; a ceremony of that sort could be applied to derive the parameters.Regarding concerns around lack of memory-hardness in the Makwa hash function,\nsee this paper\n, which shows that the\nadvantage GPUs have over CPUs is actually relatively small.See also previous work on password\npeppering\nwith\ndelegation3 which is remotely related to hashing with delegation, but the\nemployed techniques are different from those in Makwa.Let\u2019s end this blog post with a question:Is it possible to construct a PBKDF with delegation, but without the p,q\nescrow feature?The Makwa Password Hashing Function, Thomas Pornin,\nhttps://www.bolet.org/makwa/makwa-spec-20150422.pdf\n\u00a0\u21a9\ufe0e\u00a0\u21a9\ufe0eHardening brain-wallets with a useful blind proof of work, Adam Back\nhttps://bitcointalk.org/index.php?topic=311000.0\n\u00a0\u21a9\ufe0eThe Pythia PRF Service, Adam Everspaugh, Rahul Chatterjee, Samuel Scott,\nAri Juels, and Thomas Ristenpart, https://eprint.iacr.org/2015/644\n\u00a0\u21a9\ufe0e\n\u00a9 2024 LATACORA, LLC\n400 N May St, SUITE #306, Chicago, IL",
  "latestPost": {
    "title": "A Case for Password Hashing With Delegation",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://www.latacora.com/blog/index.xml",
      "value": "A Case for Password Hashing With Delegation"
    },
    "links": [
      {
        "rel": "alternate",
        "type": "text/html",
        "href": "https://latacora.github.io/blog/2023/12/22/case-for-password-hashing/"
      }
    ],
    "link": "https://latacora.github.io/blog/2023/12/22/case-for-password-hashing/",
    "published": "Fri, 22 Dec 2023 10:18:16 -0500",
    "published_parsed": [
      2023,
      12,
      22,
      15,
      18,
      16,
      4,
      356,
      0
    ],
    "id": "https://latacora.github.io/blog/2023/12/22/case-for-password-hashing/",
    "guidislink": false,
    "summary": "When people talk about PBKDFs (Password Based Key Derivation Functions), this is usually either in the context of secure password storage, or in the context of how to derive cryptographic keys from potentially low-entropy passwords. The Password Hashing Competition (PHC, 2013-2015) was an open competition to derive new password hashing algorithms, resulting in Argon2 hash as its winner. Apart from achieving general hash security, many of the candidates focused on achieving resistance to parallel attacks on available hardware such as GPUs.",
    "summary_detail": {
      "type": "text/html",
      "language": null,
      "base": "https://www.latacora.com/blog/index.xml",
      "value": "When people talk about PBKDFs (Password Based Key Derivation Functions), this is usually either in the context of secure password storage, or in the context of how to derive cryptographic keys from potentially low-entropy passwords. The Password Hashing Competition (PHC, 2013-2015) was an open competition to derive new password hashing algorithms, resulting in Argon2 hash as its winner. Apart from achieving general hash security, many of the candidates focused on achieving resistance to parallel attacks on available hardware such as GPUs."
    }
  }
}