{
  "company": "theScore",
  "title": "theScore",
  "xmlUrl": "http://techblog.thescore.com/feed.xml",
  "htmlUrl": "http://techblog.thescore.com/",
  "content": "\n\n\n\n\nRepo.transact/2 (The Case Against Ecto.Multi) \u2014 theScore Tech Blog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHome\nAbout\n\n\nThe Ultimate, Personalized Mobile Sports Experience\nLearn More\n\n\n\n\n\n\nRepo.transact/2 (The Case Against Ecto.Multi)\n\n\n  \n  \n    5 min read\n  \n\n \u2014\n        Tom Konidas \u2014\n        May 01, 2023\n        \n        \n         \u25cf elixir\n        \n         \u25cf ecto\n        \n         \u25cf transaction\n        \n         \u25cf multi\n        \n        \u25cf\n        \n      \n\n\n\n\nTweet\n\n\n\n\n\n\n\n\n\n\nAfter reading Towards Maintainable\nElixir\nby Sa\u0161a Juri\u0107 and hearing about his famous Repo.transact in some of his\ntalks, I decided it was time to explore this for myself.\nThis post takes into account that you (the reader) are aware and know why and\nwhen to use Ecto.Multi. But for\nthose unfamiliar, the TL;DR is you would use an Ecto.Multi when you want to\nperform multiple transaction that you want to be committed to the database in\none shot. Meaning, if one of the transactions fails, you would want to revert\nall other transactions in the run.\nThe Problem with Ecto.Multi\nLets get something straight, there is nothing wrong with using Ecto.Multi\nin your codebase. If it works for you, then it works. However after working\nwith it in multiple codebases I have started to see a common theme: it is very\nnoisy and can be sometimes hard to follow and DRY up. You can get around it by\nusing a lot of private functions to support the Ecto.Multi, but then your\nmodule just has a tons of wrapper functions.\nWhat is Repo.transact/2?\n\nThe function Repo.transact is our small wrapper around\nRepo.transaction/2.\nThis function commits the transaction if the lambda returns {:ok, result},\nrolling it back if the lambda returns {:error, reason}. In both cases, the\nfunction returns the result of the lambda. We chose this approach over\nEcto.Multi, because we\u2019ve experimentally established that multi adds a lot of\nnoise with no real benefits for our needs.\n-- Sa\u0161a Juri\u0107\n\nFunction definition\nSa\u0161a never gives out the implementation of the function but I came up with\nthis, and it works great; Exactly as you would expect.\ndefmodule MyApp.Repo do\n  use Ecto.Repo,\n    otp_app: :my_app,\n    adapter: Ecto.Adapters.Postgres\n  @doc \"\"\"\n  A small wrapper around `Repo.transaction/2'.\n  Commits the transaction if the lambda returns `{:ok, result}`, rolling it\n  back if the lambda returns `{:error, reason}`. In both cases, the function\n  returns the result of the lambda.\n  \"\"\"\n  @spec transact((() -> any()), keyword()) :: {:ok, any()} | {:error, any()}\n  def transact(fun, opts \\\\ []) do\n    transaction(\n      fn ->\n        case fun.() do\n          {:ok, value} -> value\n          :ok -> :transaction_commited\n          {:error, reason} -> rollback(reason)\n          :error -> rollback(:transaction_rollback_error)\n        end\n      end,\n      opts\n    )\n  end\nend\n\nEcto.Multi vs Repo.transact\nLets say we want to take the typical user registration flow as an example. If\nwe want to insert a user, log the action to an audit table and also enqueue a job\nto send a confirmation email.\nWe would have something like this using an Ecto.Multi:\nEcto.Multi implementation\ndef register_user(params) do\n  Multi.new()\n  |> Multi.insert(:user, Accounts.new_user_changeset(params))\n  |> Multi.insert(:log, fn %{user: user} ->\n    Logs.log_action(:user_registered, %{user: user})\n  end)\n  |> Multi.insert(:email_job, fn %{user: user} ->\n    Mailer.enqueue_email_confirmation(user)\n  end)\n  |> Repo.transaction()\n  |> case do\n    {:ok, %{user: user}} ->\n      {:ok, user}\n    {:error, _failed_operation, failed_value, _changes_so_far} ->\n      {:error, failed_value}\n  end\nend\n\nAs we can see, it is not the worst, but once we see the Repo.transact/2 way,\nit will be clear which is better.\nRepo.transact implementation\ndef register_user(params) do\n  Repo.transact(fn ->\n    with {:ok, user} <- Accounts.create_user(params),\n         {:ok, _log} <- Logs.log_action(:user_registered, user),\n         {:ok, _job} <- Mailer.enqueue_email_confirmation(user) do\n      {:ok, user}\n    end\n  end)\nend\n\nAs you can see, it is much shorter and easier to read. Another big benefit is\nthat we do not need to go down to the changeset level for inserting, we could\nuse our functions that perform Repo.inserts in them\n(Accounts.new_user_changeset/1 vs Accounts.create_user/1). This lets us\ncompose many functions together from outside the context modules without having\nthe need to expose your changeset functions.\nThe end result is the same, but it is a lot easier to read what is going on IMHO.\n\n\n      Originally posted at tomkonidas.com\n\n\n\n\n\n\n\n\n\n\nHome\nAbout\n\n\n\n\n\n\n\n\nIncorporated theme by Inc\n\n\n\n\n\n\n\n\n\n\n\n",
  "latestPost": {
    "title": "Repo.transact/2 (The Case Against Ecto.Multi)",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://techblog.thescore.com/feed.xml",
      "value": "Repo.transact/2 (The Case Against Ecto.Multi)"
    },
    "links": [
      {
        "rel": "alternate",
        "type": "text/html",
        "href": "https://techblog.thescore.com/2023/05/01/repo-transact/"
      }
    ],
    "link": "https://techblog.thescore.com/2023/05/01/repo-transact/",
    "published": "Mon, 01 May 2023 00:00:00 +0000",
    "published_parsed": [
      2023,
      5,
      1,
      0,
      0,
      0,
      0,
      121,
      0
    ],
    "authors": [
      {}
    ],
    "author": "",
    "id": "https://techblog.thescore.com/2023/05/01/repo-transact",
    "guidislink": false,
    "summary": "<p>After reading <a href=\"https://medium.com/very-big-things/towards-maintainable-elixir-the-core-and-the-interface-c267f0da43\">Towards Maintainable\nElixir</a>\nby Sa\u0161a Juri\u0107 and hearing about his famous <code>Repo.transact</code> in some of his\ntalks, I decided it was time to explore this for myself.</p>\n\n<p>This post takes into account that you (the reader) are aware and know why and\nwhen to use <a href=\"https://hexdocs.pm/ecto/Ecto.Multi.html\">Ecto.Multi</a>. But for\nthose unfamiliar, the TL;DR is you would use an <code>Ecto.Multi</code> when you want to\nperform multiple transaction that you want to be committed to the database in\none shot. Meaning, if one of the transactions fails, you would want to revert\nall other transactions in the run.</p>\n\n<h2>The Problem with Ecto.Multi</h2>\n\n<p>Lets get something straight, <strong>there is nothing wrong with using Ecto.Multi</strong>\nin your codebase. If it works for you, then it works. However after working\nwith it in multiple codebases I have started to see a common theme: it is very\nnoisy and can be sometimes hard to follow and DRY up. You can get around it by\nusing a lot of private functions to support the Ecto.Multi, but then your\nmodule just has a tons of wrapper functions.</p>\n\n<h2>What is Repo.transact/2?</h2>\n\n<blockquote>\n<p>The function Repo.transact is our small wrapper around\n<a href=\"https://hexdocs.pm/ecto/Ecto.Repo.html#c:transaction/2\">Repo.transaction/2</a>.\nThis function commits the transaction if the lambda returns <code>{:ok, result}</code>,\nrolling it back if the lambda returns <code>{:error, reason}</code>. In both cases, the\nfunction returns the result of the lambda. We chose this approach over\nEcto.Multi, because we\u2019ve experimentally established that multi adds a lot of\nnoise with no real benefits for our needs.</p>\n\n<p>-- <cite>Sa\u0161a Juri\u0107</cite></p>\n</blockquote>\n\n<h2>Function definition</h2>\n\n<p>Sa\u0161a never gives out the implementation of the function but I came up with\nthis, and it works great; Exactly as you would expect.</p>\n<div class=\"highlight\"><pre><code class=\"language-elixir\"><span></span><span class=\"kd\">defmodule</span><span class=\"w\"> </span><span class=\"nc\">MyApp.Repo</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"kn\">use</span><span class=\"w\"> </span><span class=\"nc\">Ecto.Repo</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"ss\">otp_app</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"ss\">:my_app</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"ss\">adapter</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Ecto.Adapters.Postgres</span>\n<span class=\"w\">  </span><span class=\"na\">@doc</span><span class=\"w\"> </span><span class=\"sh\">\"\"\"</span>\n<span class=\"w\">  </span><span class=\"sh\">A small wrapper around `Repo.transaction/2'.</span>\n<span class=\"sh\">  Commits the transaction if the lambda returns `{:ok, result}`, rolling it</span>\n<span class=\"sh\">  back if the lambda returns `{:error, reason}`. In both cases, the function</span>\n<span class=\"sh\">  returns the result of the lambda.</span>\n<span class=\"w\">  </span><span class=\"sh\">\"\"\"</span>\n<span class=\"w\">  </span><span class=\"na\">@spec</span><span class=\"w\"> </span><span class=\"n\">transact</span><span class=\"p\">((()</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"n\">keyword</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"p\">()}</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"ss\">:error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"p\">()}</span>\n<span class=\"w\">  </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">transact</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"p\">\\\\</span><span class=\"w\"> </span><span class=\"p\">[])</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">transaction</span><span class=\"p\">(</span>\n<span class=\"w\">      </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">fun</span><span class=\"o\">.</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">          </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">value</span>\n<span class=\"w\">          </span><span class=\"ss\">:ok</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"ss\">:transaction_commited</span>\n<span class=\"w\">          </span><span class=\"p\">{</span><span class=\"ss\">:error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">reason</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">rollback</span><span class=\"p\">(</span><span class=\"n\">reason</span><span class=\"p\">)</span>\n<span class=\"w\">          </span><span class=\"ss\">:error</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">rollback</span><span class=\"p\">(</span><span class=\"ss\">:transaction_rollback_error</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"k\">end</span>\n<span class=\"w\">      </span><span class=\"k\">end</span><span class=\"p\">,</span>\n<span class=\"w\">      </span><span class=\"n\">opts</span>\n<span class=\"w\">    </span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<h2>Ecto.Multi vs Repo.transact</h2>\n\n<p>Lets say we want to take the typical user registration flow as an example. If\nwe want to insert a user, log the action to an audit table and also enqueue a job\nto send a confirmation email.</p>\n\n<p>We would have something like this using an Ecto.Multi:</p>\n\n<h4>Ecto.Multi implementation</h4>\n<div class=\"highlight\"><pre><code class=\"language-elixir\"><span></span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">register_user</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"nc\">Multi</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Multi</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"ss\">:user</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nc\">Accounts</span><span class=\"o\">.</span><span class=\"n\">new_user_changeset</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">))</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Multi</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"ss\">:log</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"p\">%{</span><span class=\"ss\">user</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nc\">Logs</span><span class=\"o\">.</span><span class=\"n\">log_action</span><span class=\"p\">(</span><span class=\"ss\">:user_registered</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">%{</span><span class=\"ss\">user</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">})</span>\n<span class=\"w\">  </span><span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Multi</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"ss\">:email_job</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"p\">%{</span><span class=\"ss\">user</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nc\">Mailer</span><span class=\"o\">.</span><span class=\"n\">enqueue_email_confirmation</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Repo</span><span class=\"o\">.</span><span class=\"n\">transaction</span><span class=\"p\">()</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">%{</span><span class=\"ss\">user</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"ss\">:error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_failed_operation</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">failed_value</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_changes_so_far</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"p\">{</span><span class=\"ss\">:error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">failed_value</span><span class=\"p\">}</span>\n<span class=\"w\">  </span><span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>As we can see, it is not the worst, but once we see the <code>Repo.transact/2</code> way,\nit will be clear which is better.</p>\n\n<h4>Repo.transact implementation</h4>\n<div class=\"highlight\"><pre><code class=\"language-elixir\"><span></span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">register_user</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"nc\">Repo</span><span class=\"o\">.</span><span class=\"n\">transact</span><span class=\"p\">(</span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"nc\">Accounts</span><span class=\"o\">.</span><span class=\"n\">create_user</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">),</span>\n<span class=\"w\">         </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_log</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"nc\">Logs</span><span class=\"o\">.</span><span class=\"n\">log_action</span><span class=\"p\">(</span><span class=\"ss\">:user_registered</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">),</span>\n<span class=\"w\">         </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_job</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"nc\">Mailer</span><span class=\"o\">.</span><span class=\"n\">enqueue_email_confirmation</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"w\">  </span><span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>As you can see, it is much shorter and easier to read. Another big benefit is\nthat we do not need to go down to the changeset level for inserting, we could\nuse our functions that perform <code>Repo.insert</code>s in them\n(<code>Accounts.new_user_changeset/1</code> vs <code>Accounts.create_user/1</code>). This lets us\ncompose many functions together from outside the context modules without having\nthe need to expose your changeset functions.</p>\n\n<p>The end result is the same, but it is a lot easier to read what is going on IMHO.</p>",
    "summary_detail": {
      "type": "text/html",
      "language": null,
      "base": "https://techblog.thescore.com/feed.xml",
      "value": "<p>After reading <a href=\"https://medium.com/very-big-things/towards-maintainable-elixir-the-core-and-the-interface-c267f0da43\">Towards Maintainable\nElixir</a>\nby Sa\u0161a Juri\u0107 and hearing about his famous <code>Repo.transact</code> in some of his\ntalks, I decided it was time to explore this for myself.</p>\n\n<p>This post takes into account that you (the reader) are aware and know why and\nwhen to use <a href=\"https://hexdocs.pm/ecto/Ecto.Multi.html\">Ecto.Multi</a>. But for\nthose unfamiliar, the TL;DR is you would use an <code>Ecto.Multi</code> when you want to\nperform multiple transaction that you want to be committed to the database in\none shot. Meaning, if one of the transactions fails, you would want to revert\nall other transactions in the run.</p>\n\n<h2>The Problem with Ecto.Multi</h2>\n\n<p>Lets get something straight, <strong>there is nothing wrong with using Ecto.Multi</strong>\nin your codebase. If it works for you, then it works. However after working\nwith it in multiple codebases I have started to see a common theme: it is very\nnoisy and can be sometimes hard to follow and DRY up. You can get around it by\nusing a lot of private functions to support the Ecto.Multi, but then your\nmodule just has a tons of wrapper functions.</p>\n\n<h2>What is Repo.transact/2?</h2>\n\n<blockquote>\n<p>The function Repo.transact is our small wrapper around\n<a href=\"https://hexdocs.pm/ecto/Ecto.Repo.html#c:transaction/2\">Repo.transaction/2</a>.\nThis function commits the transaction if the lambda returns <code>{:ok, result}</code>,\nrolling it back if the lambda returns <code>{:error, reason}</code>. In both cases, the\nfunction returns the result of the lambda. We chose this approach over\nEcto.Multi, because we\u2019ve experimentally established that multi adds a lot of\nnoise with no real benefits for our needs.</p>\n\n<p>-- <cite>Sa\u0161a Juri\u0107</cite></p>\n</blockquote>\n\n<h2>Function definition</h2>\n\n<p>Sa\u0161a never gives out the implementation of the function but I came up with\nthis, and it works great; Exactly as you would expect.</p>\n<div class=\"highlight\"><pre><code class=\"language-elixir\"><span></span><span class=\"kd\">defmodule</span><span class=\"w\"> </span><span class=\"nc\">MyApp.Repo</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"kn\">use</span><span class=\"w\"> </span><span class=\"nc\">Ecto.Repo</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"ss\">otp_app</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"ss\">:my_app</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"ss\">adapter</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Ecto.Adapters.Postgres</span>\n<span class=\"w\">  </span><span class=\"na\">@doc</span><span class=\"w\"> </span><span class=\"sh\">\"\"\"</span>\n<span class=\"w\">  </span><span class=\"sh\">A small wrapper around `Repo.transaction/2'.</span>\n<span class=\"sh\">  Commits the transaction if the lambda returns `{:ok, result}`, rolling it</span>\n<span class=\"sh\">  back if the lambda returns `{:error, reason}`. In both cases, the function</span>\n<span class=\"sh\">  returns the result of the lambda.</span>\n<span class=\"w\">  </span><span class=\"sh\">\"\"\"</span>\n<span class=\"w\">  </span><span class=\"na\">@spec</span><span class=\"w\"> </span><span class=\"n\">transact</span><span class=\"p\">((()</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"n\">keyword</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"p\">()}</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"ss\">:error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"p\">()}</span>\n<span class=\"w\">  </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">transact</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">opts</span><span class=\"w\"> </span><span class=\"p\">\\\\</span><span class=\"w\"> </span><span class=\"p\">[])</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">transaction</span><span class=\"p\">(</span>\n<span class=\"w\">      </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">fun</span><span class=\"o\">.</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">          </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">value</span>\n<span class=\"w\">          </span><span class=\"ss\">:ok</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"ss\">:transaction_commited</span>\n<span class=\"w\">          </span><span class=\"p\">{</span><span class=\"ss\">:error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">reason</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">rollback</span><span class=\"p\">(</span><span class=\"n\">reason</span><span class=\"p\">)</span>\n<span class=\"w\">          </span><span class=\"ss\">:error</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">rollback</span><span class=\"p\">(</span><span class=\"ss\">:transaction_rollback_error</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"k\">end</span>\n<span class=\"w\">      </span><span class=\"k\">end</span><span class=\"p\">,</span>\n<span class=\"w\">      </span><span class=\"n\">opts</span>\n<span class=\"w\">    </span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<h2>Ecto.Multi vs Repo.transact</h2>\n\n<p>Lets say we want to take the typical user registration flow as an example. If\nwe want to insert a user, log the action to an audit table and also enqueue a job\nto send a confirmation email.</p>\n\n<p>We would have something like this using an Ecto.Multi:</p>\n\n<h4>Ecto.Multi implementation</h4>\n<div class=\"highlight\"><pre><code class=\"language-elixir\"><span></span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">register_user</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"nc\">Multi</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Multi</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"ss\">:user</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nc\">Accounts</span><span class=\"o\">.</span><span class=\"n\">new_user_changeset</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">))</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Multi</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"ss\">:log</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"p\">%{</span><span class=\"ss\">user</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nc\">Logs</span><span class=\"o\">.</span><span class=\"n\">log_action</span><span class=\"p\">(</span><span class=\"ss\">:user_registered</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">%{</span><span class=\"ss\">user</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">})</span>\n<span class=\"w\">  </span><span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Multi</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"ss\">:email_job</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"p\">%{</span><span class=\"ss\">user</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nc\">Mailer</span><span class=\"o\">.</span><span class=\"n\">enqueue_email_confirmation</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Repo</span><span class=\"o\">.</span><span class=\"n\">transaction</span><span class=\"p\">()</span>\n<span class=\"w\">  </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">%{</span><span class=\"ss\">user</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"ss\">:error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_failed_operation</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">failed_value</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_changes_so_far</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"p\">{</span><span class=\"ss\">:error</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">failed_value</span><span class=\"p\">}</span>\n<span class=\"w\">  </span><span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>As we can see, it is not the worst, but once we see the <code>Repo.transact/2</code> way,\nit will be clear which is better.</p>\n\n<h4>Repo.transact implementation</h4>\n<div class=\"highlight\"><pre><code class=\"language-elixir\"><span></span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">register_user</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"nc\">Repo</span><span class=\"o\">.</span><span class=\"n\">transact</span><span class=\"p\">(</span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"nc\">Accounts</span><span class=\"o\">.</span><span class=\"n\">create_user</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">),</span>\n<span class=\"w\">         </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_log</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"nc\">Logs</span><span class=\"o\">.</span><span class=\"n\">log_action</span><span class=\"p\">(</span><span class=\"ss\">:user_registered</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">),</span>\n<span class=\"w\">         </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_job</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"nc\">Mailer</span><span class=\"o\">.</span><span class=\"n\">enqueue_email_confirmation</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"p\">{</span><span class=\"ss\">:ok</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"k\">end</span>\n<span class=\"w\">  </span><span class=\"k\">end</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>As you can see, it is much shorter and easier to read. Another big benefit is\nthat we do not need to go down to the changeset level for inserting, we could\nuse our functions that perform <code>Repo.insert</code>s in them\n(<code>Accounts.new_user_changeset/1</code> vs <code>Accounts.create_user/1</code>). This lets us\ncompose many functions together from outside the context modules without having\nthe need to expose your changeset functions.</p>\n\n<p>The end result is the same, but it is a lot easier to read what is going on IMHO.</p>"
    }
  }
}