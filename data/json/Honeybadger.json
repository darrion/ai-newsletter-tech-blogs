{
  "company": "Honeybadger",
  "title": "Honeybadger",
  "xmlUrl": "http://blog.honeybadger.io/feed.xml",
  "htmlUrl": "http://blog.honeybadger.io/",
  "content": "\n\n\n\n\n\n\n\n\n\n\n\nComposite primary keys in Rails - Honeybadger Developer Blog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n              Tour\n            \n\n\n\n\nFeatures\nError Tracking\nUptime Monitoring\nStatus Pages\nCron & Heartbeat Monitoring\n\n\nFrameworks\n\n\nRuby on Rails\nLaravel\nDjango\nPhoenix\n\n\n\n\nLanguages\n\n\nRuby\nPHP\nPython\nJavaScript\n\n\nElixir\nCrystal\nNode\nGo\n\n\n\n\n\n\n\n\nPricing\n\n\nBlog\n\n\nDocs\n\n\nStatus\n\n\nContact\n\n\nMeet the 'Badgers\n\n\n\n\nLog In\n\n\nGet started for FREE\n\n\n\n\n\n\n\n\n\n\n\nBlog Home\n\n\nHoneybadger\n\n\nRuby\n\n\nPHP\n\n\nPython\n\n\nElixir\n\n\nJavaScript\n\n\n\n\nPosts by Topic\n\n\n\nRuby (189)\nHoneybadger (81)\nRails (63)\nJavaScript (61)\nPHP (51)\nPython (33)\nLaravel (33)\nGo (16)\nBriefing (13)\nNode (13)\nDjango (12)\nDevOps (10)\nElixir (8)\nAws (8)\nBriefing 2021 Q3 (7)\nReact (7)\nFounderQuest (6)\nBriefing 2021 Q2 (6)\nError Handling (6)\nConferences (5)\nTesting (5)\nSecurity (4)\nDeveloper Tools (4)\nElastic Beanstalk (4)\nHeroku (3)\nDebugging (3)\nDocker (3)\nMarkdown (3)\nServerless (3)\nWebsockets (3)\nSql (3)\nEvents (2)\nJekyll (2)\nStartup Advice (2)\nGuest Post (2)\nSidekiq (2)\nGit (2)\nFront End (2)\nRspec (2)\nOauth (2)\nLogging (2)\nGraphQL (2)\nFlask (2)\nNextjs (2)\nDynamoDB (2)\nActive Record (2)\nCase Studies (1)\nPerformance (1)\nAllocation Stats (1)\nIntegrations (1)\nBitbucket (1)\nMobile (1)\nGophercon (1)\nClients (1)\nVue (1)\nLambda (1)\nTurbolinks (1)\nRedis (1)\nCircleCI (1)\nGitHub (1)\nCrystal (1)\nStripe (1)\nSaas (1)\nElasticsearch (1)\nImport Maps (1)\nBuild Systems (1)\nMinitest (1)\nGuzzle (1)\nTdd (1)\nI18n (1)\nGithub Actions (1)\nPostgresql (1)\nXdebug (1)\nZend Debugger (1)\nPhpdbg (1)\nPdf (1)\nMultithreading (1)\nConcurrency (1)\nWeb Workers (1)\nFargate (1)\nDjango Q (1)\nCelery (1)\nAmazon S3 (1)\nAws Lambda (1)\nAmazon Textract (1)\nSucrase (1)\nBabel (1)\nPdfs (1)\nHanami (1)\nDiscord (1)\nActive Support (1)\nBlazer (1)\nUbuntu (1)\nKamal (1)\n\n\n\n\n\n\nWrite For Us\n\n\nRSS Feed\n\n\n\n\n\n\n\nComposite primary keys in Rails\nThere are scenarios where a combination of columns needs to be used as the primary key. This is where composite primary keys come into play. This article explores composite primary keys, how they work in Rails, when they should be used, and what to consider when using them.\n\n\n\n\n                By Kingsley Silas\n\n\n#ruby #rails #active-record\n\n\n              Jan 17, 2024\n            \n\n\n\n\n\n\n\n\n\n\nPrimary keys are vital in the design of a relational database. They are crucial in uniquely identifying records.\nFor example, if you have a table of users, you will need to identify each record uniquely. This is where primary keys are used. Primary keys are usually single columns that auto-increment. There might be cases where you'll need a combination of column to serve as the primary key - this is where composite primary keys become helpful. This article will explore composite primary keys, how they work in Rails, when they should be used, and what to consider when using them.\nExplanation of primary keys\nPrimary keys help ensure that records are uniquely identifiable. This ensures data integrity and efficient retrieval.\nRails, by default, will automatically create an integer column called id when you generate a new table using Rails migration. You can use the default primary key or a custom primary key (i.e., choose another column as your primary key).\nclass CreateProducts < ActiveRecord::Migration[7.1]\n  def change\n    create_table :products, id: false, primary_key: :slug do |t|\n      t.string :title, null: false\n      t.string :slug, null: false\n      t.text :description\n      t.timestamps\n\n      t.index :slug, unique: true\n    end\n  end\nend\n\n\nIn the above code, the migration will create a products table; the primary key for this table will be the slug column.\nNext, we need to specify the primary key in the model:\nclass Product < ApplicationRecord\n  self.primary_key = :slug\nend\n\nNow, we can search for the product using the following:\nProduct.find('gX9FS0')\n\nThere are limitations when using single primary keys.\nLet's say we are working on an e-commerce application with order and product tables. You could have a join table called order_products to ensure data integrity. This is because an order can have multiple products, and a product can belong to different orders.\nThis table will hold the order_id and product_id. This is an instance of a many-to-many relationship.\nEach row in the order_products table will represent a unique combination of an order and a product. This scenario is typical for using something different from a singular primary key.\nWhat are composite primary keys?\nComposite primary keys are composed of multiple columns - the combination of the values in these columns must be unique within the table. With it, you can identify a record using various attributes based on the columns' value.\nFor example, if you have a table for student enrollments and want to ensure that no student is enrolled in the same course more than once. You could use a composite primary key consisting of both the student ID and the course ID. With this, you ensure uniqueness by looking at both columns at once.\nSo, composite primary keys provide a way to express complex relationships and enforce unique identification across multiple columns. They're handy for organizing and managing data in databases.\nHow do they work?\nWith Rails 7.1, you no longer need to rely on the CPK gem, as Rails 7.1 now supports composite primary keys natively.\nFirst, create your table:\nclass CreateOrderProducts < ActiveRecord::Migration[7.1]\n  def change\n    create_table :order_products, primary_key: [:order_id, :product_id] do |t|\n      t.integer :order_id\n      t.integer :product_id\n      t.integer :quantity\n    end\n  end\nend\n\nIn the above migrations, we set the primary_key to [:order_id, :product_id]. Now, whenever you want to fetch OrderProducts, you\u2019ll need to do something like this: OrderProduct.find([1,9]). Then, we can specify the primary_key in the model like this:\nclass OrderProduct < ApplicationRecord\n  self.primary_key = [:order_id, :product_id]\n\n  belongs_to :order\n  belongs_to :product\nend\n\n\nWhen should you use them?\nAside from many-to-many relationships, composite primary keys can be helpful when working on a multi-tenant application. Imagine you have a multi-tenant application where users and each user belongs to a particular organization. It\u2019s possible to have a unique user_id within each organization, but the user_id itself might not be unique across the entire users table.\nIn this scenario, you could use a composite primary key of [:organisation_id, :user_id] to ensure that each user is uniquely identified across the entire application.\nclass CreateUsers < ActiveRecord::Migration[7.1]\n  def change\n    create_table :users, primary_key: [:organization_id, :user_id] do |t|\n      t.integer :organization_id\n      t.integer :user_id\n      t.string :name\n      t.string :email\n    end\n  end\nend\n\nConsiderations\nWhile composite primary keys can be beneficial, there are some things you need to consider;\n\nComposite primary keys can increase the complexity of your database schema and application logic.\nComposite primary keys can result in performance degradation when inserting new records.\nEnsure that your database systems support composite primary keys and the necessary operations your application needs.\n\nI suggest only using a composite primary key when necessary for your use case (i.e., when a single-column primary key won\u2019t suffice).\nConclusion\nIn this article, we've looked at the significance of composite primary keys, how they work in Rails and when they should be used. We also looked at things to consider when using them. At this point, you should be able to make informed decisions during database designs. It's essential to remember the importance of data integrity and relationships.\nThe tool (single or composite primary keys) to use depends on your application's requirements and the sort of data you're working with.\nYou need to approach your database design with the approach that best suits your needs.\n\n\nWhat to do next:\n\n\nTry Honeybadger for FREE\nHoneybadger helps you find and fix errors before your users\n                  can even report them. Get set up in minutes and check\n                  monitoring off your to-do list.\nStart free trial\nEasy 5-minute setup \u2014 No credit card required\n\n\nGet the Honeybadger newsletter\nEach month we share news, best practices, and stories from the DevOps & monitoring community\u2014exclusively for developers like you.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSign up\n\n\n\nInclude latest Ruby articles\n                              \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKingsley Silas\nKingsley works as a software engineer and enjoys writing technical articles.\n\n\n\n@kinsomicrote\n                      Author Twitter\n\n\n\nMore articles by Kingsley Silas\n\n\n\nMore Ruby articles\n\n\nDec 14, 2023\nDeploy a Rails app to a VPS with Kamal\n\n\nNov 20, 2023\nHow to build your own user authentication system in Rails\n\n\nNov 02, 2023\nHow to organize your code using Rails Concerns\n\n\nOct 16, 2023\nFactoryBot for Rails testing\n\n\nSep 18, 2023\nBuilding a Sinatra app in Ruby\n\n\nAug 28, 2023\nA step-by-step guide to building a Ruby gem from scratch\n\n\nAug 14, 2023\nHow the Rails params hash works\n\n\nJul 10, 2023\nHow to use enum attributes in Ruby on Rails\n\n\nJun 19, 2023\nIntro to Propshaft: A new asset pipeline for Rails\n\n\nMay 18, 2023\nDIY error monitoring for Ruby\n\n\n\n\n\n\n\nStop wasting time manually checking logs for errors!\n\nTry the only application health monitoring tool that allows you to track application errors, uptime, and cron jobs in one simple platform.\n\nKnow when critical errors occur, and which customers are affected.\nRespond instantly when your systems go down.\nImprove the health of your systems over time.\nFix problems before your customers can report them!\n\nAs developers ourselves, we hated wasting time tracking down errors\u2014so we built the system we always wanted.\nHoneybadger tracks everything you need and nothing you don't, creating one simple solution to keep your application running and error free so you can do what you do best\u2014release new code. Try it free and see for yourself.\n\nStart free trial\n\nSimple 5-minute setup \u2014 No credit card required\n\n\nLearn more\n\n\n\n\n\n\n                        \"We've looked at a lot of error management systems. Honeybadger is head and shoulders above the rest and somehow gets better with every new release.\"\n                        \u2014 Michael Smith, Cofounder & CTO of YvesBlue\n\n\n\n\n\nHoneybadger is trusted by top companies like:\n\n\n\n\n\n                  \u201cEveryone is in love with Honeybadger ... the UI is spot on.\u201d\n                  \n\nMolly Struve, Sr. Site Reliability Engineer, Netflix\n\n\nStart free trial\n\n\n\n\nGet Honeybadger's best Ruby articles in your inbox\nWe publish 1-2 times per month. Subscribe to get our Ruby articles as soon as we publish them.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet me in\n\n\n\n\n\n\n          Also send me the Honeybadger Newsletter\n\n\n\nWe're Honeybadger. We'll never send you spam; we will send you cool stuff like exclusive content, memes, and swag.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProduct\n\n\n\nError tracking\n\n\nUptime monitoring\n\n\nStatus pages\n\n\nCron & heartbeat monitoring\n\n\nIntegrations\n\n\nPlans & pricing\n\n\nHB vs. Error Trackers\n\n\nGDPR\n\n\nSecurity\n\n\n\n\n\nStacks\n\n\n\n\n\nRails\n\n\nLaravel\n\n\nDjango\n\n\nPhoenix\n\n\nJavaScript\n\n\nRuby\n\n\nNode\n\n\n\n\n\n\n\n\nPython\n\n\nPHP\n\n\nElixir\n\n\nCrystal\n\n\nGo\n\n\nCocoa\n\n\n\n\n\n\n\nCompany\n\n\n\nMeet the 'Badgers\n\n\nJob openings\n\n\nBrand assets\n\n\nTerms of use\n\n\nPrivacy statement\n\n\nContact us\n\n\n\n\n\nResources\n\n\n\nDeveloper docs\n\n\nDeveloper blog\n\n\nNewsletter\n\n\nExceptional Creatures\n\n\nFounderQuest\n\n\n Twitter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "latestPost": {
    "title": "Composite primary keys in Rails",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://www.honeybadger.io/blog/feed.xml",
      "value": "Composite primary keys in Rails"
    },
    "links": [
      {
        "rel": "alternate",
        "href": "https://www.honeybadger.io/blog/composite-keys-in-rails/",
        "type": "text/html"
      }
    ],
    "link": "https://www.honeybadger.io/blog/composite-keys-in-rails/",
    "id": "https://www.honeybadger.io/blog/composite-keys-in-rails/",
    "guidislink": false,
    "published": "2024-01-17T00:00:00+00:00",
    "published_parsed": [
      2024,
      1,
      17,
      0,
      0,
      0,
      2,
      17,
      0
    ],
    "updated": "2024-01-17T20:24:24+00:00",
    "updated_parsed": [
      2024,
      1,
      17,
      20,
      24,
      24,
      2,
      17,
      0
    ],
    "authors": [
      {
        "name": "Kingsley Silas"
      }
    ],
    "author_detail": {
      "name": "Kingsley Silas"
    },
    "author": "Kingsley Silas",
    "summary": "There are scenarios where a combination of columns needs to be used as the primary key. This is where composite primary keys come into play. This article explores composite primary keys, how they work in Rails, when they should be used, and what to consider when using them.",
    "summary_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://www.honeybadger.io/blog/feed.xml",
      "value": "There are scenarios where a combination of columns needs to be used as the primary key. This is where composite primary keys come into play. This article explores composite primary keys, how they work in Rails, when they should be used, and what to consider when using them."
    },
    "content": [
      {
        "type": "text/html",
        "language": null,
        "base": "https://www.honeybadger.io/blog/feed.xml",
        "value": "<p>Primary keys are vital in the design of a relational database. They are crucial in uniquely identifying records.</p>\n\n<p>For example, if you have a table of users, you will need to identify each record uniquely. This is where primary keys are used. Primary keys are usually single columns that auto-increment. There might be cases where you'll need a combination of column to serve as the primary key - this is where composite primary keys become helpful. This article will explore composite primary keys, how they work in Rails, when they should be used, and what to consider when using them.</p>\n\n<h2 id=\"explanation-of-primary-keys\">Explanation of primary keys</h2>\n\n<p>Primary keys help ensure that records are uniquely identifiable. This ensures data integrity and efficient retrieval.</p>\n\n<p>Rails, by default, will automatically create an <code>integer</code> column called <code>id</code> when you generate a new table using Rails migration. You can use the default primary key or a custom primary key (i.e., choose another column as your primary key).</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">CreateProducts</span> <span class=\"o\">&lt;</span> <span class=\"no\">ActiveRecord</span><span class=\"o\">::</span><span class=\"no\">Migration</span><span class=\"p\">[</span><span class=\"mf\">7.1</span><span class=\"p\">]</span>\n  <span class=\"k\">def</span> <span class=\"nf\">change</span>\n    <span class=\"n\">create_table</span> <span class=\"ss\">:products</span><span class=\"p\">,</span> <span class=\"ss\">id: </span><span class=\"kp\">false</span><span class=\"p\">,</span> <span class=\"ss\">primary_key: :slug</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">t</span><span class=\"o\">|</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">string</span> <span class=\"ss\">:title</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">string</span> <span class=\"ss\">:slug</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">text</span> <span class=\"ss\">:description</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">timestamps</span>\n\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">index</span> <span class=\"ss\">:slug</span><span class=\"p\">,</span> <span class=\"ss\">unique: </span><span class=\"kp\">true</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n</code></pre></div>\n<p>In the above code, the migration will create a <code>products</code> table; the primary key for this table will be the <code>slug</code> column.</p>\n\n<p>Next, we need to specify the primary key in the model:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">Product</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n  <span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"nf\">primary_key</span> <span class=\"o\">=</span> <span class=\"ss\">:slug</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Now, we can search for the product using the following:</p>\n<div class=\"highlight\"><pre class=\"highlight shell\"><code>Product.find<span class=\"o\">(</span><span class=\"s1\">'gX9FS0'</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>There are limitations when using single primary keys.</p>\n\n<p>Let's say we are working on an e-commerce application with <code>order</code> and <code>product</code> tables. You could have a join table called <code>order_products</code> to ensure data integrity. This is because an order can have multiple products, and a product can belong to different orders.\nThis table will hold the <code>order_id</code> and <code>product_id</code>. This is an instance of a many-to-many relationship.</p>\n\n<p>Each row in the <code>order_products</code> table will represent a unique combination of an order and a product. This scenario is typical for using something different from a singular primary key.</p>\n\n<h2 id=\"what-are-composite-primary-keys\">What are composite primary keys?</h2>\n\n<p>Composite primary keys are composed of multiple columns - the combination of the values in these columns must be unique within the table. With it, you can identify a record using various attributes based on the columns' value.</p>\n\n<p>For example, if you have a table for student enrollments and want to ensure that no student is enrolled in the same course more than once. You could use a composite primary key consisting of both the student ID and the course ID. With this, you ensure uniqueness by looking at both columns at once.</p>\n\n<p>So, composite primary keys provide a way to express complex relationships and enforce unique identification across multiple columns. They're handy for organizing and managing data in databases.</p>\n\n<h2 id=\"how-do-they-work\">How do they work?</h2>\n\n<p>With Rails 7.1, you no longer need to rely on the <a href=\"https://github.com/composite-primary-keys/composite_primary_keys\">CPK gem</a>, as Rails 7.1 now supports composite primary keys natively.</p>\n\n<p>First, create your table:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">CreateOrderProducts</span> <span class=\"o\">&lt;</span> <span class=\"no\">ActiveRecord</span><span class=\"o\">::</span><span class=\"no\">Migration</span><span class=\"p\">[</span><span class=\"mf\">7.1</span><span class=\"p\">]</span>\n  <span class=\"k\">def</span> <span class=\"nf\">change</span>\n    <span class=\"n\">create_table</span> <span class=\"ss\">:order_products</span><span class=\"p\">,</span> <span class=\"ss\">primary_key: </span><span class=\"p\">[</span><span class=\"ss\">:order_id</span><span class=\"p\">,</span> <span class=\"ss\">:product_id</span><span class=\"p\">]</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">t</span><span class=\"o\">|</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">integer</span> <span class=\"ss\">:order_id</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">integer</span> <span class=\"ss\">:product_id</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">integer</span> <span class=\"ss\">:quantity</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>In the above migrations, we set the primary_key to <code>[:order_id, :product_id]</code>. Now, whenever you want to fetch <code>OrderProducts</code>, you\u2019ll need to do something like this: <code>OrderProduct.find([1,9])</code>. Then, we can specify the <code>primary_key</code> in the model like this:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">OrderProduct</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n  <span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"nf\">primary_key</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"ss\">:order_id</span><span class=\"p\">,</span> <span class=\"ss\">:product_id</span><span class=\"p\">]</span>\n\n  <span class=\"n\">belongs_to</span> <span class=\"ss\">:order</span>\n  <span class=\"n\">belongs_to</span> <span class=\"ss\">:product</span>\n<span class=\"k\">end</span>\n\n</code></pre></div>\n<h2 id=\"when-should-you-use-them\">When should you use them?</h2>\n\n<p>Aside from many-to-many relationships, composite primary keys can be helpful when working on a multi-tenant application. Imagine you have a multi-tenant application where <code>users</code> and each user belongs to a particular <code>organization</code>. It\u2019s possible to have a unique <code>user_id</code> within each organization, but the <code>user_id</code> itself might not be unique across the entire <code>users</code> table.</p>\n\n<p>In this scenario, you could use a composite primary key of <code>[:organisation_id, :user_id]</code> to ensure that each user is uniquely identified across the entire application.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">CreateUsers</span> <span class=\"o\">&lt;</span> <span class=\"no\">ActiveRecord</span><span class=\"o\">::</span><span class=\"no\">Migration</span><span class=\"p\">[</span><span class=\"mf\">7.1</span><span class=\"p\">]</span>\n  <span class=\"k\">def</span> <span class=\"nf\">change</span>\n    <span class=\"n\">create_table</span> <span class=\"ss\">:users</span><span class=\"p\">,</span> <span class=\"ss\">primary_key: </span><span class=\"p\">[</span><span class=\"ss\">:organization_id</span><span class=\"p\">,</span> <span class=\"ss\">:user_id</span><span class=\"p\">]</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">t</span><span class=\"o\">|</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">integer</span> <span class=\"ss\">:organization_id</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">integer</span> <span class=\"ss\">:user_id</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">string</span> <span class=\"ss\">:name</span>\n      <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"nf\">string</span> <span class=\"ss\">:email</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<h2 id=\"considerations\">Considerations</h2>\n\n<p>While composite primary keys can be beneficial, there are some things you need to consider;</p>\n\n<ol>\n<li>Composite primary keys can increase the complexity of your database schema and application logic.</li>\n<li>Composite primary keys can result in <a href=\"https://shopify.engineering/how-to-introduce-composite-primary-keys-in-rails%23:~:text=There%20is%20one%20notable%20downside\">performance degradation</a> when inserting new records.</li>\n<li>Ensure that your database systems support composite primary keys and the necessary operations your application needs.</li>\n</ol>\n\n<p>I suggest only using a composite primary key when necessary for your use case (i.e., when a single-column primary key won\u2019t suffice).</p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>In this article, we've looked at the significance of composite primary keys, how they work in Rails and when they should be used. We also looked at things to consider when using them. At this point, you should be able to make informed decisions during database designs. It's essential to remember the importance of data integrity and relationships.</p>\n\n<p>The tool (single or composite primary keys) to use depends on your application's requirements and the sort of data you're working with.\nYou need to approach your database design with the approach that best suits your needs.</p>"
      }
    ]
  }
}