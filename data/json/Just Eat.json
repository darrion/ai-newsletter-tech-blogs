{
  "company": "Just Eat",
  "title": "Just Eat",
  "xmlUrl": "https://tech.just-eat.com/feed/",
  "htmlUrl": "https://tech.just-eat.com/",
  "content": "\n\n\n\n\n\n\n\n\n\n\n\nApp launching: OperationQueue to the rescue \u2013 Tech Blog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to content\n\n\n\nTech Blog\n\n\n\n\n\n\n\nCareers\nOpen Source\nSpeaking\n \n\n\nSearch for:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nApp launching: OperationQueue to the rescue \nFebruary 4, 2021Written by Luigi ParpinelArchitecture Concurrency iOS Mobile Performance\n\n\n\nThe challenge: MAD (Massive App Delegate)\nModern apps are complex, the iOS community has come up with a few architectural patterns to manage such complexity. Nonetheless, there is a step in the apps lifecycle where this complexity has not yet been tamed: the app launch. It\u2019s quite common to find bugs in which an app does not behave as expected, when launched from springboard shortcuts, or notifications. These bugs are usually related to:\nnon-linear navigation, this happens when an app is already running and you try to navigate to a screen that can\u2019t be reached from the current screenissues in managing the request because the app is launching from a cold start.\nAs developers we want our app to behave correctly and to launch as fast as it can. The iOS watchdog monitors the app\u2019s launch time, and terminates\u00a0 the app if the startup is not fast enough.\nThe complexity comes from all the steps that the app needs to perform to be ready to be used. These steps include things like fetching and applying feature flags, executing asynchronous network code, migrating databases, initializing third-party SDKs and other operations such as the handling of universal links, NSUserActivity or quick actions.\u00a0\nIt\u2019s important to note that some of these operations can be executed concurrently, while others should be done in a specific order.\nAnother source of complexity is time. The AppDelegate is (was, but this is out of topic for this post\u2026) the first object that you see when you create a new project and this usually means that it is one of the oldest files in your codebase. It is supposed to be used as an interface to communicate with the OS, but it ends up being an over complicated and confusing class, in which you can find every kind of code, from network code to UI code.\u00a0\nDivide et impera\nLet\u2019s define what we want to achieve. We want our app launching code to be:\nFastPredictableEncapsulatedDecoupledTestableMaintainable\u00a0\nTo achieve this we can use the divide et impera strategy. The app setup should be divided into small chunks of initialisation code following the single responsibility principle. These chunks will have dependencies between each other so we need to track which chunk depends on what. Conceptually the app is ready to be used when all these chunks have been executed. An important note is that the code of the chunks must be decoupled, but this does not mean that they can\u2019t be dependent on each other, for example one chunk can produce a result that another chunk will consume as its input. Once we have all these blocks of code we need one or more executors to run them.\nFoundation already provides a great way to achieve this: OperationQueue.\nEach chunk of code will be an operation. The operations are encapsulated and can be easily tested on their own. Their code is decoupled but it\u2019s very easy to define dependencies between operations in a declarative way and the framework will handle the dependencies for you. Dependencies can be even defined on operations enqueued on different queues running on different threads.\u00a0\nDefining dependencies in a declarative way will make it very easy to understand and maintain them. It will make your code predictable because you will always know in which order it will be executed.\nTo make our code faster and to avoid blocking the main thread for too long, we can use multiple queues to execute code in parallel. A possible setup could be:\nusing the main operation queue to execute the operations one by one on the main queue running on the main threadusing a background concurrent queue to execute in parallel multiple operations that do not need to be executed on the main queue, such as networking code or database management.\nThe OS will automatically scale the number of concurrently running operations based on the device resources (RAM, number of CPU cores, etc.) and the dependencies between the operations, which will guarantee the fastest possible execution and the most efficient resource usage.\nShow me some code (or pseudo-code)\nIt\u2019s not easy to provide a real and meaningful example of an app setup, but I want to provide a quick example. A common and complex-enough scenario, is when the user launches the app using a quick action from the home screen. It\u2019s quite easy to handle, isn\u2019t it?\nfunc application(_ application: UIApplication,\n                 didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n        if let shortcut = launchOptions?[.shortcutItem] as? UIApplicationShortcutItem {\n            doSomething(shortcut)\n        }\n\n        return true\n}\n\nSadly, it is not that easy\u2026 because we need to do other stuff first, like initialise the crash reporting sdk.\n func application(_ application: UIApplication,\n                  didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n        AnotherSDK(key: \"Th1s1s4S3cretK3y\")\n        \n        if let shortcut = launchOptions?[.shortcutItem] as? UIApplicationShortcutItem {\n            doSomething(shortcut)\n        }\n\n        return true\n    }\n\nDone! More or less.. Other things to consider include:\u00a0\nThe network call which should be fired as soon asthe app starts to fetch the user\u2019s data.The feature toggles should be fetched before performing the action, but after the SDK initialisation.\u00a0\n func application(_ application: UIApplication,\n                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n        AnotherSDK(key: \"Th1s1s4S3cretK3y\")\n        \n        let userDataTask = URLSession.shared.dataTask(with: self.userDataURL) { [unowned self] _, _, _ in\n            let featureToggleTask = URLSession.shared.dataTask(with: self.toggleURL) { _, _, _ in\n                if let shortcut = launchOptions?[.shortcutItem] as? UIApplicationShortcutItem {\n                    self.doSomething(shortcut)\n                }\n            }\n            featureToggleTask.resume()\n        }\n        userDataTask.resume()\n\n        return true\n    }\n\nHow easy is it to understand and change coupled code like this? It already starts to look like a Massive App Delegate.\nIn the following diagram you can see how the initialisation code can be split into operations and their dependencies (keep a lookout for circular dependencies to avoid potential deadlocks). The blocks represent the operations. The yellow blocks are the initialisations one and the green \u201chandle shortcut\u201d block is the action that the app should perform when the app is ready. The arrows show the dependencies between the blocks.\n\n\nNow that we know what we want to achieve, let\u2019s see how the code will look.\u00a0\n// The returned queue executes one operation at a time on the app\u2019s main thread\nlet mainOperationQueue = OperationQueue.main\n\nlet concurrentOperationQueue: OperationQueue = {\n    let queue = OperationQueue()\n    queue.qualityOfService = .userInitiated\n    return queue\n}()\n    \nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n    let handleQuickAction = BlockOperation { [unowned self] in\n        if let shortcut = launchOptions?[.shortcutItem] as? UIApplicationShortcutItem {\n            self.doSomething(shortcut)\n        }\n    }\n        \n    let sdkInitializationOperation = BlockOperation {\n        AnotherSDK(key: \"Th1s1s4S3cretK3y\")\n    }\n        \n    let fetchUserDataOperation = AsyncBlockOperation { [unowned self] operation in\n        let task = URLSession.shared.dataTask(with: self.userDataURL) { _, _, _ in\n            // Do something with the response\n            operation.finish()\n        }\n        task.resume()\n    }\n\n    let fetchFeatureToggleOperation = AsyncBlockOperation { [unowned self] operation in\n        let task = URLSession.shared.dataTask(with: self.toggleURL) { _, _, _ in\n            // Do something with the response\n            operation.finish()\n        }\n        task.resume()\n    }\n        \n        // Setting up the dependencies\n    handleQuickAction.addDependency(fetchUserDataOperation)\n    handleQuickAction.addDependency(fetchFeatureToggleOperation)\n    \n    fetchFeatureToggleOperation.addDependency(sdkInitializationOperation)\n        \n    mainOperationQueue.addOperations([handleQuickAction], waitUntilFinished: false)\n    concurrentOperationQueue.addOperations([sdkInitializationOperation,\n                                        \n    return true\n}\n\nThe operations can be moved away from the app delegate and from the application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool. The key point here is that each operation is self-contained, they can be tested separately and the dependency management between them is easy to change, it\u2019s declarative and it is decoupled from their creation, making it easy to modify the execution order and the concurrency model.\nNote: AsyncBlockOperation is a common Operation subclass that I suggest to add to your codebase. An example can be found here.\nConclusion\nIn software engineering there are always multiple solutions to address an issue and this is just one of the ways in which you can better handle the application setup.\nThe most important advantages in this solution are:\nIt is built-in in the iOS SDK. OperationQueue is available since iOS 2.0, it\u2019s been\u00a0 battle-tested over the years and it\u2019s good to rely on something supported by Apple for a critical part of the app such as the app setup;It is quite easy to implement. Making an operation starting from a block of code is very easy so it should be straightforward to refactor existing code with this approach;The declarative style for dependency management makes it very easy to write predictable code.\nOn top of all of that, every iOS developer should already be familiar with OperationQueue so it should be easy for everyone in your team to work with them without having to learn another framework or paradigm and, maybe, someone will enjoy this powerful tool even more!\n\n\n\n\nURLCache \u2013 Default size is not enough\n\n\n\n\nRelated Articles\n\n\n\nLessons learned from handling JWT on mobile\nRead More\n\n\n\nModular iOS Architecture @ Just Eat\nRead More\n\n\n\nEffective iOS error management\nRead More\n\n\n\n\n\n\n\n\n\n\u00a9 Just Eat Holding Ltd 2024. All rights reserved.\nCookie Policy\nPrivacy Policy\n\n\n\n\n\n\n\nManage Cookie Consent\n\n\n\n\n\n\nWe use cookies to optimize our website and our service.\n\n\n\n\n\nFunctional\n\n\n\nFunctional\n\n\t\t\t\t\t\t\t\tAlways active\t\t\t\t\t\t\t\n\n\n\n\n\n\nThe technical storage or access is strictly necessary for the legitimate purpose of enabling the use of a specific service explicitly requested by the subscriber or user, or for the sole purpose of carrying out the transmission of a communication over an electronic communications network.\n\n\n\n\n\nPreferences\n\n\nPreferences\n\n\n\n\n\n\n\nThe technical storage or access is necessary for the legitimate purpose of storing preferences that are not requested by the subscriber or user.\n\n\n\n\n\nStatistics\n\n\nStatistics\n\n\n\n\n\n\n\nThe technical storage or access that is used exclusively for statistical purposes.\nThe technical storage or access that is used exclusively for anonymous statistical purposes. Without a subpoena, voluntary compliance on the part of your Internet Service Provider, or additional records from a third party, information stored or retrieved for this purpose alone cannot usually be used to identify you.\n\n\n\n\n\nMarketing\n\n\nMarketing\n\n\n\n\n\n\n\nThe technical storage or access is required to create user profiles to send advertising, or to track the user on a website or across several websites for similar marketing purposes.\n\n\n\n\n\nManage options\nManage services\nManage {vendor_count} vendors\nRead more about these purposes\n\n\n\nAccept cookies\nDeny\nView preferences\nSave preferences\nView preferences\n\n\n{title}\n{title}\n{title}\n\n\n\nManage consent\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "latestPost": {
    "title": "App launching: OperationQueue to the rescue",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://tech.justeattakeaway.com:443/feed/",
      "value": "App launching: OperationQueue to the rescue"
    },
    "links": [
      {
        "rel": "alternate",
        "type": "text/html",
        "href": "https://tech.justeattakeaway.com/2021/02/04/app-launching-operationqueue-to-the-rescue/"
      }
    ],
    "link": "https://tech.justeattakeaway.com/2021/02/04/app-launching-operationqueue-to-the-rescue/",
    "authors": [
      {
        "name": "Luigi Parpinel"
      }
    ],
    "author": "Luigi Parpinel",
    "author_detail": {
      "name": "Luigi Parpinel"
    },
    "published": "Thu, 04 Feb 2021 18:29:37 +0000",
    "published_parsed": [
      2021,
      2,
      4,
      18,
      29,
      37,
      3,
      35,
      0
    ],
    "tags": [
      {
        "term": "iOS",
        "scheme": null,
        "label": null
      },
      {
        "term": "Mobile",
        "scheme": null,
        "label": null
      },
      {
        "term": "Architecture",
        "scheme": null,
        "label": null
      },
      {
        "term": "Concurrency",
        "scheme": null,
        "label": null
      },
      {
        "term": "Performance",
        "scheme": null,
        "label": null
      }
    ],
    "id": "https://tech.just-eat.com/?p=466245",
    "guidislink": false,
    "summary": "The challenge: MAD (Massive App Delegate) Modern apps are complex, the iOS community has come up with a few architectural patterns to manage such complexity. Nonetheless, there is a step in the apps lifecycle where this complexity has not yet been tamed: the app launch. It\u2019s quite common to find bugs in which an app...",
    "summary_detail": {
      "type": "text/html",
      "language": null,
      "base": "https://tech.justeattakeaway.com:443/feed/",
      "value": "The challenge: MAD (Massive App Delegate) Modern apps are complex, the iOS community has come up with a few architectural patterns to manage such complexity. Nonetheless, there is a step in the apps lifecycle where this complexity has not yet been tamed: the app launch. It\u2019s quite common to find bugs in which an app..."
    },
    "content": [
      {
        "type": "text/html",
        "language": null,
        "base": "https://tech.justeattakeaway.com:443/feed/",
        "value": "<h2><strong>The challenge: MAD (Massive App Delegate)</strong></h2>\n\n\n\n<p>Modern apps are complex, the iOS community has come up with a few architectural patterns to manage such complexity. Nonetheless, there is a step in the apps lifecycle where this complexity has not yet been tamed: the app launch. It\u2019s quite common to find bugs in which an app does not behave as expected, when launched from springboard shortcuts, or notifications. These bugs are usually related to:</p>\n\n\n\n<ul><li>non-linear navigation, this happens when an app is already running and you try to navigate to a screen that can\u2019t be reached from the current screen</li><li>issues in managing the request because the app is launching from a cold start.</li></ul>\n\n\n\n<p>As developers we want our app to behave correctly and to launch as fast as it can. The iOS watchdog monitors the app\u2019s launch time, and terminates&nbsp; the app if the startup is not fast enough.</p>\n\n\n\n<p>The complexity comes from all the steps that the app needs to perform to be ready to be used. These steps include things like fetching and applying feature flags, executing asynchronous network code, migrating databases, initializing third-party SDKs and other operations such as the handling of universal links, NSUserActivity or quick actions.&nbsp;</p>\n\n\n\n<p>It\u2019s important to note that some of these operations can be executed concurrently, while others should be done in a specific order.</p>\n\n\n\n<p>Another source of complexity is time. The AppDelegate is (<a href=\"https://developer.apple.com/documentation/swiftui/app\"><em>was</em></a>, but this is out of topic for this post&#8230;) the first object that you see when you create a new project and this usually means that it is one of the oldest files in your codebase. It is supposed to be used as an interface to communicate with the OS, but it ends up being an over complicated and confusing class, in which you can find every kind of code, from network code to UI code.&nbsp;</p>\n\n\n\n<h2><strong>Divide et impera</strong></h2>\n\n\n\n<p>Let\u2019s define what we want to achieve. We want our app launching code to be:</p>\n\n\n\n<ul><li>Fast</li><li>Predictable</li><li>Encapsulated</li><li>Decoupled</li><li>Testable</li><li>Maintainable&nbsp;</li></ul>\n\n\n\n<p>To achieve this we can use the <em>divide et impera</em> strategy. The app setup should be divided into small chunks of initialisation code following the <a href=\"https://en.wikipedia.org/wiki/Single-responsibility_principle\"><em>single responsibility principle</em></a>. These chunks will have dependencies between each other so we need to track which chunk depends on what. Conceptually the app is ready to be used when all these chunks have been executed. An important note is that the code of the chunks must be decoupled, but this does not mean that they can\u2019t be dependent on each other, for example one chunk can produce a result that another chunk will consume as its input. Once we have all these blocks of code we need one or more executors to run them.</p>\n\n\n\n<p>Foundation already provides a great way to achieve this: <a href=\"https://developer.apple.com/documentation/foundation/operationqueue\">OperationQueue</a>.</p>\n\n\n\n<p>Each chunk of code will be an <a href=\"https://developer.apple.com/documentation/foundation/operation\">operation</a>. The operations are encapsulated and can be easily tested on their own. Their code is decoupled but it\u2019s very easy to define dependencies between operations in a declarative way and the framework will handle the dependencies for you. Dependencies can be even defined on operations enqueued on different queues running on different threads.&nbsp;</p>\n\n\n\n<p>Defining dependencies in a declarative way will make it very easy to understand and maintain them. It will make your code predictable because you will always know in which order it will be executed.</p>\n\n\n\n<p>To make our code faster and to avoid blocking the main thread for too long, we can use multiple queues to execute code in parallel. A possible setup could be:</p>\n\n\n\n<ul><li>using the main operation queue to execute the operations one by one on the main queue running on the main thread</li><li>using a background concurrent queue to execute in parallel multiple operations that do not need to be executed on the main queue, such as networking code or database management.</li></ul>\n\n\n\n<p>The OS will automatically scale the number of concurrently running operations based on the device resources (RAM, number of CPU cores, etc.) and the dependencies between the operations, which will guarantee the fastest possible execution and the most efficient resource usage.</p>\n\n\n\n<h2><strong>Show me some code (or pseudo-code)</strong></h2>\n\n\n\n<p>It\u2019s not easy to provide a real and meaningful example of an app setup, but I want to provide a quick example. A common and complex-enough scenario, is when the user launches the app using a quick action from the home screen. It\u2019s quite easy to handle, isn\u2019t it?</p>\n\n\n\n<div class=\"wp-block-simple-code-block-ace\" style=\"height: 250px; margin-bottom: 50px;\"><pre class=\"wp-block-simple-code-block-ace\">func application(_ application: UIApplication,\n                 didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n        if let shortcut = launchOptions?[.shortcutItem] as? UIApplicationShortcutItem {\n            doSomething(shortcut)\n        }\n\n        return true\n}\n</pre></div>\n\n\n\n<p>Sadly, it is not that easy\u2026 because we need to do other stuff first, like initialise the crash reporting sdk.</p>\n\n\n\n<div class=\"wp-block-simple-code-block-ace\" style=\"height: 250px; margin-bottom: 50px;\"><pre class=\"wp-block-simple-code-block-ace\"> func application(_ application: UIApplication,\n                  didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n        AnotherSDK(key: \"Th1s1s4S3cretK3y\")\n        \n        if let shortcut = launchOptions?[.shortcutItem] as? UIApplicationShortcutItem {\n            doSomething(shortcut)\n        }\n\n        return true\n    }\n</pre></div>\n\n\n\n<p>Done! More or less.. Other things to consider include:&nbsp;</p>\n\n\n\n<ul><li>The network call which should be fired as soon asthe app starts to fetch the user\u2019s data.</li><li>The feature toggles should be fetched before performing the action, but after the SDK initialisation.&nbsp;</li></ul>\n\n\n\n<div class=\"wp-block-simple-code-block-ace\" style=\"height: 250px; margin-bottom: 50px;\"><pre class=\"wp-block-simple-code-block-ace\"> func application(_ application: UIApplication,\n                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n        AnotherSDK(key: \"Th1s1s4S3cretK3y\")\n        \n        let userDataTask = URLSession.shared.dataTask(with: self.userDataURL) { [unowned self] _, _, _ in\n            let featureToggleTask = URLSession.shared.dataTask(with: self.toggleURL) { _, _, _ in\n                if let shortcut = launchOptions?[.shortcutItem] as? UIApplicationShortcutItem {\n                    self.doSomething(shortcut)\n                }\n            }\n            featureToggleTask.resume()\n        }\n        userDataTask.resume()\n\n        return true\n    }\n</pre></div>\n\n\n\n<p>How easy is it to understand and change coupled code like this? It already starts to look like a Massive App Delegate.</p>\n\n\n\n<p>In the following diagram you can see how the initialisation code can be split into operations and their dependencies (keep a lookout for circular dependencies to avoid potential deadlocks). The blocks represent the operations. The yellow blocks are the initialisations one and the green \u201chandle shortcut\u201d block is the action that the app should perform when the app is ready. The arrows show the dependencies between the blocks.</p>\n\n\n\n<figure class=\"wp-block-image\"><img alt=\"\" src=\"https://lh6.googleusercontent.com/dl3HGOkGEOnmu12g0QlTnf1BNEnPstQfcn60JiJipP7jqAMQAy9YmHpj988TqZ5Td5qD1WuICP6T7_DHzSBcf_22U95tCGRe5cYwSZQ_-lRLCMZWwz-iOS6eH59ABPp44qxenajf\" /></figure>\n\n\n\n<p><a href=\"https://lucid.app/documents/edit/7d865c32-0d7f-46c6-acda-f97745fd9229/0?callback=close&amp;name=docs&amp;callback_type=back&amp;v=490&amp;s=595.4399999999999\"></a></p>\n\n\n\n<p>Now that we know what we want to achieve, let\u2019s see how the code will look.&nbsp;</p>\n\n\n\n<div class=\"wp-block-simple-code-block-ace\" style=\"height: 250px; margin-bottom: 50px;\"><pre class=\"wp-block-simple-code-block-ace\">// The returned queue executes one operation at a time on the app\u2019s main thread\nlet mainOperationQueue = OperationQueue.main\n\nlet concurrentOperationQueue: OperationQueue = {\n    let queue = OperationQueue()\n    queue.qualityOfService = .userInitiated\n    return queue\n}()\n    \nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n\n    let handleQuickAction = BlockOperation { [unowned self] in\n        if let shortcut = launchOptions?[.shortcutItem] as? UIApplicationShortcutItem {\n            self.doSomething(shortcut)\n        }\n    }\n        \n    let sdkInitializationOperation = BlockOperation {\n        AnotherSDK(key: \"Th1s1s4S3cretK3y\")\n    }\n        \n    let fetchUserDataOperation = AsyncBlockOperation { [unowned self] operation in\n        let task = URLSession.shared.dataTask(with: self.userDataURL) { _, _, _ in\n            // Do something with the response\n            operation.finish()\n        }\n        task.resume()\n    }\n\n    let fetchFeatureToggleOperation = AsyncBlockOperation { [unowned self] operation in\n        let task = URLSession.shared.dataTask(with: self.toggleURL) { _, _, _ in\n            // Do something with the response\n            operation.finish()\n        }\n        task.resume()\n    }\n        \n        // Setting up the dependencies\n    handleQuickAction.addDependency(fetchUserDataOperation)\n    handleQuickAction.addDependency(fetchFeatureToggleOperation)\n    \n    fetchFeatureToggleOperation.addDependency(sdkInitializationOperation)\n        \n    mainOperationQueue.addOperations([handleQuickAction], waitUntilFinished: false)\n    concurrentOperationQueue.addOperations([sdkInitializationOperation,\n                                        \n    return true\n}\n</pre></div>\n\n\n\n<p>The operations can be moved away from the app delegate and from the <em>application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool. </em>The key point here is that each operation is self-contained, they can be tested separately and the dependency management between them is easy to change, it\u2019s declarative and it is decoupled from their creation, making it easy to modify the execution order and the concurrency model.</p>\n\n\n\n<p>Note: <em>AsyncBlockOperation </em>is a common <em>Operation</em> subclass that I suggest to add to your codebase. An example can be found <a href=\"https://gist.github.com/gigisommo/0bebb9e7d6d3104cd99eeb9c51c0847e\">here</a>.</p>\n\n\n\n<h2>Conclusion</h2>\n\n\n\n<p>In software engineering there are always multiple solutions to address an issue and this is just one of the ways in which you can better handle the application setup.</p>\n\n\n\n<p>The most important advantages in this solution are:</p>\n\n\n\n<ul><li>It is built-in in the iOS SDK. OperationQueue is available since iOS 2.0, it\u2019s been&nbsp; battle-tested over the years and it\u2019s good to rely on something supported by Apple for a critical part of the app such as the app setup;</li><li>It is quite easy to implement. Making an operation starting from a block of code is very easy so it should be straightforward to refactor existing code with this approach;</li><li>The declarative style for dependency management makes it very easy to write predictable code.</li></ul>\n\n\n\n<p>On top of all of that, every iOS developer should already be familiar with OperationQueue so it should be easy for everyone in your team to work with them without having to learn another framework or paradigm and, maybe, someone will enjoy this powerful tool even more!</p>"
      }
    ]
  }
}