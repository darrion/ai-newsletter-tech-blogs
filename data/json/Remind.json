{
  "company": "Remind",
  "title": "Remind",
  "xmlUrl": "http://engineering.remind.com/feed.xml",
  "htmlUrl": "http://engineering.remind.com/",
  "content": "\n\n\n\n\n      \n        Transitive Closure in PostgreSQL\n      \n      | Remind\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRemind Engineering\n\n\n\n\n\n\nPosted 9/29/23\nTransitive Closure in PostgreSQL\n\n\nPeter Hamilton\nVP of Technology\n\n\n\n\n\n\n\nAt Remind we operate one of the largest communication tools for education in the United States and Canada. We have millions of parents, students, teachers and administrators use our application each day to improve learning outcomes by sending 10s of millions of messages per day. With this large scale usage we\u2019ve had many opportunities to innovate and some of our most recent work has been around using PostgreSQL to capture graph-based structure and efficiently query them.\nGraphs in a relational database\nOur particular dataset consists of multiple organization trees. In education, most classes belong to a school and most schools belong to a district. But some classes may belong to a department, which may belong to a school, which may belong to a college, which may belong to a campus, which may belong to a university. We wanted to build a system that could not only represent these hierarchies but do so in an efficient manner.\nAs a concrete example, here\u2019s how a middle school mach class might be represented:\n\nIn our database, we store these entities as an adjacency list. Note: We store these with UUIDs, but here we\u2019ll use the names to make it easier to follow.\n\n\n\norganization\nparent\n\n\n\n\nAlgebra I\nMaple Middle School\n\n\nMaple Middle School\nSpringfield District\n\n\nSpringfield District\nNULL\n\n\n\nCommon query patterns we have require finding all classes in a district, or finding the district a class belongs to.\nNaively, we need to traverse through Maple Middle School to determine that Algebra 1 is a descendent of Springfield District.\nOur goal was to make such queries fast and performant while maintaining accuracy.\nThere are a few techniques for doing this inside a PostgreSQL database:\n\nWe can traverse through the adjacency list using Recursive Queries.\nWe can use Nested Sets\nWe can materialize the Transitive Closure.\n\nWe started with option 1 but performance wasn\u2019t quite where we wanted it to be. Option 2 was a viable path, but concerns around maintenance and our update pattern (where leaf nodes are frequently added and removed) didn\u2019t seem like the right fit. So we went with Option 3.\nTransitive Closure\nThe transitive closure of a graph tells if one node is reachable from another node. In our Algebra 1 example above, we have 6 edges in the transitive closure:\n\nNote: We include self references here for reasons we\u2019ll explain in a bit.\nThe Edge: organization, ancestor, and distance\nThese are the columns that describe the edges in our graph. Given a class Algebra 1 in a school Maple Middle School in a district Springfield District, the edges look like:\n\n\n\norganization\ndistance\nancestor\n\n\n\n\nAlgebra 1\n0\nAlgebra 1\n\n\nAlgebra 1\n1\nMaple Middle School\n\n\nAlgebra 1\n2\nSpringfield District\n\n\nMaple Middle School\n0\nMaple Middle School\n\n\nMaple Middle School\n1\nSpringfield District\n\n\nSpringfield District\n0\nSpringfield District\n\n\n\norganization is the start node, ancestor is the end node and distance captures how many other nodes we had to go through to get there.\nThis is a really great schema for querying. We have organization tables like organization_memberships and we can perform simple queries like:\nselect\n  count(distinct \"user\")\nfrom organizations_closure\njoin organization_memberships using (organization)\nwhere ancestor = 'Springfield District'\n\nThis query will count the number of users enrolled in any class in the Springfield District. We didn\u2019t have to traverse through the schools, we could just enumerate the user enrollment directly by following the connection from district -> class.\nThe Proof: through_org, distance_to_through_org\nSomething missing from the above data is why an organization is considered an ancestor. Let\u2019s capture those reasons:\n\n\n\norganization\nancestor\nreason\n\n\n\n\nAlgebra I\nAlgebra I\nSelf\n\n\nAlgebra I\nMaple Middle School\nParent of Algebra I\n\n\nAlgebra I\nSpringfield District\nParent of Maple Middle School\n\n\nMaple Middle School\nMaple Middle School\nSelf\n\n\nMaple Middle School\nSpringfield District\nParent of Maple Middle School\n\n\nSpringfield District\nSpringfield District\nSelf\n\n\n\nEach reason is either Self or Parent of X where X is an established ancestor of the organization. In our schema we capture this by recording the through_org for each edge as well as the distance to the through_org. For self references these will be NULL. For any other references they will describe the node that must be travelled through to reach the ancestor. The resulting data looks like this:\n\n\n\norganization\ndistance\nancestor\nthrough_org\ndistance_to_through_org\n\n\n\n\nAlgebra 1\n0\nAlgebra 1\nNULL\nNULL\n\n\nMaple Middle School\n0\nMaple Middle School\nNULL\nNULL\n\n\nSpringfield District\n0\nSpringfield District\nNULL\nNULL\n\n\nAlgebra 1\n1\nMaple Middle School\nAlgebra 1\n0\n\n\nMaple Middle School\n1\nSpringfield District\nMaple Middle School\n0\n\n\nAlgebra 1\n2\nSpringfield District\nMaple Middle School\n1\n\n\n\nConstraints\nWith our columns in place, we want to ensure this data is correct and that we will not drift from our adjacency list.\nOur constraints:\n\nA row must either be a self reference or it must have a through_org .\nA self reference has a distance of 0. All other rows must have distance of distance_to_through_org + 1.\nA through_org must be an ancestor of organization (which can mean itself) and distance_to_through_org must match the distance from organization to through_org.\nIf there is a through_org, ancestor must be a direct parent of the through_org.\n\nWe can enforce these constraints in PostgreSQL:\n    \"organizations_closure_check\" CHECK (through_org IS NOT NULL OR organization = ancestor)\n\n    \"organizations_closure_distance_check\" CHECK (distance = 0 OR organization <> ancestor)\n    \"organizations_closure_distance_to_through_org_check\" CHECK (distance_to_through_org IS NULL AND distance = 0 OR distance_to_through_org = (distance - 1))\n\n    \"organizations_closure_through_org_distance_fk\" FOREIGN KEY (organization, through_org, distance_to_through_org) REFERENCES remind.organizations_closure(organization, ancestor, distance)\n\n    \"organizations_closure_through_org_fkey\" FOREIGN KEY (through_org, ancestor) REFERENCES remind.organizations(organization, parent) ON DELETE CASCADE\n\nFinally, we want to ensure referential integrity, so we ensure that ancestor is an organization that exists:\n    \"organizations_closure_ancestor_fkey\" FOREIGN KEY (ancestor) REFERENCES remind.organizations(organization) ON DELETE CASCADE\n\n(It\u2019s not necessary to have a foreign key on organization as every row has an eventual dependency on a self reference. For self references, organization = ancestor and so the foreign key on ancestor gives us what we need. Having the additional key wouldn\u2019t hurt, but it\u2019s not necessary.)\nWith these constraints in place, we are protected against stale data from intermediate nodes being improperly removed.\nPopulating\nTo populate this table, we can follow a recursive approach:\n\nEstablish self nodes as ancestors\nFor each ancestor, add its parent as a new ancestor\nIf an ancestor has no parent, do nothing\n\nReturning to our Algebra 1 example, from the above rules we can first establish the self references:\n\n\n\norganization\ndistance\nancestor\nthrough_org\ndistance_to_through_org\n\n\n\n\nAlgebra 1\n0\nAlgebra 1\nNULL\nNULL\n\n\nMaple Middle School\n0\nMaple Middle School\nNULL\nNULL\n\n\nSpringfield District\n0\nSpringfield District\nNULL\nNULL\n\n\n\nWe can then add immediate parents. Because organization is its own ancestor (from the self references), we can use those as through_org and use their parent as ancestor\n\n\n\norganization\ndistance\nancestor\nthrough_org\ndistance_to_through_org\n\n\n\n\nAlgebra 1\n0\nAlgebra 1\nNULL\nNULL\n\n\nMaple Middle School\n0\nMaple Middle School\nNULL\nNULL\n\n\nSpringfield District\n0\nSpringfield District\nNULL\nNULL\n\n\nAlgebra 1\n1\nMaple Middle School\nAlgebra 1\n0\n\n\nMaple Middle School\n1\nSpringfield District\nMaple Middle School\n0\n\n\n\nNow that we have parents in our table, we can use those parents to add grandparents\n\n\n\norganization\ndistance\nancestor\nthrough_org\ndistance_to_through_org\n\n\n\n\nAlgebra 1\n0\nAlgebra 1\nNULL\nNULL\n\n\nMaple Middle School\n0\nMaple Middle School\nNULL\nNULL\n\n\nSpringfield District\n0\nSpringfield District\nNULL\nNULL\n\n\nAlgebra 1\n1\nMaple Middle School\nAlgebra 1\n0\n\n\nMaple Middle School\n1\nSpringfield District\nMaple Middle School\n0\n\n\nAlgebra 1\n2\nSpringfield District\nMaple Middle School\n1\n\n\n\nAnd in this case, because Springfield District has no parent, we\u2019re done.\nFull Schema\nWhenever data is denormalized, the greatest risk is inconsistency. As we traverse more of the graph, a given relation depends on more and more rows. If a great-grandparent moves under another node, all of its children will need to be updated.\nOur goal was to find a way to leverage database constraints to ensure correctness.\nThis is the schema and constraints we landed on:\n                Table \"remind.organizations_closure\"\n         Column          |  Type   | Collation | Nullable | Default\n-------------------------+---------+-----------+----------+---------\n organization            | uuid    |           | not null |\n through_org             | uuid    |           |          |\n ancestor                | uuid    |           | not null |\n distance                | integer |           | not null |\n distance_to_through_org | integer |           |          |\n\nIndexes:\n    \"organizations_closure_pkey\" PRIMARY KEY, btree (organization, ancestor)\n    \"organizations_closure_ancestor_idx\" btree (ancestor)\n    \"organizations_closure_organization_ancestor_distance_idx\" UNIQUE, btree (organization, ancestor, distance)\n    \"organizations_closure_through_org_idx\" btree (through_org)\n\nCheck constraints:\n    \"organizations_closure_check\" CHECK (through_org IS NOT NULL OR organization = ancestor)\n    \"organizations_closure_distance_check\" CHECK (distance = 0 OR organization <> ancestor)\n    \"organizations_closure_distance_to_through_org_check\" CHECK (distance_to_through_org IS NULL AND distance = 0 OR distance_to_through_org = (distance - 1))\n\nForeign-key constraints:\n    \"organizations_closure_ancestor_fkey\" FOREIGN KEY (ancestor) REFERENCES remind.organizations(organization) ON DELETE CASCADE\n    \"organizations_closure_through_org_distance_fk\" FOREIGN KEY (organization, through_org, distance_to_through_org) REFERENCES remind.organizations_closure(organization, ancestor, distance)\n    \"organizations_closure_through_org_fkey\" FOREIGN KEY (through_org, ancestor) REFERENCES remind.organizations(organization, parent) ON DELETE CASCADE\n\nAdditional Invalid States\nWe also want to prevent any invalid states that we couldn\u2019t fully capture in our schema. The primary case we need to prevent is a cycle.\nTo prevent a cycle, we use the following function as a before insert trigger:\nCREATE FUNCTION remind.organizations_block_cycle() RETURNS trigger\n    LANGUAGE plpgsql\n    AS $$\n      begin\n        if exists (select from remind.organizations_closure where ancestor = NEW.organization and remind.organizations_closure.organization = NEW.parent) then\n          raise exception 'Cannot add descendant as parent, would create cycle';\n        else\n          return NEW;\n        end if;\n      end\n    $$;\n\nMaintenance\nNow that we have a schema and constraints that ensure correctness, we need a way to update it easily. While the schema will prevent invalid states, we don\u2019t want to hit these errors. We want the normal range of CRUD operations to propagate changes to these tables and keep them in sync.\nWe used the following functions in an after insert trigger:\nCREATE FUNCTION remind.organizations_rematerialize_closure(uuid) RETURNS void\n    LANGUAGE plpgsql\n    AS $_$\n      begin\n        -- This could maybe be reworked to recursively build the list of orgs that need to be\n        -- rematerialized and then materialize them all in one fell swoop.\n        perform remind.materialize_org_ancestors($1);\n\n        -- When we update the ancestors of the parent, we need to update all the children\n        -- so that they reflect the new grandparent, great-grandparent, etc.\n        perform remind.organizations_rematerialize_closure(organization) from (\n          select remind.organizations.organization\n          from remind.organizations\n          where remind.organizations.parent = $1\n        ) child_orgs;\n      end;\n    $_$;\n\nCREATE FUNCTION remind.materialize_org_ancestors(VARIADIC uuid[]) RETURNS void\n    LANGUAGE plpgsql\n    AS $_$\n      begin\n        with recursive closure as (\n          select\n            organizations.organization,\n            null::uuid as through_org,\n            organizations.organization as ancestor,\n            0 as distance,\n            null::integer as distance_to_through_org\n          from remind.organizations\n          where organization = any ($1)\n          union\n          select\n            closure.organization as organization,\n            organizations.organization as through_org,\n            organizations.parent as ancestor,\n            closure.distance + 1 as distance,\n            closure.distance as distance_to_through_org\n          from remind.organizations\n          join closure on (closure.ancestor = organizations.organization)\n          where organizations.parent is not null\n        )\n        insert into remind.organizations_closure (organization, through_org, ancestor, distance, distance_to_through_org)\n        select * from closure\n        on conflict (organization, ancestor) do nothing;\n      end\n      $_$;\n\nEssentially, we rematerialize all ancestors for a given org and then iterate through its children and rematerialize their ancestors (and continue until we\u2019ve reached all leaf nodes). This is a recursive process and it is why preventing cycles is essential.\nWhen rematerializing ancestors, we use a recursive CTE. On each iteration we track through_org and distance_to_through_org.\nFor deletes and updates we rely on our foreign keys on delete casade as well as a before update trigger to clean up rows that are no longer relevant.\nTesting Strategy\nThis is a lot of complexity. While we are confident the data in the table will be accurate, we were (rightfully) very concerned about application errors when a constraint blocks us from making a change. We decided that robust testing was essential to having confidence operationally.\nWhen we started this, we had been separately exploring a style of testing called property testing in a couple of different contexts. The core idea is that if you can create a simple model that captures your behavior, you can generate broad and nearly exhaustive test cases for a more complex implementation. In our case, the model is fairly straightforward (it\u2019s just a tree structure) and the materialization is fairly complex. It has worked very well for us.\nOur property tests (using the proptest crate) build an organization forest (or a collection of organization trees) in memory. We then sync this structure into the database and assert the following for each organization:\n\nAn organizations_closure row exists for the organization and each of its ancestors with the correct distance values. No other ancestors should exist.\nAn organizations_closure row exists for each of its descendants with the correct ancestor and with the correct distance values. No other descendants should exist.\n\nThen we mutate the tree with arbitrary actions. For each action we perform the mutation on our simple model as well as in the database.\n\n\n\nAction\nSimple Model\nComplex Model\n\n\n\n\nNothing\nNothing\nNothing\n\n\nDetach\nRemove from children, add to tree list\nupdate organizations set parent = null where organization = ?\n\n\nUpdate (1 step)\nRemove from old parent, add to new parent\nupdate organizations set parent = ? where organization = ?\n\n\nUpdate (2 step)\nRemove from old parent, add to new parent\nupdate organizations set parent = null where organization = ? followed by update organizations set parent = ? where organization = ?\n\n\nDelete (roll up children)\nMove children to grand parent, remove organization\nupdate organizations set parent = ? where parent = ? followed by delete from organizations where organization = ?\n\n\nDelete (detach children)\nAdd children to tree list, remove organization\nupdate organizations set parent = null where parent = ? followed by delete from organizations where organization = ?\n\n\n\nIn addition to these, we have a handful of other cases more specific to our product.\nWe then assert the same properties as before.\nThis testing strategy has been great. The proptest crate captures the generated tests that fail and includes them in all future runs as a regression suite. While developing we ran with 10k cases, but in our CI suite we now run with \u201cjust\u201d the default of 256 cases. The thoroughness of the testing approach has made adding additional actions (for example, \u201cArchiving\u201d an organization) easy to implement and has given us very high confidence as we roll new features out.\nRolling it out\nWe rely heavily on AWS Aurora with PostgreSQL. One of the great features available with Aurora are clones. In about 15 minutes, a Copy-on-Write clone can be spun up and be used for testing. With our full production dataset in a clone, we created the table and constraints and started populating it. It was no surprise that we had some cycles in our data set (a decade of organic data at scale means nothing is a surprise), but otherwise everything went smoothly.  We worked with our support team to clean up the cycles, added the tables to prod, and backfilled the data. Everything ran smoothly and we\u2019ve been using this table ever since.\nClosing\nWe use this to power a product that serves millions and millions of parents, students, teachers and administrators every day. It\u2019s improved performance, reduced load, and accelerated our team\u2019s ability to deliver value to our customers. A special thanks to all the team members at Remind who worked on this from conceptualization to running it in prod. Especially Phil Frost, who held the vision and set us on this path.\n\n\n\n\n\nLatest posts\n\n\n\n\n\n\n\nTransitive Closure in PostgreSQL\n9/29/23\nAt Remind we operate one of the largest communication tools for education in the United States and Canada. We have...\n\n\n\n\n\n\n\n\nReducing scaling costs with Betterscaling\n6/28/22\nBetterscaling was designed and implemented by Phil Frost. Phil was an exceptional engineer and a brilliant person, and he is...\n\n\n\n\n\n\n\n\nInclusive Language Updates\n1/21/22\nInclusive Language Overview\n\n\n\n\n\n\n\n\n\n\n\n  Interested in joining our team? \nView our job openings\n\n\n\n\n\n\n\nRemind\n\nGitHub\nLinkedIn\nTwitter\nRSS\n\n\n\n\n\n\n\n\n",
  "latestPost": {
    "title": "Transitive Closure in PostgreSQL",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://engineering.remind.com/feed.xml",
      "value": "Transitive Closure in PostgreSQL"
    },
    "summary": "<p>At Remind we operate one of the largest communication tools for education in the United States and Canada. We have millions of parents, students, teachers and administrators use our application each day to improve learning outcomes by sending 10s of millions of messages per day. With this large scale usage we\u2019ve had many opportunities to innovate and some of our most recent work has been around using PostgreSQL to capture graph-based structure and efficiently query them.</p>\n\n<h3 id=\"graphs-in-a-relational-database\">Graphs in a relational database</h3>\n<p>Our particular dataset consists of multiple organization trees. In education, most classes belong to a school and most schools belong to a district. But some classes may belong to a department, which may belong to a school, which may belong to a college, which may belong to a campus, which may belong to a university. We wanted to build a system that could not only represent these hierarchies but do so in an efficient manner.</p>\n\n<p>As a concrete example, here\u2019s how a middle school mach class might be represented:</p>\n\n<p><img alt=\"Simple Example\" src=\"https://s3.amazonaws.com/engineering.remind.com/transitive_closure/transitive_closure_example_simple.png\" /></p>\n\n<p>In our database, we store these entities as an adjacency list. Note: We store these with UUIDs, but here we\u2019ll use the names to make it easier to follow.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>parent</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra I</td>\n      <td>Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>Springfield District</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>NULL</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Common query patterns we have require finding all classes in a district, or finding the district a class belongs to.</p>\n\n<p>Naively, we need to traverse through <code class=\"language-plaintext highlighter-rouge\">Maple Middle School</code> to determine that <code class=\"language-plaintext highlighter-rouge\">Algebra 1</code> is a descendent of <code class=\"language-plaintext highlighter-rouge\">Springfield District</code>.</p>\n\n<p>Our goal was to make such queries fast and performant while maintaining accuracy.</p>\n\n<p>There are a few techniques for doing this inside a PostgreSQL database:</p>\n<ol>\n  <li>We can traverse through the adjacency list using <a href=\"https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE\">Recursive Queries</a>.</li>\n  <li>We can use <a href=\"https://en.wikipedia.org/wiki/Nested_set_model\">Nested Sets</a></li>\n  <li>We can materialize the <a href=\"https://en.wikipedia.org/wiki/Transitive_closure#In_graph_theory\">Transitive Closure</a>.</li>\n</ol>\n\n<p>We started with option 1 but performance wasn\u2019t quite where we wanted it to be. Option 2 was a viable path, but concerns around maintenance and our update pattern (where leaf nodes are frequently added and removed) didn\u2019t seem like the right fit. So we went with Option 3.</p>\n\n<h3 id=\"transitive-closure\">Transitive Closure</h3>\n<p>The transitive closure of a graph tells if one node is reachable from another node. In our <code class=\"language-plaintext highlighter-rouge\">Algebra 1</code> example above, we have 6 edges in the transitive closure:</p>\n\n<p><img alt=\"Example with Closure\" src=\"https://s3.amazonaws.com/engineering.remind.com/transitive_closure/transitive_closure_example_with_closure.png\" /></p>\n\n<p>Note: We include self references here for reasons we\u2019ll explain in a bit.</p>\n\n<h3 id=\"the-edge-organization-ancestor-and-distance\">The Edge: <code class=\"language-plaintext highlighter-rouge\">organization</code>, <code class=\"language-plaintext highlighter-rouge\">ancestor</code>, and <code class=\"language-plaintext highlighter-rouge\">distance</code></h3>\n<p>These are the columns that describe the edges in our graph. Given a class <code class=\"language-plaintext highlighter-rouge\">Algebra 1</code> in a school <code class=\"language-plaintext highlighter-rouge\">Maple Middle School</code> in a district <code class=\"language-plaintext highlighter-rouge\">Springfield District</code>, the edges look like:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>1</td>\n      <td>Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>2</td>\n      <td>Springfield District</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>1</td>\n      <td>Springfield District</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><code class=\"language-plaintext highlighter-rouge\">organization</code> is the start node, <code class=\"language-plaintext highlighter-rouge\">ancestor</code> is the end node and <code class=\"language-plaintext highlighter-rouge\">distance</code> captures how many other nodes we had to go through to get there.</p>\n\n<p>This is a really great schema for querying. We have organization tables like <code class=\"language-plaintext highlighter-rouge\">organization_memberships</code> and we can perform simple queries like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>select\n  count(distinct \"user\")\nfrom organizations_closure\njoin organization_memberships using (organization)\nwhere ancestor = 'Springfield District'\n</code></pre></div></div>\n<p>This query will count the number of users enrolled in any class in the <code class=\"language-plaintext highlighter-rouge\">Springfield District</code>. We didn\u2019t have to traverse through the schools, we could just enumerate the user enrollment directly by following the connection from <code class=\"language-plaintext highlighter-rouge\">district -&gt; class</code>.</p>\n\n<h3 id=\"the-proof-through_org-distance_to_through_org\">The Proof: <code class=\"language-plaintext highlighter-rouge\">through_org</code>, <code class=\"language-plaintext highlighter-rouge\">distance_to_through_org</code></h3>\n<p>Something missing from the above data is <em>why</em> an organization is considered an ancestor. Let\u2019s capture those reasons:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>ancestor</th>\n      <th>reason</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra I</td>\n      <td>Algebra I</td>\n      <td>Self</td>\n    </tr>\n    <tr>\n      <td>Algebra I</td>\n      <td>Maple Middle School</td>\n      <td>Parent of Algebra I</td>\n    </tr>\n    <tr>\n      <td>Algebra I</td>\n      <td>Springfield District</td>\n      <td>Parent of Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>Maple Middle School</td>\n      <td>Self</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>Springfield District</td>\n      <td>Parent of Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>Springfield District</td>\n      <td>Self</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Each <code class=\"language-plaintext highlighter-rouge\">reason</code> is either <code class=\"language-plaintext highlighter-rouge\">Self</code> or <code class=\"language-plaintext highlighter-rouge\">Parent of X</code> where <code class=\"language-plaintext highlighter-rouge\">X</code> is an established ancestor of the organization. In our schema we capture this by recording the <code class=\"language-plaintext highlighter-rouge\">through_org</code> for each edge as well as the distance to the <code class=\"language-plaintext highlighter-rouge\">through_org</code>. For self references these will be <code class=\"language-plaintext highlighter-rouge\">NULL</code>. For any other references they will describe the node that must be travelled through to reach the <code class=\"language-plaintext highlighter-rouge\">ancestor</code>. The resulting data looks like this:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n      <th>through_org</th>\n      <th>distance_to_through_org</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>1</td>\n      <td>Maple Middle School</td>\n      <td>Algebra 1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>1</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>2</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n\n<h4 id=\"constraints\">Constraints</h4>\n\n<p>With our columns in place, we want to ensure this data is correct and that we will not drift from our adjacency list.</p>\n\n<p>Our constraints:</p>\n<ol>\n  <li>A row must either be a self reference or it must have a <code class=\"language-plaintext highlighter-rouge\">through_org</code> .</li>\n  <li>A self reference has a <code class=\"language-plaintext highlighter-rouge\">distance</code> of 0. All other rows must have <code class=\"language-plaintext highlighter-rouge\">distance</code> of <code class=\"language-plaintext highlighter-rouge\">distance_to_through_org + 1</code>.</li>\n  <li>A <code class=\"language-plaintext highlighter-rouge\">through_org</code> must be an ancestor of <code class=\"language-plaintext highlighter-rouge\">organization</code> (which can mean itself) and <code class=\"language-plaintext highlighter-rouge\">distance_to_through_org</code> must match the distance from <code class=\"language-plaintext highlighter-rouge\">organization</code> to <code class=\"language-plaintext highlighter-rouge\">through_org</code>.</li>\n  <li>If there is a <code class=\"language-plaintext highlighter-rouge\">through_org</code>, <code class=\"language-plaintext highlighter-rouge\">ancestor</code> must be a direct parent of the <code class=\"language-plaintext highlighter-rouge\">through_org</code>.</li>\n</ol>\n\n<p>We can enforce these constraints in PostgreSQL:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"nv\">\"organizations_closure_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">through_org</span> <span class=\"k\">IS</span> <span class=\"k\">NOT</span> <span class=\"k\">NULL</span> <span class=\"k\">OR</span> <span class=\"n\">organization</span> <span class=\"o\">=</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n\n    <span class=\"nv\">\"organizations_closure_distance_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"k\">OR</span> <span class=\"n\">organization</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_distance_to_through_org_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">distance_to_through_org</span> <span class=\"k\">IS</span> <span class=\"k\">NULL</span> <span class=\"k\">AND</span> <span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"k\">OR</span> <span class=\"n\">distance_to_through_org</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n\n    <span class=\"nv\">\"organizations_closure_through_org_distance_fk\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">distance_to_through_org</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">distance</span><span class=\"p\">)</span>\n\n    <span class=\"nv\">\"organizations_closure_through_org_fkey\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">parent</span><span class=\"p\">)</span> <span class=\"k\">ON</span> <span class=\"k\">DELETE</span> <span class=\"k\">CASCADE</span>\n</code></pre></div></div>\n\n<p>Finally, we want to ensure referential integrity, so we ensure that <code class=\"language-plaintext highlighter-rouge\">ancestor</code> is an organization that exists:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"nv\">\"organizations_closure_ancestor_fkey\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">)</span> <span class=\"k\">ON</span> <span class=\"k\">DELETE</span> <span class=\"k\">CASCADE</span>\n</code></pre></div></div>\n<p>(It\u2019s not necessary to have a foreign key on <code class=\"language-plaintext highlighter-rouge\">organization</code> as every row has an eventual dependency on a self reference. For self references, <code class=\"language-plaintext highlighter-rouge\">organization = ancestor</code> and so the foreign key on <code class=\"language-plaintext highlighter-rouge\">ancestor</code> gives us what we need. Having the additional key wouldn\u2019t hurt, but it\u2019s not necessary.)</p>\n\n<p>With these constraints in place, we are protected against stale data from intermediate nodes being improperly removed.</p>\n\n<h3 id=\"populating\">Populating</h3>\n\n<p>To populate this table, we can follow a recursive approach:</p>\n<ol>\n  <li>Establish self nodes as ancestors</li>\n  <li>For each ancestor, add its parent as a new ancestor</li>\n  <li>If an ancestor has no parent, do nothing</li>\n</ol>\n\n<p>Returning to our <code class=\"language-plaintext highlighter-rouge\">Algebra 1</code> example, from the above rules we can first establish the self references:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n      <th>through_org</th>\n      <th>distance_to_through_org</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>We can then add immediate parents. Because <code class=\"language-plaintext highlighter-rouge\">organization</code> is its own <code class=\"language-plaintext highlighter-rouge\">ancestor</code> (from the self references), we can use those as <code class=\"language-plaintext highlighter-rouge\">through_org</code> and use their parent as <code class=\"language-plaintext highlighter-rouge\">ancestor</code></p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n      <th>through_org</th>\n      <th>distance_to_through_org</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>1</td>\n      <td>Maple Middle School</td>\n      <td>Algebra 1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>1</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Now that we have parents in our table, we can use those parents to add grandparents</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n      <th>through_org</th>\n      <th>distance_to_through_org</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>1</td>\n      <td>Maple Middle School</td>\n      <td>Algebra 1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>1</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>2</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>And in this case, because <code class=\"language-plaintext highlighter-rouge\">Springfield District</code> has no parent, we\u2019re done.</p>\n\n<h3 id=\"full-schema\">Full Schema</h3>\n<p>Whenever data is denormalized, the greatest risk is inconsistency. As we traverse more of the graph, a given relation depends on more and more rows. If a great-grandparent moves under another node, all of its children will need to be updated.</p>\n\n<p>Our goal was to find a way to leverage database constraints to ensure correctness.</p>\n\n<p>This is the schema and constraints we landed on:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>                <span class=\"k\">Table</span> <span class=\"nv\">\"remind.organizations_closure\"</span>\n         <span class=\"k\">Column</span>          <span class=\"o\">|</span>  <span class=\"k\">Type</span>   <span class=\"o\">|</span> <span class=\"k\">Collation</span> <span class=\"o\">|</span> <span class=\"k\">Nullable</span> <span class=\"o\">|</span> <span class=\"k\">Default</span>\n<span class=\"c1\">-------------------------+---------+-----------+----------+---------</span>\n <span class=\"n\">organization</span>            <span class=\"o\">|</span> <span class=\"n\">uuid</span>    <span class=\"o\">|</span>           <span class=\"o\">|</span> <span class=\"k\">not</span> <span class=\"k\">null</span> <span class=\"o\">|</span>\n <span class=\"n\">through_org</span>             <span class=\"o\">|</span> <span class=\"n\">uuid</span>    <span class=\"o\">|</span>           <span class=\"o\">|</span>          <span class=\"o\">|</span>\n <span class=\"n\">ancestor</span>                <span class=\"o\">|</span> <span class=\"n\">uuid</span>    <span class=\"o\">|</span>           <span class=\"o\">|</span> <span class=\"k\">not</span> <span class=\"k\">null</span> <span class=\"o\">|</span>\n <span class=\"n\">distance</span>                <span class=\"o\">|</span> <span class=\"nb\">integer</span> <span class=\"o\">|</span>           <span class=\"o\">|</span> <span class=\"k\">not</span> <span class=\"k\">null</span> <span class=\"o\">|</span>\n <span class=\"n\">distance_to_through_org</span> <span class=\"o\">|</span> <span class=\"nb\">integer</span> <span class=\"o\">|</span>           <span class=\"o\">|</span>          <span class=\"o\">|</span>\n\n<span class=\"n\">Indexes</span><span class=\"p\">:</span>\n    <span class=\"nv\">\"organizations_closure_pkey\"</span> <span class=\"k\">PRIMARY</span> <span class=\"k\">KEY</span><span class=\"p\">,</span> <span class=\"n\">btree</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_ancestor_idx\"</span> <span class=\"n\">btree</span> <span class=\"p\">(</span><span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_organization_ancestor_distance_idx\"</span> <span class=\"k\">UNIQUE</span><span class=\"p\">,</span> <span class=\"n\">btree</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">distance</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_through_org_idx\"</span> <span class=\"n\">btree</span> <span class=\"p\">(</span><span class=\"n\">through_org</span><span class=\"p\">)</span>\n\n<span class=\"k\">Check</span> <span class=\"k\">constraints</span><span class=\"p\">:</span>\n    <span class=\"nv\">\"organizations_closure_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">through_org</span> <span class=\"k\">IS</span> <span class=\"k\">NOT</span> <span class=\"k\">NULL</span> <span class=\"k\">OR</span> <span class=\"n\">organization</span> <span class=\"o\">=</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_distance_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"k\">OR</span> <span class=\"n\">organization</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_distance_to_through_org_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">distance_to_through_org</span> <span class=\"k\">IS</span> <span class=\"k\">NULL</span> <span class=\"k\">AND</span> <span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"k\">OR</span> <span class=\"n\">distance_to_through_org</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n\n<span class=\"k\">Foreign</span><span class=\"o\">-</span><span class=\"k\">key</span> <span class=\"k\">constraints</span><span class=\"p\">:</span>\n    <span class=\"nv\">\"organizations_closure_ancestor_fkey\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">)</span> <span class=\"k\">ON</span> <span class=\"k\">DELETE</span> <span class=\"k\">CASCADE</span>\n    <span class=\"nv\">\"organizations_closure_through_org_distance_fk\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">distance_to_through_org</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">distance</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_through_org_fkey\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">parent</span><span class=\"p\">)</span> <span class=\"k\">ON</span> <span class=\"k\">DELETE</span> <span class=\"k\">CASCADE</span>\n</code></pre></div></div>\n\n<h3 id=\"additional-invalid-states\">Additional Invalid States</h3>\n<p>We also want to prevent any invalid states that we couldn\u2019t fully capture in our schema. The primary case we need to prevent is a cycle.</p>\n\n<p>To prevent a cycle, we use the following function as a <code class=\"language-plaintext highlighter-rouge\">before insert</code> trigger:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">CREATE</span> <span class=\"k\">FUNCTION</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_block_cycle</span><span class=\"p\">()</span> <span class=\"k\">RETURNS</span> <span class=\"k\">trigger</span>\n    <span class=\"k\">LANGUAGE</span> <span class=\"n\">plpgsql</span>\n    <span class=\"k\">AS</span> <span class=\"err\">$$</span>\n      <span class=\"k\">begin</span>\n        <span class=\"n\">if</span> <span class=\"k\">exists</span> <span class=\"p\">(</span><span class=\"k\">select</span> <span class=\"k\">from</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span> <span class=\"k\">where</span> <span class=\"n\">ancestor</span> <span class=\"o\">=</span> <span class=\"k\">NEW</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"k\">and</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"o\">=</span> <span class=\"k\">NEW</span><span class=\"p\">.</span><span class=\"n\">parent</span><span class=\"p\">)</span> <span class=\"k\">then</span>\n          <span class=\"n\">raise</span> <span class=\"n\">exception</span> <span class=\"s1\">'Cannot add descendant as parent, would create cycle'</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span>\n          <span class=\"k\">return</span> <span class=\"k\">NEW</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span> <span class=\"n\">if</span><span class=\"p\">;</span>\n      <span class=\"k\">end</span>\n    <span class=\"err\">$$</span><span class=\"p\">;</span>\n</code></pre></div></div>\n\n<h3 id=\"maintenance\">Maintenance</h3>\n<p>Now that we have a schema and constraints that ensure correctness, we need a way to update it easily. While the schema will prevent invalid states, we don\u2019t want to hit these errors. We want the normal range of CRUD operations to propagate changes to these tables and keep them in sync.</p>\n\n<p>We used the following functions in an <code class=\"language-plaintext highlighter-rouge\">after insert</code> trigger:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">CREATE</span> <span class=\"k\">FUNCTION</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_rematerialize_closure</span><span class=\"p\">(</span><span class=\"n\">uuid</span><span class=\"p\">)</span> <span class=\"k\">RETURNS</span> <span class=\"n\">void</span>\n    <span class=\"k\">LANGUAGE</span> <span class=\"n\">plpgsql</span>\n    <span class=\"k\">AS</span> <span class=\"err\">$</span><span class=\"n\">_</span><span class=\"err\">$</span>\n      <span class=\"k\">begin</span>\n        <span class=\"c1\">-- This could maybe be reworked to recursively build the list of orgs that need to be</span>\n        <span class=\"c1\">-- rematerialized and then materialize them all in one fell swoop.</span>\n        <span class=\"n\">perform</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">materialize_org_ancestors</span><span class=\"p\">(</span><span class=\"err\">$</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n\n        <span class=\"c1\">-- When we update the ancestors of the parent, we need to update all the children</span>\n        <span class=\"c1\">-- so that they reflect the new grandparent, great-grandparent, etc.</span>\n        <span class=\"n\">perform</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_rematerialize_closure</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">)</span> <span class=\"k\">from</span> <span class=\"p\">(</span>\n          <span class=\"k\">select</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span>\n          <span class=\"k\">from</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span>\n          <span class=\"k\">where</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"err\">$</span><span class=\"mi\">1</span>\n        <span class=\"p\">)</span> <span class=\"n\">child_orgs</span><span class=\"p\">;</span>\n      <span class=\"k\">end</span><span class=\"p\">;</span>\n    <span class=\"err\">$</span><span class=\"n\">_</span><span class=\"err\">$</span><span class=\"p\">;</span>\n\n<span class=\"k\">CREATE</span> <span class=\"k\">FUNCTION</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">materialize_org_ancestors</span><span class=\"p\">(</span><span class=\"n\">VARIADIC</span> <span class=\"n\">uuid</span><span class=\"p\">[])</span> <span class=\"k\">RETURNS</span> <span class=\"n\">void</span>\n    <span class=\"k\">LANGUAGE</span> <span class=\"n\">plpgsql</span>\n    <span class=\"k\">AS</span> <span class=\"err\">$</span><span class=\"n\">_</span><span class=\"err\">$</span>\n      <span class=\"k\">begin</span>\n        <span class=\"k\">with</span> <span class=\"k\">recursive</span> <span class=\"n\">closure</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n          <span class=\"k\">select</span>\n            <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span><span class=\"p\">,</span>\n            <span class=\"k\">null</span><span class=\"p\">::</span><span class=\"n\">uuid</span> <span class=\"k\">as</span> <span class=\"n\">through_org</span><span class=\"p\">,</span>\n            <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"k\">as</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span>\n            <span class=\"mi\">0</span> <span class=\"k\">as</span> <span class=\"n\">distance</span><span class=\"p\">,</span>\n            <span class=\"k\">null</span><span class=\"p\">::</span><span class=\"nb\">integer</span> <span class=\"k\">as</span> <span class=\"n\">distance_to_through_org</span>\n          <span class=\"k\">from</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span>\n          <span class=\"k\">where</span> <span class=\"n\">organization</span> <span class=\"o\">=</span> <span class=\"k\">any</span> <span class=\"p\">(</span><span class=\"err\">$</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n          <span class=\"k\">union</span>\n          <span class=\"k\">select</span>\n            <span class=\"n\">closure</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"k\">as</span> <span class=\"n\">organization</span><span class=\"p\">,</span>\n            <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"k\">as</span> <span class=\"n\">through_org</span><span class=\"p\">,</span>\n            <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"k\">as</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span>\n            <span class=\"n\">closure</span><span class=\"p\">.</span><span class=\"n\">distance</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"k\">as</span> <span class=\"n\">distance</span><span class=\"p\">,</span>\n            <span class=\"n\">closure</span><span class=\"p\">.</span><span class=\"n\">distance</span> <span class=\"k\">as</span> <span class=\"n\">distance_to_through_org</span>\n          <span class=\"k\">from</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span>\n          <span class=\"k\">join</span> <span class=\"n\">closure</span> <span class=\"k\">on</span> <span class=\"p\">(</span><span class=\"n\">closure</span><span class=\"p\">.</span><span class=\"n\">ancestor</span> <span class=\"o\">=</span> <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span><span class=\"p\">)</span>\n          <span class=\"k\">where</span> <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"k\">is</span> <span class=\"k\">not</span> <span class=\"k\">null</span>\n        <span class=\"p\">)</span>\n        <span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">distance</span><span class=\"p\">,</span> <span class=\"n\">distance_to_through_org</span><span class=\"p\">)</span>\n        <span class=\"k\">select</span> <span class=\"o\">*</span> <span class=\"k\">from</span> <span class=\"n\">closure</span>\n        <span class=\"k\">on</span> <span class=\"n\">conflict</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">do</span> <span class=\"k\">nothing</span><span class=\"p\">;</span>\n      <span class=\"k\">end</span>\n      <span class=\"err\">$</span><span class=\"n\">_</span><span class=\"err\">$</span><span class=\"p\">;</span>\n</code></pre></div></div>\n<p>Essentially, we rematerialize all ancestors for a given org and then iterate through its children and rematerialize their ancestors (and continue until we\u2019ve reached all leaf nodes). This is a recursive process and it is why preventing cycles is essential.</p>\n\n<p>When rematerializing ancestors, we use a recursive CTE. On each iteration we track <code class=\"language-plaintext highlighter-rouge\">through_org</code> and <code class=\"language-plaintext highlighter-rouge\">distance_to_through_org</code>.</p>\n\n<p>For deletes and updates we rely on our foreign keys <code class=\"language-plaintext highlighter-rouge\">on delete casade</code> as well as a before update trigger to clean up rows that are no longer relevant.</p>\n\n<h3 id=\"testing-strategy\">Testing Strategy</h3>\n<p>This is a lot of complexity. While we are confident the data in the table will be accurate, we were (rightfully) very concerned about application errors when a constraint blocks us from making a change. We decided that robust testing was essential to having confidence operationally.</p>\n\n<p>When we started this, we had been separately exploring a style of testing called <a href=\"https://proptest-rs.github.io/proptest/intro.html\">property testing</a> in a couple of different contexts. The core idea is that if you can create a simple model that captures your behavior, you can generate broad and nearly exhaustive test cases for a more complex implementation. In our case, the model is fairly straightforward (it\u2019s just a tree structure) and the materialization is fairly complex. It has worked very well for us.</p>\n\n<p>Our property tests (using the <code class=\"language-plaintext highlighter-rouge\">proptest</code> crate) build an organization forest (or a collection of organization trees) in memory. We then sync this structure into the database and assert the following for each organization:</p>\n<ol>\n  <li>An <code class=\"language-plaintext highlighter-rouge\">organizations_closure</code> row exists for the organization and each of its ancestors with the correct distance values. No other ancestors should exist.</li>\n  <li>An <code class=\"language-plaintext highlighter-rouge\">organizations_closure</code> row exists for each of its descendants with the correct ancestor and with the correct distance values. No other descendants should exist.</li>\n</ol>\n\n<p>Then we mutate the tree with arbitrary actions. For each action we perform the mutation on our simple model as well as in the database.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Simple Model</th>\n      <th>Complex Model</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Nothing</td>\n      <td>Nothing</td>\n      <td>Nothing</td>\n    </tr>\n    <tr>\n      <td>Detach</td>\n      <td>Remove from children, add to tree list</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = null where organization = ?</code></td>\n    </tr>\n    <tr>\n      <td>Update (1 step)</td>\n      <td>Remove from old parent, add to new parent</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = ? where organization = ?</code></td>\n    </tr>\n    <tr>\n      <td>Update (2 step)</td>\n      <td>Remove from old parent, add to new parent</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = null where organization = ?</code> followed by <code class=\"language-plaintext highlighter-rouge\">update organizations set parent = ? where organization = ?</code></td>\n    </tr>\n    <tr>\n      <td>Delete (roll up children)</td>\n      <td>Move children to grand parent, remove organization</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = ? where parent = ?</code> followed by <code class=\"language-plaintext highlighter-rouge\">delete from organizations where organization = ?</code></td>\n    </tr>\n    <tr>\n      <td>Delete (detach children)</td>\n      <td>Add children to tree list, remove organization</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = null where parent = ?</code> followed by <code class=\"language-plaintext highlighter-rouge\">delete from organizations where organization = ?</code></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>In addition to these, we have a handful of other cases more specific to our product.</p>\n\n<p>We then assert the same properties as before.</p>\n\n<p>This testing strategy has been great. The <code class=\"language-plaintext highlighter-rouge\">proptest</code> crate captures the generated tests that fail and includes them in all future runs as a regression suite. While developing we ran with 10k cases, but in our CI suite we now run with \u201cjust\u201d the default of 256 cases. The thoroughness of the testing approach has made adding additional actions (for example, \u201cArchiving\u201d an organization) easy to implement and has given us very high confidence as we roll new features out.</p>\n\n<h3 id=\"rolling-it-out\">Rolling it out</h3>\n<p>We rely heavily on AWS Aurora with PostgreSQL. One of the great features available with Aurora are clones. In about 15 minutes, a Copy-on-Write clone can be spun up and be used for testing. With our full production dataset in a clone, we created the table and constraints and started populating it. It was no surprise that we had some cycles in our data set (a decade of organic data at scale means nothing is a surprise), but otherwise everything went smoothly.  We worked with our support team to clean up the cycles, added the tables to prod, and backfilled the data. Everything ran smoothly and we\u2019ve been using this table ever since.</p>\n\n<h2 id=\"closing\">Closing</h2>\n<p>We use this to power a product that serves millions and millions of parents, students, teachers and administrators every day. It\u2019s improved performance, reduced load, and accelerated our team\u2019s ability to deliver value to our customers. A special thanks to all the team members at Remind who worked on this from conceptualization to running it in prod. Especially Phil Frost, who held the vision and set us on this path.</p>",
    "summary_detail": {
      "type": "text/html",
      "language": null,
      "base": "https://engineering.remind.com/feed.xml",
      "value": "<p>At Remind we operate one of the largest communication tools for education in the United States and Canada. We have millions of parents, students, teachers and administrators use our application each day to improve learning outcomes by sending 10s of millions of messages per day. With this large scale usage we\u2019ve had many opportunities to innovate and some of our most recent work has been around using PostgreSQL to capture graph-based structure and efficiently query them.</p>\n\n<h3 id=\"graphs-in-a-relational-database\">Graphs in a relational database</h3>\n<p>Our particular dataset consists of multiple organization trees. In education, most classes belong to a school and most schools belong to a district. But some classes may belong to a department, which may belong to a school, which may belong to a college, which may belong to a campus, which may belong to a university. We wanted to build a system that could not only represent these hierarchies but do so in an efficient manner.</p>\n\n<p>As a concrete example, here\u2019s how a middle school mach class might be represented:</p>\n\n<p><img alt=\"Simple Example\" src=\"https://s3.amazonaws.com/engineering.remind.com/transitive_closure/transitive_closure_example_simple.png\" /></p>\n\n<p>In our database, we store these entities as an adjacency list. Note: We store these with UUIDs, but here we\u2019ll use the names to make it easier to follow.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>parent</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra I</td>\n      <td>Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>Springfield District</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>NULL</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Common query patterns we have require finding all classes in a district, or finding the district a class belongs to.</p>\n\n<p>Naively, we need to traverse through <code class=\"language-plaintext highlighter-rouge\">Maple Middle School</code> to determine that <code class=\"language-plaintext highlighter-rouge\">Algebra 1</code> is a descendent of <code class=\"language-plaintext highlighter-rouge\">Springfield District</code>.</p>\n\n<p>Our goal was to make such queries fast and performant while maintaining accuracy.</p>\n\n<p>There are a few techniques for doing this inside a PostgreSQL database:</p>\n<ol>\n  <li>We can traverse through the adjacency list using <a href=\"https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE\">Recursive Queries</a>.</li>\n  <li>We can use <a href=\"https://en.wikipedia.org/wiki/Nested_set_model\">Nested Sets</a></li>\n  <li>We can materialize the <a href=\"https://en.wikipedia.org/wiki/Transitive_closure#In_graph_theory\">Transitive Closure</a>.</li>\n</ol>\n\n<p>We started with option 1 but performance wasn\u2019t quite where we wanted it to be. Option 2 was a viable path, but concerns around maintenance and our update pattern (where leaf nodes are frequently added and removed) didn\u2019t seem like the right fit. So we went with Option 3.</p>\n\n<h3 id=\"transitive-closure\">Transitive Closure</h3>\n<p>The transitive closure of a graph tells if one node is reachable from another node. In our <code class=\"language-plaintext highlighter-rouge\">Algebra 1</code> example above, we have 6 edges in the transitive closure:</p>\n\n<p><img alt=\"Example with Closure\" src=\"https://s3.amazonaws.com/engineering.remind.com/transitive_closure/transitive_closure_example_with_closure.png\" /></p>\n\n<p>Note: We include self references here for reasons we\u2019ll explain in a bit.</p>\n\n<h3 id=\"the-edge-organization-ancestor-and-distance\">The Edge: <code class=\"language-plaintext highlighter-rouge\">organization</code>, <code class=\"language-plaintext highlighter-rouge\">ancestor</code>, and <code class=\"language-plaintext highlighter-rouge\">distance</code></h3>\n<p>These are the columns that describe the edges in our graph. Given a class <code class=\"language-plaintext highlighter-rouge\">Algebra 1</code> in a school <code class=\"language-plaintext highlighter-rouge\">Maple Middle School</code> in a district <code class=\"language-plaintext highlighter-rouge\">Springfield District</code>, the edges look like:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>1</td>\n      <td>Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>2</td>\n      <td>Springfield District</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>1</td>\n      <td>Springfield District</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><code class=\"language-plaintext highlighter-rouge\">organization</code> is the start node, <code class=\"language-plaintext highlighter-rouge\">ancestor</code> is the end node and <code class=\"language-plaintext highlighter-rouge\">distance</code> captures how many other nodes we had to go through to get there.</p>\n\n<p>This is a really great schema for querying. We have organization tables like <code class=\"language-plaintext highlighter-rouge\">organization_memberships</code> and we can perform simple queries like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>select\n  count(distinct \"user\")\nfrom organizations_closure\njoin organization_memberships using (organization)\nwhere ancestor = 'Springfield District'\n</code></pre></div></div>\n<p>This query will count the number of users enrolled in any class in the <code class=\"language-plaintext highlighter-rouge\">Springfield District</code>. We didn\u2019t have to traverse through the schools, we could just enumerate the user enrollment directly by following the connection from <code class=\"language-plaintext highlighter-rouge\">district -&gt; class</code>.</p>\n\n<h3 id=\"the-proof-through_org-distance_to_through_org\">The Proof: <code class=\"language-plaintext highlighter-rouge\">through_org</code>, <code class=\"language-plaintext highlighter-rouge\">distance_to_through_org</code></h3>\n<p>Something missing from the above data is <em>why</em> an organization is considered an ancestor. Let\u2019s capture those reasons:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>ancestor</th>\n      <th>reason</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra I</td>\n      <td>Algebra I</td>\n      <td>Self</td>\n    </tr>\n    <tr>\n      <td>Algebra I</td>\n      <td>Maple Middle School</td>\n      <td>Parent of Algebra I</td>\n    </tr>\n    <tr>\n      <td>Algebra I</td>\n      <td>Springfield District</td>\n      <td>Parent of Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>Maple Middle School</td>\n      <td>Self</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>Springfield District</td>\n      <td>Parent of Maple Middle School</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>Springfield District</td>\n      <td>Self</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Each <code class=\"language-plaintext highlighter-rouge\">reason</code> is either <code class=\"language-plaintext highlighter-rouge\">Self</code> or <code class=\"language-plaintext highlighter-rouge\">Parent of X</code> where <code class=\"language-plaintext highlighter-rouge\">X</code> is an established ancestor of the organization. In our schema we capture this by recording the <code class=\"language-plaintext highlighter-rouge\">through_org</code> for each edge as well as the distance to the <code class=\"language-plaintext highlighter-rouge\">through_org</code>. For self references these will be <code class=\"language-plaintext highlighter-rouge\">NULL</code>. For any other references they will describe the node that must be travelled through to reach the <code class=\"language-plaintext highlighter-rouge\">ancestor</code>. The resulting data looks like this:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n      <th>through_org</th>\n      <th>distance_to_through_org</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>1</td>\n      <td>Maple Middle School</td>\n      <td>Algebra 1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>1</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>2</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n\n<h4 id=\"constraints\">Constraints</h4>\n\n<p>With our columns in place, we want to ensure this data is correct and that we will not drift from our adjacency list.</p>\n\n<p>Our constraints:</p>\n<ol>\n  <li>A row must either be a self reference or it must have a <code class=\"language-plaintext highlighter-rouge\">through_org</code> .</li>\n  <li>A self reference has a <code class=\"language-plaintext highlighter-rouge\">distance</code> of 0. All other rows must have <code class=\"language-plaintext highlighter-rouge\">distance</code> of <code class=\"language-plaintext highlighter-rouge\">distance_to_through_org + 1</code>.</li>\n  <li>A <code class=\"language-plaintext highlighter-rouge\">through_org</code> must be an ancestor of <code class=\"language-plaintext highlighter-rouge\">organization</code> (which can mean itself) and <code class=\"language-plaintext highlighter-rouge\">distance_to_through_org</code> must match the distance from <code class=\"language-plaintext highlighter-rouge\">organization</code> to <code class=\"language-plaintext highlighter-rouge\">through_org</code>.</li>\n  <li>If there is a <code class=\"language-plaintext highlighter-rouge\">through_org</code>, <code class=\"language-plaintext highlighter-rouge\">ancestor</code> must be a direct parent of the <code class=\"language-plaintext highlighter-rouge\">through_org</code>.</li>\n</ol>\n\n<p>We can enforce these constraints in PostgreSQL:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"nv\">\"organizations_closure_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">through_org</span> <span class=\"k\">IS</span> <span class=\"k\">NOT</span> <span class=\"k\">NULL</span> <span class=\"k\">OR</span> <span class=\"n\">organization</span> <span class=\"o\">=</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n\n    <span class=\"nv\">\"organizations_closure_distance_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"k\">OR</span> <span class=\"n\">organization</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_distance_to_through_org_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">distance_to_through_org</span> <span class=\"k\">IS</span> <span class=\"k\">NULL</span> <span class=\"k\">AND</span> <span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"k\">OR</span> <span class=\"n\">distance_to_through_org</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n\n    <span class=\"nv\">\"organizations_closure_through_org_distance_fk\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">distance_to_through_org</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">distance</span><span class=\"p\">)</span>\n\n    <span class=\"nv\">\"organizations_closure_through_org_fkey\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">parent</span><span class=\"p\">)</span> <span class=\"k\">ON</span> <span class=\"k\">DELETE</span> <span class=\"k\">CASCADE</span>\n</code></pre></div></div>\n\n<p>Finally, we want to ensure referential integrity, so we ensure that <code class=\"language-plaintext highlighter-rouge\">ancestor</code> is an organization that exists:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"nv\">\"organizations_closure_ancestor_fkey\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">)</span> <span class=\"k\">ON</span> <span class=\"k\">DELETE</span> <span class=\"k\">CASCADE</span>\n</code></pre></div></div>\n<p>(It\u2019s not necessary to have a foreign key on <code class=\"language-plaintext highlighter-rouge\">organization</code> as every row has an eventual dependency on a self reference. For self references, <code class=\"language-plaintext highlighter-rouge\">organization = ancestor</code> and so the foreign key on <code class=\"language-plaintext highlighter-rouge\">ancestor</code> gives us what we need. Having the additional key wouldn\u2019t hurt, but it\u2019s not necessary.)</p>\n\n<p>With these constraints in place, we are protected against stale data from intermediate nodes being improperly removed.</p>\n\n<h3 id=\"populating\">Populating</h3>\n\n<p>To populate this table, we can follow a recursive approach:</p>\n<ol>\n  <li>Establish self nodes as ancestors</li>\n  <li>For each ancestor, add its parent as a new ancestor</li>\n  <li>If an ancestor has no parent, do nothing</li>\n</ol>\n\n<p>Returning to our <code class=\"language-plaintext highlighter-rouge\">Algebra 1</code> example, from the above rules we can first establish the self references:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n      <th>through_org</th>\n      <th>distance_to_through_org</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>We can then add immediate parents. Because <code class=\"language-plaintext highlighter-rouge\">organization</code> is its own <code class=\"language-plaintext highlighter-rouge\">ancestor</code> (from the self references), we can use those as <code class=\"language-plaintext highlighter-rouge\">through_org</code> and use their parent as <code class=\"language-plaintext highlighter-rouge\">ancestor</code></p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n      <th>through_org</th>\n      <th>distance_to_through_org</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>1</td>\n      <td>Maple Middle School</td>\n      <td>Algebra 1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>1</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Now that we have parents in our table, we can use those parents to add grandparents</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>organization</th>\n      <th>distance</th>\n      <th>ancestor</th>\n      <th>through_org</th>\n      <th>distance_to_through_org</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Algebra 1</td>\n      <td>0</td>\n      <td>Algebra 1</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>0</td>\n      <td>Maple Middle School</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Springfield District</td>\n      <td>0</td>\n      <td>Springfield District</td>\n      <td>NULL</td>\n      <td>NULL</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>1</td>\n      <td>Maple Middle School</td>\n      <td>Algebra 1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Maple Middle School</td>\n      <td>1</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <td>Algebra 1</td>\n      <td>2</td>\n      <td>Springfield District</td>\n      <td>Maple Middle School</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>And in this case, because <code class=\"language-plaintext highlighter-rouge\">Springfield District</code> has no parent, we\u2019re done.</p>\n\n<h3 id=\"full-schema\">Full Schema</h3>\n<p>Whenever data is denormalized, the greatest risk is inconsistency. As we traverse more of the graph, a given relation depends on more and more rows. If a great-grandparent moves under another node, all of its children will need to be updated.</p>\n\n<p>Our goal was to find a way to leverage database constraints to ensure correctness.</p>\n\n<p>This is the schema and constraints we landed on:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>                <span class=\"k\">Table</span> <span class=\"nv\">\"remind.organizations_closure\"</span>\n         <span class=\"k\">Column</span>          <span class=\"o\">|</span>  <span class=\"k\">Type</span>   <span class=\"o\">|</span> <span class=\"k\">Collation</span> <span class=\"o\">|</span> <span class=\"k\">Nullable</span> <span class=\"o\">|</span> <span class=\"k\">Default</span>\n<span class=\"c1\">-------------------------+---------+-----------+----------+---------</span>\n <span class=\"n\">organization</span>            <span class=\"o\">|</span> <span class=\"n\">uuid</span>    <span class=\"o\">|</span>           <span class=\"o\">|</span> <span class=\"k\">not</span> <span class=\"k\">null</span> <span class=\"o\">|</span>\n <span class=\"n\">through_org</span>             <span class=\"o\">|</span> <span class=\"n\">uuid</span>    <span class=\"o\">|</span>           <span class=\"o\">|</span>          <span class=\"o\">|</span>\n <span class=\"n\">ancestor</span>                <span class=\"o\">|</span> <span class=\"n\">uuid</span>    <span class=\"o\">|</span>           <span class=\"o\">|</span> <span class=\"k\">not</span> <span class=\"k\">null</span> <span class=\"o\">|</span>\n <span class=\"n\">distance</span>                <span class=\"o\">|</span> <span class=\"nb\">integer</span> <span class=\"o\">|</span>           <span class=\"o\">|</span> <span class=\"k\">not</span> <span class=\"k\">null</span> <span class=\"o\">|</span>\n <span class=\"n\">distance_to_through_org</span> <span class=\"o\">|</span> <span class=\"nb\">integer</span> <span class=\"o\">|</span>           <span class=\"o\">|</span>          <span class=\"o\">|</span>\n\n<span class=\"n\">Indexes</span><span class=\"p\">:</span>\n    <span class=\"nv\">\"organizations_closure_pkey\"</span> <span class=\"k\">PRIMARY</span> <span class=\"k\">KEY</span><span class=\"p\">,</span> <span class=\"n\">btree</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_ancestor_idx\"</span> <span class=\"n\">btree</span> <span class=\"p\">(</span><span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_organization_ancestor_distance_idx\"</span> <span class=\"k\">UNIQUE</span><span class=\"p\">,</span> <span class=\"n\">btree</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">distance</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_through_org_idx\"</span> <span class=\"n\">btree</span> <span class=\"p\">(</span><span class=\"n\">through_org</span><span class=\"p\">)</span>\n\n<span class=\"k\">Check</span> <span class=\"k\">constraints</span><span class=\"p\">:</span>\n    <span class=\"nv\">\"organizations_closure_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">through_org</span> <span class=\"k\">IS</span> <span class=\"k\">NOT</span> <span class=\"k\">NULL</span> <span class=\"k\">OR</span> <span class=\"n\">organization</span> <span class=\"o\">=</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_distance_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"k\">OR</span> <span class=\"n\">organization</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_distance_to_through_org_check\"</span> <span class=\"k\">CHECK</span> <span class=\"p\">(</span><span class=\"n\">distance_to_through_org</span> <span class=\"k\">IS</span> <span class=\"k\">NULL</span> <span class=\"k\">AND</span> <span class=\"n\">distance</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"k\">OR</span> <span class=\"n\">distance_to_through_org</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">distance</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n\n<span class=\"k\">Foreign</span><span class=\"o\">-</span><span class=\"k\">key</span> <span class=\"k\">constraints</span><span class=\"p\">:</span>\n    <span class=\"nv\">\"organizations_closure_ancestor_fkey\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">)</span> <span class=\"k\">ON</span> <span class=\"k\">DELETE</span> <span class=\"k\">CASCADE</span>\n    <span class=\"nv\">\"organizations_closure_through_org_distance_fk\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">distance_to_through_org</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">distance</span><span class=\"p\">)</span>\n    <span class=\"nv\">\"organizations_closure_through_org_fkey\"</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">parent</span><span class=\"p\">)</span> <span class=\"k\">ON</span> <span class=\"k\">DELETE</span> <span class=\"k\">CASCADE</span>\n</code></pre></div></div>\n\n<h3 id=\"additional-invalid-states\">Additional Invalid States</h3>\n<p>We also want to prevent any invalid states that we couldn\u2019t fully capture in our schema. The primary case we need to prevent is a cycle.</p>\n\n<p>To prevent a cycle, we use the following function as a <code class=\"language-plaintext highlighter-rouge\">before insert</code> trigger:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">CREATE</span> <span class=\"k\">FUNCTION</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_block_cycle</span><span class=\"p\">()</span> <span class=\"k\">RETURNS</span> <span class=\"k\">trigger</span>\n    <span class=\"k\">LANGUAGE</span> <span class=\"n\">plpgsql</span>\n    <span class=\"k\">AS</span> <span class=\"err\">$$</span>\n      <span class=\"k\">begin</span>\n        <span class=\"n\">if</span> <span class=\"k\">exists</span> <span class=\"p\">(</span><span class=\"k\">select</span> <span class=\"k\">from</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span> <span class=\"k\">where</span> <span class=\"n\">ancestor</span> <span class=\"o\">=</span> <span class=\"k\">NEW</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"k\">and</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"o\">=</span> <span class=\"k\">NEW</span><span class=\"p\">.</span><span class=\"n\">parent</span><span class=\"p\">)</span> <span class=\"k\">then</span>\n          <span class=\"n\">raise</span> <span class=\"n\">exception</span> <span class=\"s1\">'Cannot add descendant as parent, would create cycle'</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span>\n          <span class=\"k\">return</span> <span class=\"k\">NEW</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span> <span class=\"n\">if</span><span class=\"p\">;</span>\n      <span class=\"k\">end</span>\n    <span class=\"err\">$$</span><span class=\"p\">;</span>\n</code></pre></div></div>\n\n<h3 id=\"maintenance\">Maintenance</h3>\n<p>Now that we have a schema and constraints that ensure correctness, we need a way to update it easily. While the schema will prevent invalid states, we don\u2019t want to hit these errors. We want the normal range of CRUD operations to propagate changes to these tables and keep them in sync.</p>\n\n<p>We used the following functions in an <code class=\"language-plaintext highlighter-rouge\">after insert</code> trigger:</p>\n<div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">CREATE</span> <span class=\"k\">FUNCTION</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_rematerialize_closure</span><span class=\"p\">(</span><span class=\"n\">uuid</span><span class=\"p\">)</span> <span class=\"k\">RETURNS</span> <span class=\"n\">void</span>\n    <span class=\"k\">LANGUAGE</span> <span class=\"n\">plpgsql</span>\n    <span class=\"k\">AS</span> <span class=\"err\">$</span><span class=\"n\">_</span><span class=\"err\">$</span>\n      <span class=\"k\">begin</span>\n        <span class=\"c1\">-- This could maybe be reworked to recursively build the list of orgs that need to be</span>\n        <span class=\"c1\">-- rematerialized and then materialize them all in one fell swoop.</span>\n        <span class=\"n\">perform</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">materialize_org_ancestors</span><span class=\"p\">(</span><span class=\"err\">$</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n\n        <span class=\"c1\">-- When we update the ancestors of the parent, we need to update all the children</span>\n        <span class=\"c1\">-- so that they reflect the new grandparent, great-grandparent, etc.</span>\n        <span class=\"n\">perform</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_rematerialize_closure</span><span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">)</span> <span class=\"k\">from</span> <span class=\"p\">(</span>\n          <span class=\"k\">select</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span>\n          <span class=\"k\">from</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span>\n          <span class=\"k\">where</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"err\">$</span><span class=\"mi\">1</span>\n        <span class=\"p\">)</span> <span class=\"n\">child_orgs</span><span class=\"p\">;</span>\n      <span class=\"k\">end</span><span class=\"p\">;</span>\n    <span class=\"err\">$</span><span class=\"n\">_</span><span class=\"err\">$</span><span class=\"p\">;</span>\n\n<span class=\"k\">CREATE</span> <span class=\"k\">FUNCTION</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">materialize_org_ancestors</span><span class=\"p\">(</span><span class=\"n\">VARIADIC</span> <span class=\"n\">uuid</span><span class=\"p\">[])</span> <span class=\"k\">RETURNS</span> <span class=\"n\">void</span>\n    <span class=\"k\">LANGUAGE</span> <span class=\"n\">plpgsql</span>\n    <span class=\"k\">AS</span> <span class=\"err\">$</span><span class=\"n\">_</span><span class=\"err\">$</span>\n      <span class=\"k\">begin</span>\n        <span class=\"k\">with</span> <span class=\"k\">recursive</span> <span class=\"n\">closure</span> <span class=\"k\">as</span> <span class=\"p\">(</span>\n          <span class=\"k\">select</span>\n            <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span><span class=\"p\">,</span>\n            <span class=\"k\">null</span><span class=\"p\">::</span><span class=\"n\">uuid</span> <span class=\"k\">as</span> <span class=\"n\">through_org</span><span class=\"p\">,</span>\n            <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"k\">as</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span>\n            <span class=\"mi\">0</span> <span class=\"k\">as</span> <span class=\"n\">distance</span><span class=\"p\">,</span>\n            <span class=\"k\">null</span><span class=\"p\">::</span><span class=\"nb\">integer</span> <span class=\"k\">as</span> <span class=\"n\">distance_to_through_org</span>\n          <span class=\"k\">from</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span>\n          <span class=\"k\">where</span> <span class=\"n\">organization</span> <span class=\"o\">=</span> <span class=\"k\">any</span> <span class=\"p\">(</span><span class=\"err\">$</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n          <span class=\"k\">union</span>\n          <span class=\"k\">select</span>\n            <span class=\"n\">closure</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"k\">as</span> <span class=\"n\">organization</span><span class=\"p\">,</span>\n            <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span> <span class=\"k\">as</span> <span class=\"n\">through_org</span><span class=\"p\">,</span>\n            <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"k\">as</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span>\n            <span class=\"n\">closure</span><span class=\"p\">.</span><span class=\"n\">distance</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"k\">as</span> <span class=\"n\">distance</span><span class=\"p\">,</span>\n            <span class=\"n\">closure</span><span class=\"p\">.</span><span class=\"n\">distance</span> <span class=\"k\">as</span> <span class=\"n\">distance_to_through_org</span>\n          <span class=\"k\">from</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations</span>\n          <span class=\"k\">join</span> <span class=\"n\">closure</span> <span class=\"k\">on</span> <span class=\"p\">(</span><span class=\"n\">closure</span><span class=\"p\">.</span><span class=\"n\">ancestor</span> <span class=\"o\">=</span> <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">organization</span><span class=\"p\">)</span>\n          <span class=\"k\">where</span> <span class=\"n\">organizations</span><span class=\"p\">.</span><span class=\"n\">parent</span> <span class=\"k\">is</span> <span class=\"k\">not</span> <span class=\"k\">null</span>\n        <span class=\"p\">)</span>\n        <span class=\"k\">insert</span> <span class=\"k\">into</span> <span class=\"n\">remind</span><span class=\"p\">.</span><span class=\"n\">organizations_closure</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">through_org</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">,</span> <span class=\"n\">distance</span><span class=\"p\">,</span> <span class=\"n\">distance_to_through_org</span><span class=\"p\">)</span>\n        <span class=\"k\">select</span> <span class=\"o\">*</span> <span class=\"k\">from</span> <span class=\"n\">closure</span>\n        <span class=\"k\">on</span> <span class=\"n\">conflict</span> <span class=\"p\">(</span><span class=\"n\">organization</span><span class=\"p\">,</span> <span class=\"n\">ancestor</span><span class=\"p\">)</span> <span class=\"k\">do</span> <span class=\"k\">nothing</span><span class=\"p\">;</span>\n      <span class=\"k\">end</span>\n      <span class=\"err\">$</span><span class=\"n\">_</span><span class=\"err\">$</span><span class=\"p\">;</span>\n</code></pre></div></div>\n<p>Essentially, we rematerialize all ancestors for a given org and then iterate through its children and rematerialize their ancestors (and continue until we\u2019ve reached all leaf nodes). This is a recursive process and it is why preventing cycles is essential.</p>\n\n<p>When rematerializing ancestors, we use a recursive CTE. On each iteration we track <code class=\"language-plaintext highlighter-rouge\">through_org</code> and <code class=\"language-plaintext highlighter-rouge\">distance_to_through_org</code>.</p>\n\n<p>For deletes and updates we rely on our foreign keys <code class=\"language-plaintext highlighter-rouge\">on delete casade</code> as well as a before update trigger to clean up rows that are no longer relevant.</p>\n\n<h3 id=\"testing-strategy\">Testing Strategy</h3>\n<p>This is a lot of complexity. While we are confident the data in the table will be accurate, we were (rightfully) very concerned about application errors when a constraint blocks us from making a change. We decided that robust testing was essential to having confidence operationally.</p>\n\n<p>When we started this, we had been separately exploring a style of testing called <a href=\"https://proptest-rs.github.io/proptest/intro.html\">property testing</a> in a couple of different contexts. The core idea is that if you can create a simple model that captures your behavior, you can generate broad and nearly exhaustive test cases for a more complex implementation. In our case, the model is fairly straightforward (it\u2019s just a tree structure) and the materialization is fairly complex. It has worked very well for us.</p>\n\n<p>Our property tests (using the <code class=\"language-plaintext highlighter-rouge\">proptest</code> crate) build an organization forest (or a collection of organization trees) in memory. We then sync this structure into the database and assert the following for each organization:</p>\n<ol>\n  <li>An <code class=\"language-plaintext highlighter-rouge\">organizations_closure</code> row exists for the organization and each of its ancestors with the correct distance values. No other ancestors should exist.</li>\n  <li>An <code class=\"language-plaintext highlighter-rouge\">organizations_closure</code> row exists for each of its descendants with the correct ancestor and with the correct distance values. No other descendants should exist.</li>\n</ol>\n\n<p>Then we mutate the tree with arbitrary actions. For each action we perform the mutation on our simple model as well as in the database.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Action</th>\n      <th>Simple Model</th>\n      <th>Complex Model</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Nothing</td>\n      <td>Nothing</td>\n      <td>Nothing</td>\n    </tr>\n    <tr>\n      <td>Detach</td>\n      <td>Remove from children, add to tree list</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = null where organization = ?</code></td>\n    </tr>\n    <tr>\n      <td>Update (1 step)</td>\n      <td>Remove from old parent, add to new parent</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = ? where organization = ?</code></td>\n    </tr>\n    <tr>\n      <td>Update (2 step)</td>\n      <td>Remove from old parent, add to new parent</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = null where organization = ?</code> followed by <code class=\"language-plaintext highlighter-rouge\">update organizations set parent = ? where organization = ?</code></td>\n    </tr>\n    <tr>\n      <td>Delete (roll up children)</td>\n      <td>Move children to grand parent, remove organization</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = ? where parent = ?</code> followed by <code class=\"language-plaintext highlighter-rouge\">delete from organizations where organization = ?</code></td>\n    </tr>\n    <tr>\n      <td>Delete (detach children)</td>\n      <td>Add children to tree list, remove organization</td>\n      <td><code class=\"language-plaintext highlighter-rouge\">update organizations set parent = null where parent = ?</code> followed by <code class=\"language-plaintext highlighter-rouge\">delete from organizations where organization = ?</code></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>In addition to these, we have a handful of other cases more specific to our product.</p>\n\n<p>We then assert the same properties as before.</p>\n\n<p>This testing strategy has been great. The <code class=\"language-plaintext highlighter-rouge\">proptest</code> crate captures the generated tests that fail and includes them in all future runs as a regression suite. While developing we ran with 10k cases, but in our CI suite we now run with \u201cjust\u201d the default of 256 cases. The thoroughness of the testing approach has made adding additional actions (for example, \u201cArchiving\u201d an organization) easy to implement and has given us very high confidence as we roll new features out.</p>\n\n<h3 id=\"rolling-it-out\">Rolling it out</h3>\n<p>We rely heavily on AWS Aurora with PostgreSQL. One of the great features available with Aurora are clones. In about 15 minutes, a Copy-on-Write clone can be spun up and be used for testing. With our full production dataset in a clone, we created the table and constraints and started populating it. It was no surprise that we had some cycles in our data set (a decade of organic data at scale means nothing is a surprise), but otherwise everything went smoothly.  We worked with our support team to clean up the cycles, added the tables to prod, and backfilled the data. Everything ran smoothly and we\u2019ve been using this table ever since.</p>\n\n<h2 id=\"closing\">Closing</h2>\n<p>We use this to power a product that serves millions and millions of parents, students, teachers and administrators every day. It\u2019s improved performance, reduced load, and accelerated our team\u2019s ability to deliver value to our customers. A special thanks to all the team members at Remind who worked on this from conceptualization to running it in prod. Especially Phil Frost, who held the vision and set us on this path.</p>"
    },
    "published": "Fri, 29 Sep 2023 00:00:00 +0000",
    "published_parsed": [
      2023,
      9,
      29,
      0,
      0,
      0,
      4,
      272,
      0
    ],
    "links": [
      {
        "rel": "alternate",
        "type": "text/html",
        "href": "http://engineering.remind.com/Transitive-Closure-In-PostgreSQL/"
      }
    ],
    "link": "http://engineering.remind.com/Transitive-Closure-In-PostgreSQL/",
    "id": "http://engineering.remind.com/Transitive-Closure-In-PostgreSQL/",
    "guidislink": false
  }
}