{
  "company": "Red Hat",
  "title": "Red Hat",
  "xmlUrl": "https://developers.redhat.com/blog/feed/atom/",
  "htmlUrl": "https://developers.redhat.com/blog/",
  "content": "\n\n\nMonolith to microservices: Breaking down apps the useful way | Red Hat Developer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      Skip to main content\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProducts\n\n\n\nFeatured\n\n\n\nRed Hat Enterprise Linux\n\n \n\n\n\nA secure, stable, and supported operating system.\n\n\n\nRed Hat OpenShift\n\n \n\n\n\nA cloud-native application platform.\n\n\n\nRed Hat Ansible Automation Platform\n\n \n\n\n\nSimple IT automation anyone can use.\n\n\n\n\nView All Red Hat Products\n\n\n\n\n\n\n\n\n\nLinux\n\n\n\nRed Hat Enterprise Linux\n\n\nRed Hat Universal Base Images (UBI)\n\n\nRed Hat Enterprise Linux for SAP\n\n\nMicrosoft SQL Server on Red Hat Enterprise Linux\n\n\nCentOS Linux\n\n\n\n\n\nJava runtimes & frameworks\n\n\n\nJBoss Enterprise Application Platform\n\n\nRed Hat build of Quarkus\n\n\nRed Hat build of OpenJDK\n\n\n\nView all\n\n\n\n\n\n\n\n\n\n\nKubernetes\n\n\n\nRed Hat OpenShift\n\n\nRed Hat OpenShift Service on AWS (ROSA)\n\n\nMicrosoft Azure Red Hat OpenShift\n\n\nRed Hat OpenShift Dedicated\n\n\nRed Hat OpenShift Data Science\n\n\n\n\n\nIntegration & App Connectivity\n\n\n\nRed Hat Service Interconnect\n\n\nAMQ Broker\n\n\n\nView all\n\n\n\n\n\n\n\n\n\n\nAutomation\n\n\n\nRed Hat Ansible Automation Platform\n\n\nRed Hat Ansible Automation Platform via AWS Marketplace\n\n\nRed Hat Ansible Lightspeed with IBM watsonx Code Assistant\n\n\nAnsible automation for applications and services\n\n\n\nView all\n\n\n\n\n\n\nDeveloper tools\n\n\n\nRed Hat Developer Hub\n\n\nRed Hat Trusted Software Supply Chain\n\n\nRed Hat OpenShift Dev Spaces\n\n\n\nView all\n\n\n\n\n\n\n\n\n\n\nDeveloper Sandbox for Red Hat OpenShift\n\n \n\n\n\nTry Red Hat products and technologies without setup or configuration fees for 30 days with this shared Openshift and Kubernetes cluster.\n\n\n\n\nTry at no cost\n\n\n\n\n\n\n\nTechnologies\n\n\n\nFeatured\n\n\n\nLinux\n\n \n\n\n\n\nKubernetes\n\n \n\n\n\n\nAutomation\n\n \n\n\n\n\nApp Dev Platform\n\n \n\n\n\n\n\nView All Technologies\n\n\n\n\n\n\n\n\n\nProgramming Languages & Frameworks\n\n\n\nJava\n\n\nPython\n\n\nC, C#, C++\n\n\n\n\n\nSystem Design & Architecture\n\n\n\nRed Hat architecture and design patterns\n\n\nMicroservices\n\n\nEvent-Driven Architecture\n\n\nDatabases\n\n\n\n\n\n\n\n\n\nDeveloper Productivity\n\n\n\nDeveloper Tools\n\n\nVisual Studio Code (VS Code)\n\n\nGitOps\n\n\n\n\n\nSecure Development & Architectures\n\n\n\nSecurity\n\n\nSecure coding\n\n\n\n\n\n\n\n\n\nPlatform Engineering\n\n\n\nDevOps\n\n\nDevSecOps\n\n\nAnsible automation for applications and services\n\n\n\n\n\nAutomated Data Processing\n\n\n\nAI/ML\n\n\nData Science\n\n\nApache Kafka on Kubernetes\n\n\n\nView All Technologies\n\n\n\n\n\n\n\n\n\n\nStart exploring in the Developer Sandbox for free\n\n \n\n\n\nTry Red Hat's products and technologies without setup or configuration.\n\n\n\n\nTry at no cost\n\n\n\n\n\n\n\nLearn\n\n\n\nFeatured\n\n\n\nKubernetes & Cloud Native\n\n \n\n\n\n\nLinux\n\n \n\n\n\n\nAutomation\n\n \n\n\n\n\nJava\n\n \n\n\n\n\nAI/ML\n\n \n\n\n\n\n\nView All Learning Resources\n\n\n\n\n\n\n\n\nInteractive Lessons and Learning Paths\n\n\n\nRed Hat Enterprise Linux\n\n\nRed Hat OpenShift\n\n\nRed Hat Ansible Automation Platform\n\n\nRed Hat OpenShift AI\n\n\nJava\n\n\n\n\n\nDeveloper Sandbox Activities\n\n\n\nGet Started\n\n\nTry Hands-On Activities\n\n\n\n\n\n\n\nE-Books\n\n\n\nGitOps Cookbook\n\n\nPodman in Action\n\n\nKubernetes Operators\n\n\nThe Path to GitOps\n\n\n\nView All E-books\n\n\n\n\n\n\nTutorials\n\n\n\nKubernetes\n\n\nApplication Development\n\n\n\n\n\n\n\nCheat Sheets\n\n\n\nLinux Commands\n\n\nBash Commands\n\n\nGit\n\n\nsystemd Commands\n\n\n\nView All Cheat Sheets\n\n\n\n\n\n\nAPI Catalog\n\n\n\nAPI Catalog\n\n\nLegacy Documentation\n\n\n\n\n\n\n\n\nRed Hat Learning\n\n \n\n\n\nBoost your technical skills to expert-level with the help of interactive lessons offered by various Red Hat Learning programs.\n\n\n\n\nExplore Red Hat Learning\n\n\n\n\n\n\n\nEvents\n\n\n\nDeveloper Events\n\n\n\nDevNation\n\nJoin developers across the globe for live and virtual events led by Red Hat technology experts.\n\n\n\n\nExplore All Events\n\n\n\n\n\n\n\n\n\nTech Talks\n\n\n\nGetting Gitops\n\n\nGitHub Makeover\n\n\nOpenTelemetry on Kubernetes\n\n\n\nView All Tech Talks\n\n\n\n\n\n\n\n\n\n\nDeep Dives\n\n\n\nQuinoa: A modern Quarkus UI with no hassles\n\n\nEvent-driven autoscaling through KEDA and Knative Integration\n\n\n\nView All Deep Dives\n\n\n\n\n\n\n\n\n\n\nRed Hat Summit\n\n \n\n\n\nExplore the Red Hat Summit 2023 virtual content hub and uncover insights that can fuel your future. Get on-demand access to the keynotes, sessions, and technical presentations from Red Hat Summit 2023 that are most relevant to your career.\n\n\n\n\nView the content hub\n\n\n\n\n\n\n\nDeveloper Sandbox\n\n\n\nDeveloper Sandbox (free)\n\n\n\nTry hands-on activities in the Developer Sandbox\n\nAccess Red Hat\u2019s products and technologies without setup or configuration, and start developing quicker than ever before with our new, no-cost sandbox environments.\n\n\n\nExplore the Developer Sandbox IDE\n\n\n\n\n\nFeatured Developer Sandbox activities\n\n\n\nDeploy a Java application on Kubernetes in minutes\n\n\nLearn Kubernetes using the Developer Sandbox\n\n\nDeploy full-stack JavaScript apps to the Developer Sandbox\n\n\n\n\n\nReady to  start developing apps?\n\n\n\n\nExplore the free Developer Sandbox\n\n\n\n\n\n\n\nBlog\n\n\n\n\n\n\nSearch\n\n\nSearch\n\n\n\n\n\n \n\n\n\n\n\n\n        All Red Hat\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArticle\nMonolith to microservices: Breaking down apps the useful way\n\n\nJanuary 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMicroservices\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\nMichael Thirion\n\n\nSenior Specialist Solution Architect\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                  Table of contents:\n                  \n\n\n\n\n\n\n\n\n\n\n\u201cDon\u2019t break your toys\u2026 unless it\u2019s to have 2 playable toys.\u201d\n\nA significant part of my 10-year career as a consultant in middleware and applications development has been centered on microservices architectures, still an important topic for IT modernization nowadays.\nAt the very beginning, it was important to just explain the concepts, what it was about and why it wasn\u2019t just another way to speak about service-oriented architecture (SOA). Then came best practices, patterns, and pitfalls.\nSome projects were greenfields, of course, but there were also many initiatives around modernizing monoliths by splitting them into smaller pieces.\nAfter a few years, I started to hear some negative feedback. That feedback highlighted and emphasized the higher complexity of the resulting solution. People were saying that the architecture was way more difficult to manage, that end-to-end visibility was a nightmare. Eventually, I even heard some people saying it would be better to go back to the traditional monoliths on traditional application servers.\nSo the question that came to my mind and that I tried to figure out by gathering information about their transformation projects was: \u201cDidn\u2019t you get any benefits from the microservices architecture?\u201d\nThat\u2019s the question I\u2019d like to explore with you here.\nWhere should I start?\nGoing from monolith to microservices is not an easy task. And the result will indeed probably be more complex to administer. So it\u2019s critical that the transformation is conducted for a purpose, and that some benefits show up at the end.\nA key question in a monolith-to-microservices transformation is: Where to split the monolith? How many pieces should I have\u2014one, five, ten? And, most importantly, why?\nLet\u2019s first look at some (non-exhaustive) elements that led to an architecture that didn't bring what was promised.\nWith microservices, I will save resources (thus money)\nNo, you won't. There\u2019s no way 10 GB can be bigger than 5 times 2 GB, which actually will easily turn into 5 times 2.5 GB or 3 GB because of the duplicated stack, e.g., the server and operating system.\nYou\u2019ll achieve better resource control by switching to a lightweight, more resource-efficient runtime\u2014for example, by going from an application server to a Spring Boot application, or to a Quarkus one. But this task will be made much easier if the application is first refactored as a set of components better fitting a new runtime environment.\nWith microservices, my applications will be more reliable\nNot really. Five tightly-coupled services will still fail altogether as one piece.\nYou\u2019ll achieve that by introducing circuit breakers, alternative flows, asynchronicity, loose coupling mechanisms, and other solutions of the same kind.\nSo, performing a microservices transformation with only those objectives in mind won\u2019t lead to happiness.\nMicroservices approach: A structure in a structure\nEven though the 2 concepts could be evaluated in isolation, we should consider the business-to-IT alignment before even thinking about microservices architectures. Business to IT alignment, on the technical perspective, comes down to the \u201cseparation of concerns\u201d principle, which states that never two microservices share the same responsibility and that one microservice never has more than exactly one responsibility. An attempt to improve business-to-IT alignment was given by SOA architecture and domain-driven design. We\u2019ll assume here that this part is something we can already leverage on.\nThe microservices approach comes on top of this to complement it. It adds technical considerations to the matter in order to provide more flexibility, with better scalability, shorter release cycle so shorter time-to-market and improved robustness with failure transparency; all of them together leading to a much higher efficiency.\nThe monolith breakdown pivots\nHere is a proposal of 4 pivots to drive a monolith-to-microservices breakdown activity in order to see an added value at the end.\n1. The scalability\nA monolith should be split into 2 parts when those 2 parts have a reason to scale independently from each other. The objective here is to increase flexibility.\nSo, if we detect, with experience, that one technical element of an application requires more resources than another under a specific load, breaking it down into 2 microservices could here help save resources (as not the whole application would need to scale but only a part of it).\nThe application of this principle can lead to a rather extreme example that trades higher flexibility for higher complexity where one component is split into its read operations runtime and its write operations runtime (also known as the CQRS pattern).\u00a0\n2. The ability to release more quickly\nThis is probably the one benefit that is expected the most, tightly linked to the time-to-market problem.\nThis aspect can be reactive or proactive:\nIt can be that we realize that, over time, one piece of the monolith was updated more often than the rest. The coupling of this piece with the rest of the application creates some friction that slows down the release process. In such a case, we can benefit from splitting down the application in 2 parts to add a decoupling.\nOr, we do want to be able to release a particular business function with a reduced time-to-market. However, this business function is embedded in a monolithic application with tight coupling to other business functions. Here, a split into microservices could allow us to insert the appropriate level of isolation for that function to be released at a much higher speed.\n3. Failure impact isolation\nImpact isolation is a key to application reliability.\nSometimes, statistics can show that one constituent of the monolith is more subject to errors than its other constituents. However, many errors usually lead to the entire monolith to become unresponsive.\nSplitting a monolith around that pivot can be a solution to improve the robustness of the overall business service.\nIt will help introduce error management concepts such as circuit breakers, alternative flows or asynchronous call/callback to create loose-couple functions with fail-fast capabilities that will prevent that an error on one constituent of a service makes the whole service unavailable to users.\n4. Component specialization\nAlthough I haven\u2019t really witnessed or haven\u2019t been reported with this pivot as being a priority concern for customers, we can definitely say there are traces of it out there. For example, web UI interfaces and ML models tend to stick to their preferred programming languages, JavaScript and Python, while interacting with other microservices written in other languages such as Java or .NET\u2026\u00a0\nI\u2019m convinced this pivot is something whose consideration could be higher, as it can definitely provide added value. The idea behind the \u201cspecialization pivot\u201d is to break down a monolith so that specific functions can leverage a more appropriate programming language or even full technology stack.\nConclusion\nWe hope the outlined approach can assist you to make informed decisions for your microservices approach or microservices transformation, and that the balance of the complexity versus flexibility will finally lean to the right side.\nLast updated:\n              January 18, 2024\n\n\n\n\n\n\nRecent Articles\n\n\n\n\n\nMonolith to microservices: Breaking down apps the useful way\nHow to install and upgrade Data Grid 8 Operator\nRed Hat Developer Hub: Your gateway to seamless development\nHow to deploy Vue.js apps to OpenShift\nConnect a .NET app to an external PostgreSQL database\n\n\n\n\n\n\n\n\nRelated Content\n\n\n\n\n\n5 design principles for microservices\n\n\n\n\n\n\n\nHow applications evolve from monolith to microservices\n\n\n\n\n\n\n\nAnalyze monolithic Java applications in multiple workspaces with Red Hat's migration toolkit for applications\n\n\n\n\n\n\n\nDistributed transaction patterns for microservices compared\n\n\n\n\n\n\n\nAdding keystores and truststores to microservices in Red Hat OpenShift\n\n\n\n\n\n\n\nPatterns for distributed transactions within a microservices architecture\n\n\n\n\n\n\n\n\n\n\n            What\u2019s up next?\n          \n\n\n\nRead Kubernetes Native Microservices with Quarkus and MicroProfile to gain an essential understanding of what it takes to develop cloud-native applications using modern tools such as microservices that utilize and integrate with Kubernetes features naturally and efficiently.\n\n\n              Get the e-book\n              \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinkedIn\n\n\nYouTube\n\n\nTwitter\n\n\nFacebook\n\nProducts\n\n\nRed Hat Enterprise Linux\n\n\nRed Hat OpenShift\n\n\nRed Hat Ansible Automation Platform\n\n\nSee all products\n\n\nSee all technologies\n\n\nBuild\n\n\nDeveloper Sandbox\n\n\nDeveloper Tools\n\n\nInteractive Tutorials\n\n\nAPI Catalog\n\n\nOperators Marketplace\n\n\nQuicklinks\n\n\nLearning Resources\n\n\nE-books\n\n\nCheat Sheets\n\n\nBlog\n\n\nEvents\n\n\nCommunicate\n\n\nAbout us\n\n\nContact sales\n\n\nFind a partner\n\n\nSite Status Dashboard\n\n\nReport a security problem\n\n\n\nRED HAT DEVELOPER\nBuild here. Go anywhere.\nWe serve the builders. The problem solvers who create careers with code.\nJoin us if you\u2019re a developer, software engineer, web designer, front-end designer, UX designer, computer scientist, architect, tester, product manager, project manager or team lead.\nSign me up \n\n\nWe\u2019ve updated our Privacy Statement effective July 1, 2023\n\n\nRed Hat legal and privacy links\n\n\nAbout Red Hat\n\nJobs\n\nEvents\n\nLocations\n\nContact Red Hat\n\nRed Hat Blog\n\nDiversity, equity, and inclusion\n\nCool Stuff Store\n\nRed Hat Summit\n\n\nRed Hat legal and privacy links\n\n\nPrivacy statement\n\n\nTerms of use\n\n\nAll policies and guidelines\n\n\nDigital accessibility\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
  "latestPost": {
    "title": "Monolith to microservices: Breaking down apps the useful way",
    "title_detail": {
      "type": "text/plain",
      "language": "en",
      "base": "https://developers.redhat.com/",
      "value": "Monolith to microservices: Breaking down apps the useful way"
    },
    "links": [
      {
        "rel": "alternate",
        "type": "text/html",
        "href": "https://developers.redhat.com/articles/2024/01/17/monolith-microservices-breaking-down-apps-useful-way"
      }
    ],
    "link": "https://developers.redhat.com/articles/2024/01/17/monolith-microservices-breaking-down-apps-useful-way",
    "summary": "<blockquote>\n<p><em>\u201cDon\u2019t break your toys\u2026 unless it\u2019s to have 2 playable toys.\u201d</em></p>\n</blockquote>\n\n<p>A significant part of my 10-year career as a consultant in middleware and applications development has been centered on <a href=\"https://developers.redhat.com/topics/microservices/\">microservices</a> architectures, still an important topic for IT modernization nowadays.</p>\n\n<p>At the very beginning, it was important to just explain the concepts, what it was about and why it wasn\u2019t just another way to speak about service-oriented architecture (SOA). Then came best practices, patterns, and pitfalls.</p>\n\n<p>Some projects were greenfields, of course, but there were also many initiatives around modernizing monoliths by splitting them into smaller pieces.</p>\n\n<p>After a few years, I started to hear some negative feedback. That feedback highlighted and emphasized the higher complexity of the resulting solution. People were saying that the architecture was way more difficult to manage, that end-to-end visibility was a nightmare. Eventually, I even heard some people saying it would be better to go back to the traditional monoliths on traditional application servers.</p>\n\n<p>So the question that came to my mind and that I tried to figure out by gathering information about their transformation projects was: \u201cDidn\u2019t you get any benefits from the microservices architecture?\u201d</p>\n\n<p>That\u2019s the question I\u2019d like to explore with you here.</p>\n\n<h2>Where should I start?</h2>\n\n<p>Going from monolith to microservices is not an easy task. And the result will indeed probably be more complex to administer. So it\u2019s critical that the transformation is conducted for a purpose, and that some benefits show up at the end.</p>\n\n<p>A key question in a monolith-to-microservices transformation is: Where to split the monolith? How many pieces should I have\u2014one, five, ten? And, most importantly, why?</p>\n\n<p>Let\u2019s first look at some (non-exhaustive) elements that led to an architecture that didn't bring what was promised.</p>\n\n<h3>With microservices, I will save resources (thus money)</h3>\n\n<p>No, you won't. There\u2019s no way 10 GB can be bigger than 5 times 2 GB, which actually will easily turn into 5 times 2.5 GB or 3 GB because of the duplicated stack, e.g., the server and operating system.</p>\n\n<p>You\u2019ll achieve better resource control by switching to a lightweight, more resource-efficient runtime\u2014for example, by going from an application server to a Spring Boot application, or to a <a href=\"https://developers.redhat.com/products/quarkus/overview\">Quarkus</a> one. But this task will be made much easier if the application is first refactored as a set of components better fitting a new runtime environment.</p>\n\n<h3>With microservices, my applications will be more reliable</h3>\n\n<p>Not really. Five tightly-coupled services will still fail altogether as one piece.</p>\n\n<p>You\u2019ll achieve that by introducing <a href=\"https://developers.redhat.com/blog/2022/10/19/coming-terms-circuit-breaker\">circuit breakers</a>, alternative flows, asynchronicity, loose coupling mechanisms, and other solutions of the same kind.</p>\n\n<p>So, performing a microservices transformation with only those objectives in mind won\u2019t lead to happiness.</p>\n\n<h2>Microservices approach: A structure in a structure</h2>\n\n<p>Even though the 2 concepts could be evaluated in isolation, we should consider the business-to-IT alignment before even thinking about microservices architectures. Business to IT alignment, on the technical perspective, comes down to the \u201cseparation of concerns\u201d principle, which states that never two microservices share the same responsibility <span><span><span><span><span><span>and that one microservice never has more than exactly one responsibility</span></span></span></span></span></span>. An attempt to improve business-to-IT alignment was given by SOA architecture and domain-driven design. We\u2019ll assume here that this part is something we can already leverage on.</p>\n\n<p>The microservices approach comes on top of this to complement it. It adds technical considerations to the matter in order to provide more flexibility, with better scalability, shorter release cycle so shorter time-to-market and improved robustness with failure transparency; all of them together leading to a much higher efficiency.</p>\n\n<h2>The monolith breakdown pivots</h2>\n\n<p>Here is a proposal of 4 pivots to drive a monolith-to-microservices breakdown activity in order to see an added value at the end.</p>\n\n<h3>1. The scalability</h3>\n\n<p>A monolith should be split into 2 parts when those 2 parts have a reason to scale independently from each other. The objective here is to increase flexibility.</p>\n\n<p>So, if we detect, with experience, that one technical element of an application requires more resources than another under a specific load, breaking it down into 2 microservices could here help save resources (as not the whole application would need to scale but only a part of it).</p>\n\n<p>The application of this principle can lead to a rather extreme example that trades higher flexibility for higher complexity where one component is split into its read operations runtime and its write operations runtime (also known as the CQRS pattern).\u00a0</p>\n\n<h3>2. The ability to release more quickly</h3>\n\n<p>This is probably the one benefit that is expected the most, tightly linked to the time-to-market problem.</p>\n\n<p>This aspect can be reactive or proactive:</p>\n\n<ul><li>It can be that we realize that, over time, one piece of the monolith was updated more often than the rest. The coupling of this piece with the rest of the application creates some friction that slows down the release process. In such a case, we can benefit from splitting down the application in 2 parts to add a decoupling.</li>\n\t<li>Or, we do want to be able to release a particular business function with a reduced time-to-market. However, this business function is embedded in a monolithic application with tight coupling to other business functions. Here, a split into microservices could allow us to insert the appropriate level of isolation for that function to be released at a much higher speed.</li>\n</ul><h3>3. Failure impact isolation</h3>\n\n<p>Impact isolation is a key to application reliability.</p>\n\n<p>Sometimes, statistics can show that one constituent of the monolith is more subject to errors than its other constituents. However, many errors usually lead to the entire monolith to become unresponsive.</p>\n\n<p>Splitting a monolith around that pivot can be a solution to improve the robustness of the overall business service.</p>\n\n<p>It will help introduce error management concepts such as circuit breakers, alternative flows or asynchronous call/callback to create loose-couple functions with fail-fast capabilities that will prevent that an error on one constituent of a service makes the whole service unavailable to users.</p>\n\n<h3>4. Component specialization</h3>\n\n<p>Although I haven\u2019t really witnessed or haven\u2019t been reported with this pivot as being a priority concern for customers, we can definitely say there are traces of it out there. For example, web UI interfaces and ML models tend to stick to their preferred programming languages, <a href=\"https://developers.redhat.com/topics/javascript\">JavaScript</a> and<a href=\"https://developers.redhat.com/topics/python\"> Python</a>, while interacting with other microservices written in other languages such as <a href=\"https://developers.redhat.com/java\">Java</a> or <a href=\"https://developers.redhat.com/topics/dotnet/\">.NET</a>\u2026\u00a0</p>\n\n<p>I\u2019m convinced this pivot is something whose consideration could be higher, as it can definitely provide added value. The idea behind the \u201cspecialization pivot\u201d is to break down a monolith so that specific functions can leverage a more appropriate programming language or even full technology stack.</p>\n\n<h2>Conclusion</h2>\n\n<p>We hope the outlined approach can assist you to make informed decisions for your microservices approach or microservices transformation, and that the balance of the complexity versus flexibility will finally lean to the right side.</p>\nThe post <a href=\"https://developers.redhat.com/articles/2024/01/17/monolith-microservices-breaking-down-apps-useful-way\" title=\"Monolith to microservices: Breaking down apps the useful way\">Monolith to microservices: Breaking down apps the useful way</a> appeared first on <a href=\"https://developers.redhat.com/blog\" title=\"Red Hat Developer\">Red Hat Developer</a>.\n<br /><br />",
    "summary_detail": {
      "type": "text/html",
      "language": "en",
      "base": "https://developers.redhat.com/",
      "value": "<blockquote>\n<p><em>\u201cDon\u2019t break your toys\u2026 unless it\u2019s to have 2 playable toys.\u201d</em></p>\n</blockquote>\n\n<p>A significant part of my 10-year career as a consultant in middleware and applications development has been centered on <a href=\"https://developers.redhat.com/topics/microservices/\">microservices</a> architectures, still an important topic for IT modernization nowadays.</p>\n\n<p>At the very beginning, it was important to just explain the concepts, what it was about and why it wasn\u2019t just another way to speak about service-oriented architecture (SOA). Then came best practices, patterns, and pitfalls.</p>\n\n<p>Some projects were greenfields, of course, but there were also many initiatives around modernizing monoliths by splitting them into smaller pieces.</p>\n\n<p>After a few years, I started to hear some negative feedback. That feedback highlighted and emphasized the higher complexity of the resulting solution. People were saying that the architecture was way more difficult to manage, that end-to-end visibility was a nightmare. Eventually, I even heard some people saying it would be better to go back to the traditional monoliths on traditional application servers.</p>\n\n<p>So the question that came to my mind and that I tried to figure out by gathering information about their transformation projects was: \u201cDidn\u2019t you get any benefits from the microservices architecture?\u201d</p>\n\n<p>That\u2019s the question I\u2019d like to explore with you here.</p>\n\n<h2>Where should I start?</h2>\n\n<p>Going from monolith to microservices is not an easy task. And the result will indeed probably be more complex to administer. So it\u2019s critical that the transformation is conducted for a purpose, and that some benefits show up at the end.</p>\n\n<p>A key question in a monolith-to-microservices transformation is: Where to split the monolith? How many pieces should I have\u2014one, five, ten? And, most importantly, why?</p>\n\n<p>Let\u2019s first look at some (non-exhaustive) elements that led to an architecture that didn't bring what was promised.</p>\n\n<h3>With microservices, I will save resources (thus money)</h3>\n\n<p>No, you won't. There\u2019s no way 10 GB can be bigger than 5 times 2 GB, which actually will easily turn into 5 times 2.5 GB or 3 GB because of the duplicated stack, e.g., the server and operating system.</p>\n\n<p>You\u2019ll achieve better resource control by switching to a lightweight, more resource-efficient runtime\u2014for example, by going from an application server to a Spring Boot application, or to a <a href=\"https://developers.redhat.com/products/quarkus/overview\">Quarkus</a> one. But this task will be made much easier if the application is first refactored as a set of components better fitting a new runtime environment.</p>\n\n<h3>With microservices, my applications will be more reliable</h3>\n\n<p>Not really. Five tightly-coupled services will still fail altogether as one piece.</p>\n\n<p>You\u2019ll achieve that by introducing <a href=\"https://developers.redhat.com/blog/2022/10/19/coming-terms-circuit-breaker\">circuit breakers</a>, alternative flows, asynchronicity, loose coupling mechanisms, and other solutions of the same kind.</p>\n\n<p>So, performing a microservices transformation with only those objectives in mind won\u2019t lead to happiness.</p>\n\n<h2>Microservices approach: A structure in a structure</h2>\n\n<p>Even though the 2 concepts could be evaluated in isolation, we should consider the business-to-IT alignment before even thinking about microservices architectures. Business to IT alignment, on the technical perspective, comes down to the \u201cseparation of concerns\u201d principle, which states that never two microservices share the same responsibility <span><span><span><span><span><span>and that one microservice never has more than exactly one responsibility</span></span></span></span></span></span>. An attempt to improve business-to-IT alignment was given by SOA architecture and domain-driven design. We\u2019ll assume here that this part is something we can already leverage on.</p>\n\n<p>The microservices approach comes on top of this to complement it. It adds technical considerations to the matter in order to provide more flexibility, with better scalability, shorter release cycle so shorter time-to-market and improved robustness with failure transparency; all of them together leading to a much higher efficiency.</p>\n\n<h2>The monolith breakdown pivots</h2>\n\n<p>Here is a proposal of 4 pivots to drive a monolith-to-microservices breakdown activity in order to see an added value at the end.</p>\n\n<h3>1. The scalability</h3>\n\n<p>A monolith should be split into 2 parts when those 2 parts have a reason to scale independently from each other. The objective here is to increase flexibility.</p>\n\n<p>So, if we detect, with experience, that one technical element of an application requires more resources than another under a specific load, breaking it down into 2 microservices could here help save resources (as not the whole application would need to scale but only a part of it).</p>\n\n<p>The application of this principle can lead to a rather extreme example that trades higher flexibility for higher complexity where one component is split into its read operations runtime and its write operations runtime (also known as the CQRS pattern).\u00a0</p>\n\n<h3>2. The ability to release more quickly</h3>\n\n<p>This is probably the one benefit that is expected the most, tightly linked to the time-to-market problem.</p>\n\n<p>This aspect can be reactive or proactive:</p>\n\n<ul><li>It can be that we realize that, over time, one piece of the monolith was updated more often than the rest. The coupling of this piece with the rest of the application creates some friction that slows down the release process. In such a case, we can benefit from splitting down the application in 2 parts to add a decoupling.</li>\n\t<li>Or, we do want to be able to release a particular business function with a reduced time-to-market. However, this business function is embedded in a monolithic application with tight coupling to other business functions. Here, a split into microservices could allow us to insert the appropriate level of isolation for that function to be released at a much higher speed.</li>\n</ul><h3>3. Failure impact isolation</h3>\n\n<p>Impact isolation is a key to application reliability.</p>\n\n<p>Sometimes, statistics can show that one constituent of the monolith is more subject to errors than its other constituents. However, many errors usually lead to the entire monolith to become unresponsive.</p>\n\n<p>Splitting a monolith around that pivot can be a solution to improve the robustness of the overall business service.</p>\n\n<p>It will help introduce error management concepts such as circuit breakers, alternative flows or asynchronous call/callback to create loose-couple functions with fail-fast capabilities that will prevent that an error on one constituent of a service makes the whole service unavailable to users.</p>\n\n<h3>4. Component specialization</h3>\n\n<p>Although I haven\u2019t really witnessed or haven\u2019t been reported with this pivot as being a priority concern for customers, we can definitely say there are traces of it out there. For example, web UI interfaces and ML models tend to stick to their preferred programming languages, <a href=\"https://developers.redhat.com/topics/javascript\">JavaScript</a> and<a href=\"https://developers.redhat.com/topics/python\"> Python</a>, while interacting with other microservices written in other languages such as <a href=\"https://developers.redhat.com/java\">Java</a> or <a href=\"https://developers.redhat.com/topics/dotnet/\">.NET</a>\u2026\u00a0</p>\n\n<p>I\u2019m convinced this pivot is something whose consideration could be higher, as it can definitely provide added value. The idea behind the \u201cspecialization pivot\u201d is to break down a monolith so that specific functions can leverage a more appropriate programming language or even full technology stack.</p>\n\n<h2>Conclusion</h2>\n\n<p>We hope the outlined approach can assist you to make informed decisions for your microservices approach or microservices transformation, and that the balance of the complexity versus flexibility will finally lean to the right side.</p>\nThe post <a href=\"https://developers.redhat.com/articles/2024/01/17/monolith-microservices-breaking-down-apps-useful-way\" title=\"Monolith to microservices: Breaking down apps the useful way\">Monolith to microservices: Breaking down apps the useful way</a> appeared first on <a href=\"https://developers.redhat.com/blog\" title=\"Red Hat Developer\">Red Hat Developer</a>.\n<br /><br />"
    },
    "time": {
      "datetime": "2024-01-17T07:00:00+00:00"
    },
    "published": "Wed, 17 Jan 2024 07:00:00 +0000",
    "published_parsed": [
      2024,
      1,
      17,
      7,
      0,
      0,
      2,
      17,
      0
    ],
    "authors": [
      {
        "name": "Michael Thirion"
      }
    ],
    "author": "Michael Thirion",
    "author_detail": {
      "name": "Michael Thirion"
    },
    "id": "c111124b-248c-4e1c-8d4d-d72d3ac6ae63",
    "guidislink": false
  }
}