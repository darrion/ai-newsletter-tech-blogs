{
  "company": "Asana",
  "title": "Asana",
  "xmlUrl": "https://blog.asana.com/feed/",
  "htmlUrl": "https://blog.asana.com/category/eng/",
  "content": "\n\nScaling a Mature iOS Codebase with Tuist - The Asana Blog \u2022 AsanaWe're proud to be recognized as a Leader in the 2023 Gartner\u00ae\ufe0f Magic Quadrant\u2122\ufe0f for Collaborative Work ManagementGet the reportx iconAsana HomeNavigation InstructionsUse left and right arrow keys to navigate between columns.Use up and down arrow keys to move between submenu items.Use Escape to close the menu.Why Asana?\u00a0Why AsanaOverviewBuild project plans, coordinate tasks, and hit deadlinesFor MarketingPlan and track campaigns, launches, and moreFor OperationsBuild, scale and streamline processes to improve efficiencyFor Leaders NewImprove clarity, focus, and personal growthFor ProductBuild roadmaps, plan sprints, manage shipping and launchesFor Your WorkflowProject ManagementPlan, track, and manage team projects from start to finishCampaign ManagementCreate, launch, and track your marketing campaignsCreative ProductionDesign, review, and ship inspirational workRequest TrackingTrack, prioritize, and fulfill the asks for your teamsRemote teams PopularCollaborate and manage work from anywhereProductivityBe more deliberate about how you manage your timeAgile ManagementBuild fast, ship often, and track it all in one placeSee all workflowsTemplatesTemplates HomeHit the ground running with templates designed for your use-casePopular TemplatesTeam continuityMeeting agendaProject planWork requestsTeam goals & objective planningFeatures\u00a0Key FeaturesAsana Intelligence NewAmplify your team's impact with AI for AsanaWorkflow BuilderCreate automated processes to coordinate your teamsTimelineBuild a beautiful Gantt chart in minutesBoardsSee and track your work on Kanban boardsCalendarView your team's work on one shared calendarApp IntegrationsSee how Asana brings apps together to support your teamReportingGet real-time insight into progress on any stream of workGoalsSet strategic goals and track progress in one placeFormsSubmit and manage work requests in one placeAutomationStreamline processes, reduce errors, and spend less time on routine tasksWorkloadSee how much work team members have across projectsSee all featuresAll PlansPersonalFor individuals and small teams looking to manage their tasksStarterFor growing teams that need to track their projects' progress and hit deadlinesAdvancedFor companies that need to manage a portfolio of work and goals across departmentsCompare all plansResources\u00a0LearnWork Management ResourcesDiscover best practices, watch webinars, get insightsWhat's NewLearn about the latest and greatest from AsanaHelp CenterGet lots of tips, tricks, and advice to get the most from AsanaAsana AcademySign up for interactive courses and webinars to learn AsanaInside Asana BlogDiscover the latest Asana product and company newsConnectEventsFind out about upcoming events near youCommunity ProgramsConnect with and learn from Asana customers around the worldSupportNeed help? Contact the Asana support teamPartnersLearn more about our partner programsDevelopersLearn more about building apps on the Asana platformAsana for NonprofitsGet more information on our nonprofit discount program, and apply.Asana for EducationGet more information on our education discount program, and apply.Featured ReadsMeet Asana Intelligence:AI has joined the team,DemoWatch nowDrive employee impact: New tools to empower resilient leadership,ReportRead moreThe Anatomy of Work: Global Index 2023,ReportRead moreEnterprisePricingGet startedGet startedLog InLaunch AsanaContact salesView demoDownload AppBahasa IndonesiaDeutschEnglishEspa\u00f1olFran\u00e7aisItaliano\u65e5\u672c\u8a9e\ud55c\uad6d\uc5b4NederlandsPolskiPortugu\u00eas\u0420\u0443\u0441\u0441\u043a\u0438\u0439Svenska\u7e41\u9ad4\u4e2d\u6587Contact salesLog InGet startedInside Asana|Role Spotlights|Scaling a Mature iOS Codebase with TuistJump To SectionWhere we wereThe decision to make a changeChoosing to use Tuist to make module creation trivialTuist\u2019s advantagesMigrating to TuistRefactoring to support modulesActually making the modulesWhere we are nowWas it worth it? Should you do the same?New problemsNew benefitsScaling a Mature iOS Codebase with TuistEngineering TeamFebruary 21st, 20239 min readfacebooktwitterlinkedinSix months ago, it usually took 45 seconds to make a change to a feature in the Asana iOS app and rebuild it. Today, it usually takes 15 seconds.The Mobile Foundations team achieved this by migrating our Xcode project to\u00a0Tuist\u00a0and splitting the code into several modules, enabled by some modest refactors. In this article, I\u2019ll describe how we decided what path to take, and how you can make similar changes in your own codebase.Where we wereComing into 2022, we had about ten engineers maintaining about 300,000 lines of Swift code. Almost all of it was compiled into a single build target, Asana. The Swift compiler was doing a decent job of building it all; if you made a change, you could see it reflected in the simulator in just 45 seconds or so. (Unless you were using an Intel Mac, in which case it would be more like 90 seconds.)Once in a while, two people would make changes to the Xcode project file that would cause a merge conflict. It would take time to sort these out each time they occurred, but we learned to live with it.The decision to make a changeWe expected to add more people to the team. Build times would affect more people, and we knew we\u2019d keep writing more code, so the builds would get slower.One way to make builds faster is to build less stuff each time, which in the Swift world means splitting code into modules. If code in module A depends on module B, and module A changes but module B does not, then module B does not need to be recompiled in order to get a working app binary.Splitting the code into modules came with two challenges: the developer experience of creating the modules, and refactoring our code to allow different types to exist in different modules.Choosing to use Tuist to make module creation trivialSplitting the codebase into modules required either adopting a new tool, or choosing to deal with the native Xcode workflow. We spent time investigating four options.While looking at these options, our most important criterion was the developer experience. We knew modules would make the build faster, but if we sacrificed developer experience in other ways, the gains would be useless. However, we also looked at the adoption cost of each tool, and whether they support remote build caching and selective test execution.The option with the lowest starting cost was to use Xcode\u2019s built-in GUI to manually add new build targets. While this approach is cheap to prototype and doesn\u2019t require new dependencies, we\u2019d have needed to write a graphical runbook to help people make new modules, and it would have still been error-prone and tedious. We wouldn\u2019t be able to automate adding files to the project, or defining dependencies.Another option was to use Xcode\u2019s native Swift Package Manager support, and create local Swift packages. We prototyped this, but the developer experience still wasn\u2019t very good, especially tracking down the root causes of compiler errors. Additionally, writing Package.swift files by hand was just about as error-prone and tedious as working with the Xcode GUI. The local modules we tried to create all had very similar and repetitive Package.swift files, and those files couldn\u2019t share code.Many companies use\u00a0Bazel\u00a0to manage their iOS builds. We investigated Bazel, but found serious issues with its developer experience. Bazel is a very heavyweight set of tools that requires new mental models, and we ran into workflow-breaking issues with breakpoints.The last thing we looked at was\u00a0Tuist, a relatively new project which generates Xcode projects from Swift source code. We found almost no downsides.Tuist\u2019s advantagesTuist is a command-line tool that automates the creation of Xcode projects and workspaces. Swift code in a Tuist manifest has full access to the Foundation framework. With this power, we believed we could write a Tuist manifest that would automate nearly every task to be based on the filesystem, not manual configuration. There would be an onboarding process for people who did need to make changes for special cases, but the day-to-day experience of an iOS engineer would be that things just work, and they could use Xcode without thinking about Tuist. This all came true, with the help of\u00a0 some light Python scripting to automate creating new modules.A few aspects of Tuist reduce the risk of a migration going wrong. Tuist\u2019s output is an Xcode project, so we could always go back to checking the project into source control and stop generating it with Tuist. Also, Tuist\u2019s documentation is really good, so we wouldn\u2019t need to do as much work writing our own internal docs. Finally, being written in Swift, we felt we could contribute code back to the project if we needed to fix a bug.Migrating to TuistTuist has one limitation we needed to overcome: lack of first-party support for CocoaPods. So first, we needed to migrate all our CocoaPods dependencies to Swift Package Manager or Carthage. Fortunately, all our dependencies supported one or the other.Then, we needed to migrate all our build settings to .xcconfig files using\u00a0tuist migration settings-to-xcconfig. This was straightforward.With the prep work done, we were able to write a Tuist \u201cmanifest\u201d (project definition) from scratch. This part took a couple weeks, and we did need to keep tweaking this for months as we made new modules and discovered subtle errors we had made during the migration, but none of those were really Tuist\u2019s fault.Finally, once the Tuist manifest was in a state where engineers could reasonably be asked to use its output, we wrote git hooks to run\u00a0tuist generate\u00a0on every\u00a0git checkout, and removed the old Xcode project from source control.Refactoring to support modulesWhen all our code was in a single module, we had never needed the\u00a0public\u00a0keyword, so we never used it. Thousands of classes, methods, and properties needed to be made public. We eventually resolved this by writing a Python script that could parse Swift code and mark every internal symbol in a file as\u00a0public, and running it on various files as needed.Our other big problem was circular dependencies. Consider Asana\u2019s project view and task view: a project needs to open a task, and you can then open a project from within that task. We needed a way for\u00a0ProjectViewController\u00a0and\u00a0TaskDetailsViewController to instantiate each other. We solved this problem using something resembling Tuist\u2019s\u00a0\u00b5Features architecture, which puts a feature\u2019s public interface in its own module. Refactoring code to use this pattern was the most arduous and manual step, because in most cases we were cutting dependency boundaries for the first time, often in very old code.Both of these changes were applied to different parts of the codebase at different times over months. Just a little at first, then a lot as we broke out new modules, then just a little again when the dust settled.Actually making the modulesThe first thing we did after making the Tuist manifest was to put almost all of the code except\u00a0AppDelegate\u00a0into a big module called\u00a0AsanaCore. We wanted to discover and fix workflow issues as soon as possible. We chose to use static libraries.The main workflow issues we encountered after creating AsanaCore were:We use NSKeyed[Un]Archiver to store unsynced user actions. We needed to tell NSKeyedUnarchiver how to find types that had been saved using a different module name so user data wasn\u2019t lost.Our XLIFF string exports from Xcode had different metadata, which made a huge diff in our translation backend. We fixed this and other issues by writing Python code to patch the XLIFF files after export and before import.Importing XLIFFs back into Xcode didn\u2019t work at first, because although Xcode was happy to export strings in AsanaCore, it didn\u2019t recognize them for some reason on import, so it would discard all of them. We fixed this in a really silly way: manually generate a Swift file containing all strings, add it to the app target (using Tuist of course), and then delete it after import. String lookups continue to work just fine.The localization stuff was hairy, but the challenges were within our reach and the solutions didn\u2019t need to be touched after being written. Teams that use different approaches to localization than we do might have an easier time. And the localization challenges weren\u2019t Tuist\u2019s fault\u2014after all, it was just generating projects the way we asked it to.With the workflow issues fixed, our build graph still looked pretty simple. We had a \u201cmodule,\u201d but no build time savings. Really the worst possible world to be in, though it wasn\u2019t perceptibly worse than before.From here, our approach was to \u201clift\u201d features upward out of\u00a0AsanaCore, and \u201cpush\u201d non-feature code downward out of\u00a0AsanaCore\u00a0into more granular frameworks. The first big feature module we pulled out of\u00a0AsanaCore\u00a0was\u00a0Inbox:The reason we chose Inbox is because Inbox calls other code a lot, but not much other code calls Inbox.\u00a0 It was a perfect test of whether our modules-make-good-build-times hypothesis was correct.Well, it was correct. Incremental build times for changing a line of Inbox code went from 30-50 seconds to 4 seconds.Once we had our first feature module, we began creating more, ranging from 5,000 to 30,000 lines of code. At the same time, we found ways to carve other parts of\u00a0AsanaCore\u00a0out into framework-level modules. Eventually,\u00a0AsanaCore\u00a0contained just 21% of the code in the app. Pushing code up from\u00a0AsanaCore\u00a0into feature modules reduced time spent rebuilding feature code an engineer wasn\u2019t actively working on, while pushing code \u201cdown\u201d from\u00a0AsanaCore\u00a0into a framework reduced time spent rebuilding code that rarely changed at all during feature development.We spent about 3 months incrementally moving code into modules. We\u2019d establish a beachhead with just a few files, then migrate code into the new module a bit at a time. We also wrote a command line script that could both move files between modules and update their imports.Where we are nowOur Tuist manifest is about 1,400 lines. A lot of this is intrinsic complexity, doing different things depending on environment variables related to different build types (debug, TestFlight, nightly, etc). Some of it is automation, so it just takes a few lines to add a new module. There\u2019s very little code that doesn\u2019t have a critical role in the project definition.Our median build time is 15 seconds. We do wish it were even lower, and we expect to get there eventually using build caching, but for now we\u2019re very happy with our progress. We log all our build times to Scalyr, so I can show you the distribution:X axis: seconds to build on a log scale. Y axis: number of builds during the period.We\u2019d love to know whether the type of module modified in a given build affects that build\u2019s duration, but unfortunately we haven\u2019t been able to get trustworthy data out of Xcode build logs to find out.Our module graph now looks something like this:Splitting the frameworks below\u00a0AsanaCore\u00a0like this doesn\u2019t affect build times much, but down the road, we expect it will let us skip running test suites for code that changes rarely unless that code has been changed.Here\u2019s the breakdown of module size. We\u2019re roughly where we expected to be, although we hope to get even more code out of\u00a0AsanaCore, since it mostly represents old features we haven\u2019t chosen to refactor yet, or code that doesn\u2019t have a clear home at the moment.Was it worth it? Should you do the same?With the benefit of hindsight, everyone on the team agrees Tuist has been a hugely positive change. While the migration brought new issues, the benefits are well worth the cost of dealing with those issues.New problemsTuist is a complex new tool that only a minority of our iOS engineers are comfortable with. We\u2019ve found that having 3+ Tuist experts is fine in practice, but we\u2019re always working to help everyone become comfortable with\u00a0tuist edit. On the bright side, it\u2019s very rare for anyone to need to edit the Tuist manifest unless they\u2019re working on some build performance or developer experience improvement.git checkout\u00a0takes 5-15 seconds longer than it used to. We wish this were faster, but we also appreciate that we don\u2019t need to deal with project file merge conflicts at all anymore.Using modules has forced us to write a bit more boilerplate code to separate interfaces from implementations. However, in some ways this was a positive change, forcing us to be more explicit about API boundaries between objects.New benefitsAutocomplete works better with modules. Xcode seems much more capable of dealing with many small modules rather than a single big one, perhaps because it can cache its index per target instead of constantly having the current target\u2019s index invalidated by trivial changes.Treating project configuration as code makes sense when your app is complex. It\u2019s easy to leave comments on changes to the Tuist manifest on a GitHub pull request or in the code, which wasn\u2019t true at all when we\u2019d change the Xcode project in the GUI. Project-file-related merge conflicts are all gone.Repetitive changes are easy to make. Making a new module requires running one command on the command line and then adding the implementation.Being able to completely rely on the filesystem as the arbiter of a file\u2019s target membership has prevented many errors and drastically reduced the number of clicks it takes to move a group of files between targets. Xcode often guesses wrong which target a new file should belong to, but our handwritten Tuist rules are always right.I\u2019ve said it many times in this article, but it\u2019s worth saying again: builds are much faster!There are additional benefits we haven\u2019t yet reached for, particularly in the realm of CI. We\u2019re looking forward to running our tests in parallel, caching build artifacts more aggressively, and running only tests affected by changed code in a PR, rather than running all tests on every PR.Personally, if I were starting a new iOS project today, even as a solo developer, I\u2019d use Tuist from day one. Any team that can deal with the extra complexity should make the switch. Building your own Project.swift from scratch will teach you enough to understand and maintain it.We love Tuist so much that we sponsored the project this year. The maintainers have always been responsive and helpful. Thank you for everything, Tuist maintainers!Related articlesRole SpotlightsAsana\u2019s Tech Stack: How we build a collaborative app for teams of all sizesRole SpotlightsScaling Scala: How we chose our backend language and toolingRole SpotlightsMeet our 2020 summer intern classRole SpotlightsTypeScript\u2019s quirks: How inconsistencies make the language more complexAsana HomeAsanaHomeProductWhat's NewPricingStarterAdvancedEnterpriseCustomer SuccessAsana TemplatesTrust & SecurityStatusAbout UsCompanyLeadershipCustomersDiversityCareersPressWavelengthInside AsanaInvestor RelationsSitemapModern Slavery Transparency StatementWorkflow SolutionsProject ManagementGoal ManagementAgile ManagementTask ManagementIncrease ProductivityWork ManagementProject PlanningTo Do ListsSee All UsesSee All TeamsResourcesHelp CenterForumSupportApp DirectoryDevelopers & APIPartnersAsana CommunityEventsAsana for NonprofitsAsana for EducationAccessibilityLearn11 Leadership Styles110 Icebreaker QuestionsExecutive Summary TipsImpostor Syndrome TipsPrevent Team BurnoutSWOT Analysis TipsWhat are OKRs?What are SMART Goals?What is Scope Creep?See All resources\u00a9 2024 Asana, Inc.LanguageBahasa IndonesiaDeutschEnglishEspa\u00f1olFran\u00e7aisItaliano\u65e5\u672c\u8a9e\ud55c\uad6d\uc5b4NederlandsPolskiPortugu\u00eas\u0420\u0443\u0441\u0441\u043a\u0438\u0439Svenska\u7e41\u9ad4\u4e2d\u6587Terms & PrivacyTwitterLinkedinInstagramFacebookYoutube",
  "latestPost": {
    "title": "Scaling a Mature iOS Codebase with\u00a0Tuist",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://blog.asana.com/feed/",
      "value": "Scaling a Mature iOS Codebase with\u00a0Tuist"
    },
    "links": [
      {
        "rel": "alternate",
        "type": "text/html",
        "href": "https://blog.asana.com/2023/02/scaling-a-mature-ios-codebase-with-tuist/"
      }
    ],
    "link": "https://blog.asana.com/2023/02/scaling-a-mature-ios-codebase-with-tuist/",
    "comments": "https://blog.asana.com/2023/02/scaling-a-mature-ios-codebase-with-tuist/#respond",
    "authors": [
      {
        "name": "Steve Landey"
      }
    ],
    "author": "Steve Landey",
    "author_detail": {
      "name": "Steve Landey"
    },
    "published": "Tue, 21 Feb 2023 19:53:23 +0000",
    "published_parsed": [
      2023,
      2,
      21,
      19,
      53,
      23,
      1,
      52,
      0
    ],
    "tags": [
      {
        "term": "Engineering",
        "scheme": null,
        "label": null
      }
    ],
    "id": "https://blog.asana.com/?p=14352",
    "guidislink": false,
    "summary": "<p>Six months ago, it usually took 45 seconds to make a change to a feature in the Asana iOS app and rebuild it. Today, it usually takes 15 seconds. The Mobile Foundations team achieved this by migrating our Xcode project to Tuist and splitting the code into several modules, enabled by some modest refactors. In [&#8230;]</p>\n<p>The post <a href=\"https://blog.asana.com/2023/02/scaling-a-mature-ios-codebase-with-tuist/\" rel=\"nofollow\">Scaling a Mature iOS Codebase with&nbsp;Tuist</a> appeared first on <a href=\"https://blog.asana.com\" rel=\"nofollow\">The Asana Blog</a>.</p>",
    "summary_detail": {
      "type": "text/html",
      "language": null,
      "base": "https://blog.asana.com/feed/",
      "value": "<p>Six months ago, it usually took 45 seconds to make a change to a feature in the Asana iOS app and rebuild it. Today, it usually takes 15 seconds. The Mobile Foundations team achieved this by migrating our Xcode project to Tuist and splitting the code into several modules, enabled by some modest refactors. In [&#8230;]</p>\n<p>The post <a href=\"https://blog.asana.com/2023/02/scaling-a-mature-ios-codebase-with-tuist/\" rel=\"nofollow\">Scaling a Mature iOS Codebase with&nbsp;Tuist</a> appeared first on <a href=\"https://blog.asana.com\" rel=\"nofollow\">The Asana Blog</a>.</p>"
    },
    "content": [
      {
        "type": "text/html",
        "language": null,
        "base": "https://blog.asana.com/feed/",
        "value": "<div class=\"wpcollab-hello-emoji\">\n<p>Six months ago, it usually took 45 seconds to make a change to a feature in the Asana iOS app and rebuild it. Today, it usually takes 15 seconds.</p>\n\n\n\n<p>The Mobile Foundations team achieved this by migrating our Xcode project to <a href=\"https://tuist.io\">Tuist</a> and splitting the code into several modules, enabled by some modest refactors. In this article, I&#8217;ll describe how we decided what path to take, and how you can make similar changes in your own codebase.</p>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>Where we were</strong></h2>\n\n\n\n<p>Coming into 2022, we had about ten engineers maintaining about 300,000 lines of Swift code. Almost all of it was compiled into a single build target, Asana. The Swift compiler was doing a decent job of building it all; if you made a change, you could see it reflected in the simulator in just 45 seconds or so. (Unless you were using an Intel Mac, in which case it would be more like 90 seconds.)</p>\n\n\n\n<p>Once in a while, two people would make changes to the Xcode project file that would cause a merge conflict. It would take time to sort these out each time they occurred, but we learned to live with it.</p>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>The decision to make a change</strong></h2>\n\n\n\n<p>We expected to add more people to the team. Build times would affect more people, and we knew we&#8217;d keep writing more code, so the builds would get slower.</p>\n\n\n\n<p>One way to make builds faster is to build less stuff each time, which in the Swift world means splitting code into modules. If code in module A depends on module B, and module A changes but module B does not, then module B does not need to be recompiled in order to get a working app binary.</p>\n\n\n\n<p>Splitting the code into modules came with two challenges: the developer experience of creating the modules, and refactoring our code to allow different types to exist in different modules.</p>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>Choosing to use Tuist to make module creation trivial</strong></h2>\n\n\n\n<p>Splitting the codebase into modules required either adopting a new tool, or choosing to deal with the native Xcode workflow. We spent time investigating four options.</p>\n\n\n\n<p>While looking at these options, our most important criterion was the developer experience. We knew modules would make the build faster, but if we sacrificed developer experience in other ways, the gains would be useless. However, we also looked at the adoption cost of each tool, and whether they support remote build caching and selective test execution.</p>\n\n\n\n<p>The option with the lowest starting cost was to use Xcode&#8217;s built-in GUI to manually add new build targets. While this approach is cheap to prototype and doesn&#8217;t require new dependencies, we&#8217;d have needed to write a graphical runbook to help people make new modules, and it would have still been error-prone and tedious. We wouldn&#8217;t be able to automate adding files to the project, or defining dependencies.</p>\n\n\n\n<p>Another option was to use Xcode&#8217;s native Swift Package Manager support, and create local Swift packages. We prototyped this, but the developer experience still wasn&#8217;t very good, especially tracking down the root causes of compiler errors. Additionally, writing Package.swift files by hand was just about as error-prone and tedious as working with the Xcode GUI. The local modules we tried to create all had very similar and repetitive Package.swift files, and those files couldn&#8217;t share code.</p>\n\n\n\n<p>Many companies use <a href=\"https://github.com/bazelbuild/rules_apple/blob/master/doc/tutorials/ios-app.md\">Bazel</a> to manage their iOS builds. We investigated Bazel, but found serious issues with its developer experience. Bazel is a very heavyweight set of tools that requires new mental models, and we ran into workflow-breaking issues with breakpoints.</p>\n\n\n\n<p>The last thing we looked at was <a href=\"https://tuist.io\">Tuist</a>, a relatively new project which generates Xcode projects from Swift source code. We found almost no downsides.</p>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>Tuist\u2019s advantages</strong></h2>\n\n\n\n<p>Tuist is a command-line tool that automates the creation of Xcode projects and workspaces. Swift code in a Tuist manifest has full access to the Foundation framework. With this power, we believed we could write a Tuist manifest that would automate nearly every task to be based on the filesystem, not manual configuration. There would be an onboarding process for people who did need to make changes for special cases, but the day-to-day experience of an iOS engineer would be that things just work, and they could use Xcode without thinking about Tuist. This all came true, with the help of&nbsp; some light Python scripting to automate creating new modules.</p>\n\n\n\n<p>A few aspects of Tuist reduce the risk of a migration going wrong. Tuist&#8217;s output is an Xcode project, so we could always go back to checking the project into source control and stop generating it with Tuist. Also, Tuist&#8217;s documentation is really good, so we wouldn&#8217;t need to do as much work writing our own internal docs. Finally, being written in Swift, we felt we could contribute code back to the project if we needed to fix a bug.</p>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>Migrating to Tuist</strong></h2>\n\n\n\n<p>Tuist has one limitation we needed to overcome: lack of first-party support for CocoaPods. So first, we needed to migrate all our CocoaPods dependencies to Swift Package Manager or Carthage. Fortunately, all our dependencies supported one or the other.</p>\n\n\n\n<p>Then, we needed to migrate all our build settings to .xcconfig files using <code><a href=\"https://docs.tuist.io/guides/adopting-tuist\">tuist migration settings-to-xcconfig</a></code>. This was straightforward.</p>\n\n\n\n<p>With the prep work done, we were able to write a Tuist &#8220;manifest&#8221; (project definition) from scratch. This part took a couple weeks, and we did need to keep tweaking this for months as we made new modules and discovered subtle errors we had made during the migration, but none of those were really Tuist&#8217;s fault.</p>\n\n\n\n<p>Finally, once the Tuist manifest was in a state where engineers could reasonably be asked to use its output, we wrote git hooks to run <code>tuist generate</code> on every <code>git checkout</code>, and removed the old Xcode project from source control.</p>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>Refactoring to support modules</strong></h2>\n\n\n\n<p>When all our code was in a single module, we had never needed the <code>public</code> keyword, so we never used it. Thousands of classes, methods, and properties needed to be made public. We eventually resolved this by writing a Python script that could parse Swift code and mark every internal symbol in a file as <code>public</code>, and running it on various files as needed.</p>\n\n\n\n<p>Our other big problem was circular dependencies. Consider Asana&#8217;s project view and task view: a project needs to open a task, and you can then open a project from within that task. We needed a way for <code>ProjectViewController</code> and <code>TaskDetailsViewController</code> to instantiate each other. We solved this problem using something resembling Tuist&#8217;s <a href=\"https://docs.tuist.io/building-at-scale/microfeatures\">\u00b5Features architecture</a>, which puts a feature&#8217;s public interface in its own module. Refactoring code to use this pattern was the most arduous and manual step, because in most cases we were cutting dependency boundaries for the first time, often in very old code.</p>\n\n\n\n<p>Both of these changes were applied to different parts of the codebase at different times over months. Just a little at first, then a lot as we broke out new modules, then just a little again when the dust settled.</p>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>Actually making the modules</strong></h2>\n\n\n\n<p>The first thing we did after making the Tuist manifest was to put almost all of the code except <code>AppDelegate</code> into a big module called <code>AsanaCore</code>. We wanted to discover and fix workflow issues as soon as possible. We chose to use static libraries.</p>\n\n\n\n<p>The main workflow issues we encountered after creating AsanaCore were:</p>\n\n\n\n<ol>\n<li>We use <code>NSKeyed[Un]Archiver</code> to store unsynced user actions. We needed to tell <code>NSKeyedUnarchiver</code> <a href=\"https://developer.apple.com/documentation/foundation/nskeyedunarchiver/1409718-setclass\">how to find types</a> that had been saved using a different module name so user data wasn&#8217;t lost.</li>\n\n\n\n<li>Our XLIFF string exports from Xcode had different metadata, which made a huge diff in our translation backend. We fixed this and other issues by writing Python code to patch the XLIFF files after export and before import.</li>\n\n\n\n<li>Importing XLIFFs back into Xcode didn&#8217;t work at first, because although Xcode was happy to export strings in <code>AsanaCore</code>, it didn&#8217;t recognize them for some reason on import, so it would discard all of them. We fixed this in a really silly way: manually generate a Swift file containing all strings, add it to the app target (using Tuist of course), and then delete it after import. String lookups continue to work just fine.</li>\n</ol>\n\n\n\n<p>The localization stuff was hairy, but the challenges were within our reach and the solutions didn&#8217;t need to be touched after being written. Teams that use different approaches to localization than we do might have an easier time. And the localization challenges weren&#8217;t Tuist&#8217;s fault\u2014after all, it was just generating projects the way we asked it to.</p>\n\n\n\n<p>With the workflow issues fixed, our build graph still looked pretty simple. We had a &#8220;module,&#8221; but no build time savings. Really the worst possible world to be in, though it wasn&#8217;t perceptibly worse than before.</p>\n\n\n\n<figure class=\"wp-block-image\"><img alt=\"\" src=\"https://lh4.googleusercontent.com/OrvGNQq8bWpTbBqebqzStMcKR7iuU0pk8tCBI-DxLPcoucsO3YJkxx88-HT_IR2XR1G_aCYGTJPGd1db4RnpN7EI1dyeKbMFJM-2PxozOJXljbQZnMkYYV5nwLXeVSWjMLvf2AQD9l0k1Ew6lOT9JRw\" /></figure>\n\n\n\n<p>From here, our approach was to &#8220;lift&#8221; features upward out of <code>AsanaCore</code>, and &#8220;push&#8221; non-feature code downward out of <code>AsanaCore</code> into more granular frameworks. The first big feature module we pulled out of <code>AsanaCore</code> was <code>Inbox</code>:</p>\n\n\n\n<figure class=\"wp-block-image\"><img alt=\"\" src=\"https://lh3.googleusercontent.com/Xb6a3pgo-1R2VqdqYEw-Mfc4g-2KOAsUwPRjgPO5ZYRdqOALBtavoK3SDkpykZWCgh-Mf5qmHDQeeVJnTpL_vEVQhM28VUWBKD9TaDur_tvDE67pElB8sCfAgunSHQ0lAGZ1n4rAS2iyZkrO020Hb3E\" /></figure>\n\n\n\n<p>The reason we chose Inbox is because Inbox calls other code a lot, but not much other code calls Inbox.&nbsp; It was a perfect test of whether our modules-make-good-build-times hypothesis was correct.</p>\n\n\n\n<p>Well, it was correct. Incremental build times for changing a line of Inbox code went from 30-50 seconds to 4 seconds.</p>\n\n\n\n<p>Once we had our first feature module, we began creating more, ranging from 5,000 to 30,000 lines of code. At the same time, we found ways to carve other parts of <code>AsanaCore</code> out into framework-level modules. Eventually, <code>AsanaCore</code> contained just 21% of the code in the app. Pushing code up from <code>AsanaCore</code> into feature modules reduced time spent rebuilding feature code an engineer wasn&#8217;t actively working on, while pushing code &#8220;down&#8221; from <code>AsanaCore</code> into a framework reduced time spent rebuilding code that rarely changed at all during feature development.</p>\n\n\n\n<p>We spent about 3 months incrementally moving code into modules. We&#8217;d establish a beachhead with just a few files, then migrate code into the new module a bit at a time. We also wrote a command line script that could both move files between modules and update their imports.</p>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>Where we are now</strong></h2>\n\n\n\n<p>Our Tuist manifest is about 1,400 lines. A lot of this is intrinsic complexity, doing different things depending on environment variables related to different build types (debug, TestFlight, nightly, etc). Some of it is automation, so it just takes a few lines to add a new module. There&#8217;s very little code that doesn&#8217;t have a critical role in the project definition.</p>\n\n\n\n<p>Our median build time is 15 seconds. We do wish it were even lower, and we expect to get there eventually using build caching, but for now we&#8217;re very happy with our progress. We log all our build times to Scalyr, so I can show you the distribution:</p>\n\n\n\n<figure class=\"wp-block-image\"><img alt=\"Distribution of build times, evenly distributed on a log scale between zero and 200 seconds, with a spike at 15 seconds.\" src=\"https://lh6.googleusercontent.com/swDFoMBuIY-7OnTiOtdq3DdBLJYiF4X_2tmej_eWlq_C-UwhNDf9_S9aSRuT4QfHq63Yo6Tgo1Mn-YrQcGAVXixLFayGxzmaOFzFfnSW1tjhg8QPxmrrZRZRLMZyfNBXL4rATgTTMOPmCJDWU603xC0\" /><figcaption class=\"wp-element-caption\">X axis: seconds to build on a log scale. Y axis: number of builds during the period.</figcaption></figure>\n\n\n\n<p>We&#8217;d love to know whether the type of module modified in a given build affects that build&#8217;s duration, but unfortunately we haven&#8217;t been able to get trustworthy data out of Xcode build logs to find out.</p>\n\n\n\n<p>Our module graph now looks something like this:</p>\n\n\n\n<figure class=\"wp-block-image\"><img alt=\"\" src=\"https://lh6.googleusercontent.com/FMRxlzFz_6JIrpQWkIu6WmgK3J1r04gULk4kju8r0UTO1kaFncFphzZ6zUGmZpwUl_7HM9GygekN9tNsihUnHZuKytcEqQPWlEqOQMfHdtSFYeOQhf2io0Hdf5hGssayp0shRS52OIN47GJ0C10HiTY\" /></figure>\n\n\n\n<p>Splitting the frameworks below <code>AsanaCore</code> like this doesn&#8217;t affect build times much, but down the road, we expect it will let us skip running test suites for code that changes rarely unless that code has been changed.</p>\n\n\n\n<p>Here&#8217;s the breakdown of module size. We&#8217;re roughly where we expected to be, although we hope to get even more code out of <code>AsanaCore</code>, since it mostly represents old features we haven&#8217;t chosen to refactor yet, or code that doesn&#8217;t have a clear home at the moment.</p>\n\n\n\n<figure class=\"wp-block-image\"><img alt=\"Pie chart showing the percentage of code that each module represents. AsanaCore is 21%, CommonUI is 15%, AsanaData is 14%, and then about ten smaller modules take up the other half.\" src=\"https://lh6.googleusercontent.com/HTHzhXr3K0Muu0lAGCQZTiSuzPaFyFxyW3rc77Ffh5HAec665wF12QA0tYFC-ML0NCVaZl22RZ7Lilq1khifwLXKzCemU2L7BEya6CgSx7G44KVdzEr4EZdJfQ1GL5PSTFC-9e2om51iq2nGkcT6020\" /></figure>\n\n\n\n<h2 class=\"wp-block-heading\"><strong>Was it worth it? Should you do the same?</strong></h2>\n\n\n\n<p>With the benefit of hindsight, everyone on the team agrees Tuist has been a hugely positive change. While the migration brought new issues, the benefits are well worth the cost of dealing with those issues.</p>\n\n\n\n<h3 class=\"wp-block-heading\">New problems</h3>\n\n\n\n<p>Tuist is a complex new tool that only a minority of our iOS engineers are comfortable with. We&#8217;ve found that having 3+ Tuist experts is fine in practice, but we&#8217;re always working to help everyone become comfortable with <code>tuist edit</code>. On the bright side, it&#8217;s very rare for anyone to need to edit the Tuist manifest unless they&#8217;re working on some build performance or developer experience improvement.</p>\n\n\n\n<p><code>git checkout</code> takes 5-15 seconds longer than it used to. We wish this were faster, but we also appreciate that we don&#8217;t need to deal with project file merge conflicts at all anymore.</p>\n\n\n\n<p>Using modules has forced us to write a bit more boilerplate code to separate interfaces from implementations. However, in some ways this was a positive change, forcing us to be more explicit about API boundaries between objects.</p>\n\n\n\n<h3 class=\"wp-block-heading\">New benefits</h3>\n\n\n\n<ol>\n<li>Autocomplete works better with modules. Xcode seems much more capable of dealing with many small modules rather than a single big one, perhaps because it can cache its index per target instead of constantly having the current target&#8217;s index invalidated by trivial changes.</li>\n\n\n\n<li>Treating project configuration as code makes sense when your app is complex. It&#8217;s easy to leave comments on changes to the Tuist manifest on a GitHub pull request or in the code, which wasn&#8217;t true at all when we&#8217;d change the Xcode project in the GUI. Project-file-related merge conflicts are all gone.</li>\n\n\n\n<li>Repetitive changes are easy to make. Making a new module requires running one command on the command line and then adding the implementation.</li>\n\n\n\n<li>Being able to completely rely on the filesystem as the arbiter of a file&#8217;s target membership has prevented many errors and drastically reduced the number of clicks it takes to move a group of files between targets. Xcode often guesses wrong which target a new file should belong to, but our handwritten Tuist rules are always right.</li>\n\n\n\n<li>I&#8217;ve said it many times in this article, but it&#8217;s worth saying again: builds are much faster!</li>\n</ol>\n\n\n\n<p>There are additional benefits we haven&#8217;t yet reached for, particularly in the realm of CI. We&#8217;re looking forward to running our tests in parallel, caching build artifacts more aggressively, and running only tests affected by changed code in a PR, rather than running all tests on every PR.</p>\n\n\n\n<p>Personally, if I were starting a new iOS project today, even as a solo developer, I&#8217;d use Tuist from day one. Any team that can deal with the extra complexity should make the switch. Building your own Project.swift from scratch will teach you enough to understand and maintain it.</p>\n\n\n\n<p>We love Tuist so much that we sponsored the project this year. The maintainers have always been responsive and helpful. Thank you for everything, Tuist maintainers!</p>\n</div><p>The post <a href=\"https://blog.asana.com/2023/02/scaling-a-mature-ios-codebase-with-tuist/\" rel=\"nofollow\">Scaling a Mature iOS Codebase with&nbsp;Tuist</a> appeared first on <a href=\"https://blog.asana.com\" rel=\"nofollow\">The Asana Blog</a>.</p>"
      }
    ],
    "wfw_commentrss": "https://blog.asana.com/2023/02/scaling-a-mature-ios-codebase-with-tuist/feed/",
    "slash_comments": "0"
  }
}