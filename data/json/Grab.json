{
  "company": "Grab",
  "title": "Grab",
  "xmlUrl": "http://engineering.grab.com/feed.xml",
  "htmlUrl": "http://engineering.grab.com/",
  "content": "\n\n\n\nKafka on Kubernetes: Reloaded for fault tolerance\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00a0Tech Blog\n\n\n\n\n\nEngineering\n\n\nData Science\n\n\nDesign\n\n\nProduct\n\n\nSecurity\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\nEngineering\n\n\nData Science\n\n\nDesign\n\n\nProduct\n\n\nSecurity\n\n\n\n\n\n\n\n\n\n\n\n\nEngineering \n      \n        \n          \u00b7\n        \n          Data Science \nKafka on Kubernetes: Reloaded for fault tolerance\n\n\n\n\n\n\n\n\n\nFabrice Harbulot\n                  \n                \n                  \n                  \n                    \n                      \u00b7\n                    \n                    Thang Le\n\n26 Dec 2023 | 20 min read\n\n\n\n\n\n\n\nIntroduction\nCoban - Grab\u2019s real-time data streaming platform - has been operating Kafka on Kubernetes with Strimzi in \nproduction for about two years. In a previous article (Zero trust with Kafka), we explained how we leveraged Strimzi to enhance the security of our data streaming offering.\nIn this article, we are going to describe how we improved the fault tolerance of our initial design, to the point where we no longer need to intervene if a Kafka broker is unexpectedly terminated.\nProblem statement\nWe operate Kafka in the AWS Cloud. For the Kafka on Kubernetes design described in this article, we rely on Amazon Elastic Kubernetes Service (EKS), the managed Kubernetes offering by AWS, with the worker nodes deployed as self-managed nodes on Amazon Elastic Compute Cloud (EC2).\nTo make our operations easier and limit the blast radius of any incidents, we deploy exactly one Kafka cluster for each EKS cluster. We also give a full worker node to each Kafka broker. In terms of storage, we initially relied on EC2 instances with non-volatile memory express (NVMe) instance store volumes for \nmaximal I/O performance. Also, each Kafka cluster is accessible beyond its own Virtual Private Cloud (VPC) via a VPC Endpoint Service.\n\nFig. 1 Initial design of a 3-node Kafka cluster running on Kubernetes.\n\n\nFig. 1 shows a logical view of our initial design of a 3-node Kafka on Kubernetes cluster, as typically run by Coban. The Zookeeper and Cruise-Control components are not shown for clarity.\nThere are four Kubernetes services (1): one for the initial connection - referred to as \u201cbootstrap\u201d - that redirects incoming traffic to any Kafka pods, plus one for each Kafka pod, for the clients to target each Kafka broker individually (a requirement to produce or consume from/to a partition that resides on any particular Kafka broker). Four different listeners on the Network Load Balancer (NLB) listening on four different TCP ports, enable the Kafka clients to target either the bootstrap \nservice or any particular Kafka broker they need to reach. This is very similar to what we previously described in Exposing a Kafka Cluster via a VPC Endpoint Service.\nEach worker node hosts a single Kafka pod (2). The NVMe instance store volume is used to create a Kubernetes Persistent Volume (PV), attached to a pod via a Kubernetes Persistent Volume Claim (PVC).\nLastly, the worker nodes belong to Auto-Scaling Groups (ASG) (3), one by Availability Zone (AZ). Strimzi adds in node affinity to make sure that the brokers are evenly distributed across AZs. In this initial design, ASGs are not for auto-scaling though, because we want to keep the size of the cluster under control. We only use ASGs - with a fixed size - to facilitate manual scaling operation and to automatically replace the terminated worker nodes.\nWith this initial design, let us see what happens in case of such a worker node termination.\n\nFig. 2 Representation of a worker node termination. Node C is terminated and replaced by node D. However the Kafka broker 3 pod is unable to restart on node D.\n\n\nFig. 2 shows the worker node C being terminated along with its NVMe instance store volume C, and replaced (by the ASG) by a new worker node D and its new, empty NVMe instance store volume D. On start-up, the worker node D automatically joins the Kubernetes cluster. The Kafka broker 3 pod that was running on the faulty worker node C is scheduled to restart on the new worker node D.\nAlthough the NVMe instance store volume C is terminated along with the worker node C, there is no data loss because all of our Kafka topics are configured with a minimum of three replicas. The data is poised to be copied over from the surviving Kafka brokers 1 and 2 back to Kafka broker 3, as soon as Kafka broker 3 is effectively restarted on the worker node D.\nHowever, there are three fundamental issues with this initial design:\n\nThe Kafka clients that were in the middle of producing or consuming to/from the partition leaders of Kafka broker 3 are suddenly facing connection errors, because the broker was not gracefully demoted beforehand.\nThe target groups of the NLB for both the bootstrap connection and Kafka broker 3 still point to the worker node C. Therefore, the network communication from the NLB to Kafka broker 3 is broken. A manual reconfiguration of the target groups is required.\nThe PVC associating the Kafka broker 3 pod with its instance store PV is unable to automatically switch to the new NVMe instance store volume of the worker node D. Indeed, static provisioning is an intrinsic characteristic of Kubernetes local volumes. The PVC is still in Bound state, so Kubernetes does not take any action. However, the actual storage beneath the PV does not exist anymore. Without any storage, the Kafka broker 3 pod is unable to start.\n\nAt this stage, the Kafka cluster is running in a degraded state with only two out of three brokers, until a Coban engineer intervenes to reconfigure the target groups of the NLB and delete the zombie PVC (this, in turn, triggers its re-creation by Strimzi, this time using the new instance store PV).\nIn the next section, we will see how we have managed to address the three issues mentioned above to make this design fault-tolerant.\nSolution\nGraceful Kafka shutdown\nTo minimise the disruption for the Kafka clients, we leveraged the AWS Node Termination Handler (NTH). This component provided by AWS for Kubernetes environments is able to cordon and drain a worker node that is going to be terminated. This draining, in turn, triggers a graceful shutdown of the Kafka \nprocess by sending a polite SIGTERM signal to all pods running on the worker node that is being drained (instead of the brutal SIGKILL of a normal termination).\nThe termination events of interest that are captured by the NTH are:\n\nScale-in operations by an ASG.\nManual termination of an instance.\nAWS maintenance events, typically EC2 instances scheduled for upcoming retirement.\n\nThis suffices for most of the disruptions our clusters can face in normal times and our common maintenance operations, such as terminating a worker node to refresh it. Only sudden hardware failures (AWS issue events) would fall through the cracks and still trigger errors on the Kafka client side.\nThe NTH comes in two modes: Instance Metadata Service (IMDS) and Queue Processor. We chose to go with the latter as it is able to capture a broader range of events, widening the fault tolerance capability.\nScale-in operations by an ASG\n\nFig. 3 Architecture of the NTH with the Queue Processor.\n\n\nFig. 3 shows the NTH with the Queue Processor in action, and how it reacts to a scale-in operation (typically triggered manually, during a maintenance operation):\n\nAs soon as the scale-in operation is triggered, an Auto Scaling lifecycle hook is invoked to pause the termination of the instance.\nSimultaneously, an Auto Scaling lifecycle hook event is issued to an Amazon Simple Queue Service (SQS) queue. In Fig. 3, we have also materialised EC2 events (e.g. manual termination of an instance, AWS maintenance events, etc.) that transit via Amazon EventBridge to eventually end up in the same SQS queue. We will discuss EC2 events in the next two sections.\nThe NTH, a pod running in the Kubernetes cluster itself, constantly polls that SQS queue.\nWhen a scale-in event pertaining to a worker node of the Kubernetes cluster is read from the SQS queue, the NTH sends to the Kubernetes API the instruction to cordon and drain the impacted worker node.\nOn draining, Kubernetes sends a SIGTERM signal to the Kafka pod residing on the worker node.\nUpon receiving the SIGTERM signal, the Kafka pod gracefully migrates the leadership of its leader partitions to other brokers of the cluster before shutting down, in a transparent manner for the clients. This behaviour is ensured by the controlled.shutdown.enable parameter of Kafka, which is enabled by default.\nOnce the impacted worker node has been drained, the NTH eventually resumes the termination of the instance.\n\nStrimzi also comes with a terminationGracePeriodSeconds parameter, which we have set to 180 seconds to give the Kafka pods enough time to migrate all of their partition leaders gracefully on termination. We have verified that this is enough to migrate all partition leaders on our Kafka clusters (about 60 seconds for 600 partition leaders).\nManual termination of an instance\nThe Auto Scaling lifecycle hook that pauses the termination of an instance (Fig. 3, step 1) as well as the corresponding resuming by the NTH (Fig. 3, step 7) are invoked only for ASG scaling events.\nIn case of a manual termination of an EC2 instance, the termination is captured as an EC2 event that also reaches the NTH. Upon receiving that event, the NTH cordons and drains the impacted worker node. However, the instance is immediately terminated, most likely before the leadership of all of its Kafka partition leaders has had the time to get migrated to other brokers.\nTo work around this and let a manual termination of an EC2 instance also benefit from the ASG lifecycle hook, the instance must be terminated using the terminate-instance-in-auto-scaling-group AWS CLI command.\nAWS maintenance events\nFor AWS maintenance events such as instances scheduled for upcoming retirement, the NTH acts immediately when the event is first received (typically adequately in advance). It cordons and drains the soon-to-be-retired worker node, which in turn triggers the SIGTERM signal and the graceful termination of Kafka as described above. At this stage, the impacted instance is not terminated, so the Kafka partition leaders have plenty of time to complete their migration to other brokers.\nHowever, the evicted Kafka pod has nowhere to go. There is a need for spinning up a new worker node for it to be able to eventually restart somewhere.\nTo make this happen seamlessly, we doubled the maximum size of each of our ASGs and installed the Kubernetes Cluster Autoscaler. With that, when such a maintenance event is received:\n\nThe worker node scheduled for retirement is cordoned and drained by the NTH. The state of the impacted Kafka pod becomes Pending.\nThe Kubernetes Cluster Autoscaler comes into play and triggers the corresponding ASG to spin up a new EC2 instance that joins the Kubernetes cluster as a new worker node.\nThe impacted Kafka pod restarts on the new worker node.\nThe Kubernetes Cluster Autoscaler detects that the previous worker node is now under-utilised and terminates it.\n\nIn this scenario, the impacted Kafka pod only remains in Pending state for about four minutes in total.\nIn case of multiple simultaneous AWS maintenance events, the Kubernetes scheduler would honour our PodDisruptionBudget and not evict more than one Kafka pod at a time.\nDynamic NLB configuration\nTo automatically map the NLB\u2019s target groups with a newly spun up EC2 instance, we leveraged the AWS Load Balancer Controller (LBC).\nLet us see how it works.\n\nFig. 4 Architecture of the LBC managing the NLB's target groups via TargetGroupBinding custom resources.\n\n\nFig. 4 shows how the LBC automates the reconfiguration of the NLB\u2019s target groups:\n\nIt first retrieves the desired state described in Kubernetes custom resources (CR) of type TargetGroupBinding. There is one such resource per target group to maintain. Each TargetGroupBinding CR associates its respective target group with a Kubernetes service.\nThe LBC then watches over the changes of the Kubernetes services that are referenced in the TargetGroupBinding CRs\u2019 definition, specifically the private IP addresses exposed by their respective Endpoints resources.\nWhen a change is detected, it dynamically updates the corresponding NLB\u2019s target groups with those IP addresses as well as the TCP port of the target containers (containerPort).\n\nThis automated design sets up the NLB\u2019s target groups with IP addresses (targetType: ip) instead of EC2 instance IDs (targetType: instance). Although the LBC can handle both target types, the IP address approach is actually more straightforward in our case, since each pod has a routable private IP address in the AWS subnet, thanks to the AWS Container Networking Interface (CNI) plug-in.\nThis dynamic NLB configuration design comes with a challenge. Whenever we need to update the Strimzi CR, the rollout of the change to each Kafka pod in a rolling update fashion is happening too fast for the NLB. This is because the NLB inherently takes some time to mark each target as healthy before enabling it. The Kafka brokers that have just been rolled out start advertising their broker-specific endpoints to the Kafka clients via the bootstrap service, but those \nendpoints are actually not immediately available because the NLB is still checking their health. To mitigate this, we have reduced the HealthCheckIntervalSeconds and HealthyThresholdCount parameters of each target group to their minimum values of 5 and 2 respectively. This reduces the maximum delay for the NLB to detect that a target has become healthy to 10 seconds. In addition, we have configured the LBC with a Pod Readiness Gate. This feature makes the Strimzi rolling deployment wait for the health check of the NLB to pass, before marking the current pod as Ready and proceeding with the next pod.\n\nFig. 5 Steps for a Strimzi rolling deployment with a Pod Readiness Gate. Only one Kafka broker and one NLB listener and target group are shown for simplicity.\n\n\nFig. 5 shows how the Pod Readiness Gate works during a Strimzi rolling deployment:\n\nThe old Kafka pod is terminated.\nThe new Kafka pod starts up and joins the Kafka cluster. Its individual endpoint for direct access via the NLB is immediately advertised by the Kafka cluster. However, at this stage, it is not reachable, as the target group of the NLB still points to the IP address of the old Kafka pod.\nThe LBC updates the target group of the NLB with the IP address of the new Kafka pod, but the NLB health check has not yet passed, so the traffic is not forwarded to the new Kafka pod just yet.\nThe LBC then waits for the NLB health check to pass, which takes 10 seconds. Once the NLB health check has passed, the NLB resumes forwarding the traffic to the Kafka pod.\nFinally, the LBC updates the pod readiness gate of the new Kafka pod. This informs Strimzi that it can proceed with the next pod of the rolling deployment.\n\nData persistence with EBS\nTo address the challenge of the residual PV and PVC of the old worker node preventing Kubernetes from mounting the local storage of the new worker node after a node rotation, we adopted Elastic Block Store (EBS) volumes instead of NVMe instance store volumes. Contrary to the latter, EBS volumes can conveniently be attached and detached. The trade-off is that their performance is significantly lower.\nHowever, relying on EBS comes with additional benefits:\n\nThe cost per GB is lower, compared to NVMe instance store volumes.\nUsing EBS decouples the size of an instance in terms of CPU and memory from its storage capacity, leading to further cost savings by independently right-sizing the instance type and its storage. Such a separation of concerns also opens the door to new use cases requiring disproportionate amounts of storage.\nAfter a worker node rotation, the time needed for the new node to get back in sync is faster, as it only needs to catch up the data that was produced during the downtime. This leads to shorter maintenance operations and higher iteration speed. Incidentally, the associated inter-AZ traffic cost is also lower, since there is less data to transfer among brokers during this time.\nIncreasing the storage capacity is an online operation.\nData backup is supported by taking snapshots of EBS volumes.\n\nWe have verified with our historical monitoring data that the performance of EBS General Purpose 3 (gp3) volumes is significantly above our maximum historical values for both throughput and I/O per second (IOPS), and we have successfully benchmarked a test EBS-based Kafka cluster. We have also set up new monitors to be alerted in case we need to \nprovision either additional throughput or IOPS, beyond the baseline of EBS gp3 volumes.\nWith that, we updated our instance types from storage optimised instances to either general purpose or memory optimised instances. We added the Amazon EBS Container Storage Interface (CSI) driver to the Kubernetes cluster and created a new Kubernetes storage class to let the cluster dynamically provision EBS gp3 volumes.\nWe configured Strimzi to use that storage class to create any new PVCs. This makes Strimzi able to automatically create the EBS volumes it needs, typically when the cluster is first set up, but also to attach/detach the volumes to/from the EC2 instances whenever a Kafka pod is relocated to a different worker node.\nNote that the EBS volumes are not part of any ASG Launch Template, nor do they scale automatically with the ASGs.\n\nFig. 6 Steps for the Strimzi Operator to create an EBS volume and attach it to a new Kafka pod.\n\n\nFig. 6 illustrates how this works when Strimzi sets up a new Kafka broker, for example the first broker of the cluster in the initial setup:\n\nThe Strimzi Cluster Operator first creates a new PVC, specifying a volume size and EBS gp3 as its storage class. The storage class is configured with the EBS CSI Driver as the volume provisioner, so that volumes are dynamically provisioned [1]. However, because it is also set up with volumeBindingMode: WaitForFirstConsumer, the volume is not yet provisioned until a pod actually claims the PVC.\nThe Strimzi Cluster Operator then creates the Kafka pod, with a reference to the newly created PVC. The pod is scheduled to start, which in turn claims the PVC.\nThis triggers the EBS CSI Controller. As the volume provisioner, it dynamically creates a new EBS volume in the AWS VPC, in the AZ of the worker node where the pod has been scheduled to start.\nIt then attaches the newly created EBS volume to the corresponding EC2 instance.\nAfter that, it creates a Kubernetes PV with nodeAffinity and claimRef specifications, making sure that the PV is reserved for the Kafka broker 1 pod.\nLastly, it updates the PVC with the reference of the newly created PV. The PVC is now in Bound state and the Kafka pod can start.\n\nOne important point to take note of is that EBS volumes can only be attached to EC2 instances residing in their own AZ. Therefore, when rotating a worker node, the EBS volume can only be re-attached to the new instance if both old and new instances reside in the same AZ. A simple way to guarantee this is to set up one ASG per AZ, instead of a single ASG spanning across 3 AZs.\nAlso, when such a rotation occurs, the new broker only needs to synchronise the recent data produced during the brief downtime, which is typically an order of magnitude faster than replicating the entire volume (depending on the overall retention period of the hosted Kafka topics).\n\nTable 1 Comparison of the resynchronization of the Kafka data after a broker rotation between the initial design and the new design with EBS volumes.\n\n\n\nInitial design (NVMe instance store volumes)\nNew design (EBS volumes)\n\n\n\n\nData to synchronise\nAll of the data\nRecent data produced during the brief downtime\n\n\nFunction of (primarily)\nRetention period\nDowntime\n\n\nTypical duration\nHours\nMinutes\n\n\n\nOutcome\nWith all that, let us revisit the initial scenario, where a malfunctioning worker node is being replaced by a fresh new node.\n\nFig. 7 Representation of a worker node termination after implementing the solution. Node C is terminated and replaced by node D. This time, the Kafka broker 3 pod is able to start and serve traffic.\n\n\nFig. 7 shows the worker node C being terminated and replaced (by the ASG) by a new worker node D, similar to what we have described in the initial problem statement. The worker node D automatically joins the Kubernetes cluster on start-up.\nHowever, this time, a seamless failover takes place:\n\nThe Kafka clients that were in the middle of producing or consuming to/from the partition leaders of Kafka broker 3 are gracefully redirected to Kafka brokers 1 and 2, where Kafka has migrated the leadership of its leader partitions.\nThe target groups of the NLB for both the bootstrap connection and Kafka broker 3 are automatically updated by the LBC. The connectivity between the NLB and Kafka broker 3 is immediately restored.\nTriggered by the creation of the Kafka broker 3 pod, the Amazon EBS CSI driver running on the worker node D re-attaches the EBS volume 3 that was previously attached to the worker node C, to the worker node D instead. This enables Kubernetes to automatically re-bind the corresponding PV and PVC to Kafka broker 3 pod. With its storage dependency resolved, Kafka broker 3 is able to start successfully and re-join the Kafka cluster. From there, it only needs to catch up with the new data that was produced \nduring its short downtime, by replicating it from Kafka brokers 1 and 2.\n\nWith this fault-tolerant design, when an EC2 instance is being retired by AWS, no particular action is required from our end.\nSimilarly, our EKS version upgrades, as well as any operations that require rotating all worker nodes of the cluster in general, are:\n\nSimpler and less error-prone: We only need to rotate each instance in sequence, with no need for manually reconfiguring the target groups of the NLB and deleting the zombie PVCs anymore.\nFaster: The time between each instance rotation is limited to the short amount of time it takes for the restarted Kafka broker to catch up with the new data.\nMore cost-efficient: There is less data to transfer across AZs (which is charged by AWS).\n\nIt is worth noting that we have chosen to omit Zookeeper and Cruise Control in this article, for the sake of clarity and simplicity. In reality, all pods in the Kubernetes cluster - including Zookeeper and Cruise Control - now benefit from the same graceful stop, triggered by the AWS termination events and the NTH. Similarly, the EBS CSI driver improves the fault tolerance of any pods that use EBS volumes for persistent storage, which includes the Zookeeper pods.\nChallenges faced\nOne challenge that we are facing with this design lies in the EBS volumes\u2019 management.\nOn the one hand, the size of EBS volumes cannot be increased consecutively before the end of a cooldown period (minimum of 6 hours and can exceed 24 hours in some cases [2]). Therefore, when we need to urgently extend some EBS volumes because the size of a Kafka topic is suddenly growing, we need to be relatively generous when sizing the new required capacity and add a comfortable security margin, to make sure that we are not running out of storage in the short run.\nOn the other hand, shrinking a Kubernetes PV is not a supported operation. This can affect the cost efficiency of our design if we overprovision the storage capacity by too much, or in case the workload of a particular cluster organically diminishes.\nOne way to mitigate this challenge is to tactically scale the cluster horizontally (ie. adding new brokers) when there is a need for more storage and the existing EBS volumes are stuck in a cooldown period, or when the new storage need is only temporary.\nWhat\u2019s next?\nIn the future, we can improve the NTH\u2019s capability by utilising webhooks. Upon receiving events from SQS, the NTH can also forward the events to the specified webhook URLs.\nThis can potentially benefit us in a few ways, e.g.:\n\nProactively spinning up a new instance without waiting for the old one to be terminated, whenever a termination event is received. This would shorten the rotation time even further.\nSending Slack notifications to Coban engineers to keep them informed of any actions taken by the NTH.\n\nWe would need to develop and maintain an application that receives webhook events from the NTH and performs the necessary actions.\nIn addition, we are also rolling out Karpenter to replace the Kubernetes Cluster Autoscaler, as it is able to spin up new instances slightly faster, helping reduce the four minutes delay a Kafka pod remains in Pending state during a node rotation. Incidentally, Karpenter also removes the need for setting up one ASG by AZ, as it is able to deterministically provision instances in a specific AZ, for example where a particular EBS volume resides.\nLastly, to ensure that the performance of our EBS gp3 volumes is both sufficient and cost-efficient, we want to explore autoscaling their throughput and IOPS beyond the baseline, based on the usage metrics collected by our monitoring stack.\nReferences\n[1] Dynamic Volume Provisioning | Kubernetes\n[2] Troubleshoot EBS volume stuck in Optimizing state during modification | AWS re:Post\nWe would like to thank our team members and Grab Kubernetes gurus that helped review and improve this blog before publication: Will Ho, Gable Heng, Dewin Goh, Vinnson Lee, Siddharth Pandey, Shi Kai Ng, Quang Minh Tran, Yong Liang Oh, Leon Tay, Tuan Anh Vu. \nJoin us\nGrab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.\nPowered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, join our team today!\n\n\n\nAWS\nData Streaming\nKafka\nKubernetes\n\n\n\n\n  Share on \u00a0\n  \u00a0 Twitter\n\u00a0 Facebook\n\u00a0 LinkedIn\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrab Tech\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJoin Us\n\n          Want to join us in our mission to revolutionize transportation?\n        \nView open positions\n\n\n\n\n\n\n\n\n\n",
  "latestPost": {
    "title": "Kafka on Kubernetes: Reloaded for fault tolerance",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://engineering.grab.com/feed.xml",
      "value": "Kafka on Kubernetes: Reloaded for fault tolerance"
    },
    "summary": "<h2 id=\"introduction\">Introduction</h2>\n\n<p>Coban - Grab\u2019s real-time data streaming platform - has been operating <a href=\"https://kafka.apache.org/\">Kafka</a> on <a href=\"https://kubernetes.io/\">Kubernetes</a> with <a href=\"https://strimzi.io/\">Strimzi</a> in \nproduction for about two years. In a previous article (<a href=\"https://engineering.grab.com/zero-trust-with-kafka\">Zero trust with Kafka</a>), we explained how we leveraged Strimzi to enhance the security of our data streaming offering.</p>\n\n<p>In this article, we are going to describe how we improved the fault tolerance of our initial design, to the point where we no longer need to intervene if a Kafka broker is unexpectedly terminated.</p>\n\n<h2 id=\"problem-statement\">Problem statement</h2>\n\n<p>We operate Kafka in the AWS Cloud. For the Kafka on Kubernetes design described in this article, we rely on <a href=\"https://aws.amazon.com/eks/\">Amazon Elastic Kubernetes Service</a> (EKS), the managed Kubernetes offering by AWS, with the worker nodes deployed as <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/worker.html\">self-managed nodes</a> on <a href=\"https://aws.amazon.com/ec2/\">Amazon Elastic Compute Cloud</a> (EC2).</p>\n\n<p>To make our operations easier and limit the blast radius of any incidents, we deploy exactly one Kafka cluster for each EKS cluster. We also give a full worker node to each Kafka broker. In terms of storage, we initially relied on EC2 instances with <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html\">non-volatile memory express (NVMe) instance store volumes</a> for \nmaximal I/O performance. Also, each Kafka cluster is accessible beyond its own <a href=\"https://aws.amazon.com/vpc/\">Virtual Private Cloud</a> (VPC) via a <a href=\"https://docs.aws.amazon.com/vpc/latest/privatelink/privatelink-share-your-services.html\">VPC Endpoint Service</a>.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image5.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 1 Initial design of a 3-node Kafka cluster running on Kubernetes.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 1 shows a logical view of our initial design of a 3-node Kafka on Kubernetes cluster, as typically run by Coban. The Zookeeper and Cruise-Control components are not shown for clarity.</p>\n\n<p>There are four Kubernetes services (1): one for the initial connection - referred to as \u201cbootstrap\u201d - that redirects incoming traffic to any Kafka pods, plus one for each Kafka pod, for the clients to target each Kafka broker individually (a requirement to produce or consume from/to a partition that resides on any particular Kafka broker). Four different listeners on the Network Load Balancer (NLB) listening on four different TCP ports, enable the Kafka clients to target either the bootstrap \nservice or any particular Kafka broker they need to reach. This is very similar to what we previously described in <a href=\"https://engineering.grab.com/exposing-kafka-cluster\">Exposing a Kafka Cluster via a VPC Endpoint Service</a>.</p>\n\n<p>Each worker node hosts a single Kafka pod (2). The NVMe instance store volume is used to create a Kubernetes Persistent Volume (PV), attached to a pod via a Kubernetes Persistent Volume Claim (PVC).</p>\n\n<p>Lastly, the worker nodes belong to <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html\">Auto-Scaling Groups</a> (ASG) (3), one by <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones\">Availability Zone</a> (AZ). Strimzi adds in node affinity to make sure that the brokers are evenly distributed across AZs. In this initial design, ASGs are not for auto-scaling though, because we want to keep the size of the cluster under control. We only use ASGs - with a fixed size - to facilitate manual scaling operation and to automatically replace the terminated worker nodes.</p>\n\n<p>With this initial design, let us see what happens in case of such a worker node termination.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image4.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 2 Representation of a worker node termination. Node C is terminated and replaced by node D. However the Kafka broker 3 pod is unable to restart on node D.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 2 shows the worker node C being terminated along with its NVMe instance store volume C, and replaced (by the ASG) by a new worker node D and its new, empty NVMe instance store volume D. On start-up, the worker node D automatically joins the Kubernetes cluster. The Kafka broker 3 pod that was running on the faulty worker node C is scheduled to restart on the new worker node D.</p>\n\n<p>Although the NVMe instance store volume C is terminated along with the worker node C, there is no data loss because all of our Kafka topics are configured with a minimum of three replicas. The data is poised to be copied over from the surviving Kafka brokers 1 and 2 back to Kafka broker 3, as soon as Kafka broker 3 is effectively restarted on the worker node D.</p>\n\n<p>However, there are three fundamental issues with this initial design:</p>\n\n<ol>\n  <li>The Kafka clients that were in the middle of producing or consuming to/from the partition leaders of Kafka broker 3 are suddenly facing connection errors, because the broker was not gracefully demoted beforehand.</li>\n  <li>The target groups of the NLB for both the bootstrap connection and Kafka broker 3 still point to the worker node C. Therefore, the network communication from the NLB to Kafka broker 3 is broken. A manual reconfiguration of the target groups is required.</li>\n  <li>The PVC associating the Kafka broker 3 pod with its instance store PV is unable to automatically switch to the new NVMe instance store volume of the worker node D. Indeed, static provisioning is an intrinsic characteristic of Kubernetes <a href=\"https://kubernetes.io/docs/concepts/storage/volumes/#local\">local volumes</a>. The PVC is still in <em>Bound</em> state, so Kubernetes does not take any action. However, the actual storage beneath the PV does not exist anymore. Without any storage, the Kafka broker 3 pod is unable to start.</li>\n</ol>\n\n<p>At this stage, the Kafka cluster is running in a degraded state with only two out of three brokers, until a Coban engineer intervenes to reconfigure the target groups of the NLB and delete the zombie PVC (this, in turn, triggers its re-creation by Strimzi, this time using the new instance store PV).</p>\n\n<p>In the next section, we will see how we have managed to address the three issues mentioned above to make this design fault-tolerant.</p>\n\n<h2 id=\"solution\">Solution</h2>\n\n<h3 id=\"graceful-kafka-shutdown\">Graceful Kafka shutdown</h3>\n\n<p>To minimise the disruption for the Kafka clients, we leveraged the <a href=\"https://aws-quickstart.github.io/cdk-eks-blueprints/addons/aws-node-termination-handler/\">AWS Node Termination Handler</a> (NTH). This component provided by AWS for Kubernetes environments is able to cordon and drain a worker node that is going to be terminated. This draining, in turn, triggers a graceful shutdown of the Kafka \nprocess by sending a polite <a href=\"https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html\">SIGTERM</a> signal to all pods running on the worker node that is being drained (instead of the brutal <a href=\"https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html\">SIGKILL</a> of a normal termination).</p>\n\n<p>The termination events of interest that are captured by the NTH are:</p>\n\n<ul>\n  <li>Scale-in operations by an ASG.</li>\n  <li>Manual termination of an instance.</li>\n  <li>AWS maintenance events, typically EC2 instances scheduled for upcoming retirement.</li>\n</ul>\n\n<p>This suffices for most of the disruptions our clusters can face in normal times and our common maintenance operations, such as terminating a worker node to refresh it. Only sudden hardware failures (AWS issue events) would fall through the cracks and still trigger errors on the Kafka client side.</p>\n\n<p>The NTH comes in two modes: <a href=\"https://github.com/aws/aws-node-termination-handler#major-features\">Instance Metadata Service (IMDS) and Queue Processor</a>. We chose to go with the latter as it is able to capture a broader range of events, widening the fault tolerance capability.</p>\n\n<h4 id=\"scale-in-operations-by-an-asg\">Scale-in operations by an ASG</h4>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image2.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 3 Architecture of the NTH with the Queue Processor.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 3 shows the NTH with the Queue Processor in action, and how it reacts to a scale-in operation (typically triggered manually, during a maintenance operation):</p>\n\n<ol>\n  <li>As soon as the scale-in operation is triggered, an <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/lifecycle-hooks.html\">Auto Scaling lifecycle hook</a> is invoked to pause the termination of the instance.</li>\n  <li>Simultaneously, an Auto Scaling lifecycle hook event is issued to an <a href=\"https://aws.amazon.com/sqs/\">Amazon Simple Queue Service</a> (SQS) queue. In Fig. 3, we have also materialised EC2 events (e.g. manual termination of an instance, AWS maintenance events, etc.) that transit via <a href=\"https://aws.amazon.com/eventbridge/\">Amazon EventBridge</a> to eventually end up in the same SQS queue. We will discuss EC2 events in the next two sections.</li>\n  <li>The NTH, a pod running in the Kubernetes cluster itself, constantly polls that SQS queue.</li>\n  <li>When a scale-in event pertaining to a worker node of the Kubernetes cluster is read from the SQS queue, the NTH sends to the Kubernetes API the instruction to <a href=\"https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration\">cordon</a> and <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/\">drain</a> the impacted worker node.</li>\n  <li>On draining, Kubernetes sends a SIGTERM signal to the Kafka pod residing on the worker node.</li>\n  <li>Upon receiving the SIGTERM signal, the Kafka pod gracefully migrates the leadership of its leader partitions to other brokers of the cluster before shutting down, in a transparent manner for the clients. This behaviour is ensured by the <a href=\"https://kafka.apache.org/documentation/#basic_ops_restarting\"><code class=\"language-plaintext highlighter-rouge\">controlled.shutdown.enable</code></a> parameter of Kafka, which is enabled by default.</li>\n  <li>Once the impacted worker node has been drained, the NTH eventually resumes the termination of the instance.</li>\n</ol>\n\n<p>Strimzi also comes with a <code class=\"language-plaintext highlighter-rouge\">terminationGracePeriodSeconds</code> parameter, which we have set to 180 seconds to give the Kafka pods enough time to migrate all of their partition leaders gracefully on termination. We have verified that this is enough to migrate all partition leaders on our Kafka clusters (about 60 seconds for 600 partition leaders).</p>\n\n<h4 id=\"manual-termination-of-an-instance\">Manual termination of an instance</h4>\n\n<p>The Auto Scaling lifecycle hook that pauses the termination of an instance (Fig. 3, step 1) as well as the corresponding resuming by the NTH (Fig. 3, step 7) are invoked only for ASG scaling events.</p>\n\n<p>In case of a manual termination of an EC2 instance, the termination is captured as an EC2 event that also reaches the NTH. Upon receiving that event, the NTH cordons and drains the impacted worker node. However, the instance is immediately terminated, most likely before the leadership of all of its Kafka partition leaders has had the time to get migrated to other brokers.</p>\n\n<p>To work around this and let a manual termination of an EC2 instance also benefit from the ASG lifecycle hook, the instance must be terminated using the <a href=\"https://docs.aws.amazon.com/cli/latest/reference/autoscaling/terminate-instance-in-auto-scaling-group.html\"><code class=\"language-plaintext highlighter-rouge\">terminate-instance-in-auto-scaling-group</code></a> AWS CLI command.</p>\n\n<h4 id=\"aws-maintenance-events\">AWS maintenance events</h4>\n\n<p>For AWS maintenance events such as instances scheduled for upcoming retirement, the NTH acts immediately when the event is first received (typically adequately in advance). It cordons and drains the soon-to-be-retired worker node, which in turn triggers the SIGTERM signal and the graceful termination of Kafka as described above. At this stage, the impacted instance is not terminated, so the Kafka partition leaders have plenty of time to complete their migration to other brokers.</p>\n\n<p>However, the evicted Kafka pod has nowhere to go. There is a need for spinning up a new worker node for it to be able to eventually restart somewhere.</p>\n\n<p>To make this happen seamlessly, we doubled the maximum size of each of our ASGs and installed the <a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md\">Kubernetes Cluster Autoscaler</a>. With that, when such a maintenance event is received:</p>\n\n<ul>\n  <li>The worker node scheduled for retirement is cordoned and drained by the NTH. The state of the impacted Kafka pod becomes <em>Pending</em>.</li>\n  <li>The Kubernetes Cluster Autoscaler comes into play and triggers the corresponding ASG to spin up a new EC2 instance that joins the Kubernetes cluster as a new worker node.</li>\n  <li>The impacted Kafka pod restarts on the new worker node.</li>\n  <li>The Kubernetes Cluster Autoscaler detects that the previous worker node is now under-utilised and terminates it.</li>\n</ul>\n\n<p>In this scenario, the impacted Kafka pod only remains in <em>Pending</em> state for about four minutes in total.</p>\n\n<p>In case of multiple simultaneous AWS maintenance events, the Kubernetes scheduler would honour our <a href=\"https://kubernetes.io/docs/tasks/run-application/configure-pdb/\">PodDisruptionBudget</a> and not evict more than one Kafka pod at a time.</p>\n\n<h3 id=\"dynamic-nlb-configuration\">Dynamic NLB configuration</h3>\n\n<p>To automatically map the NLB\u2019s target groups with a newly spun up EC2 instance, we leveraged the <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/aws-load-balancer-controller.html\">AWS Load Balancer Controller</a> (LBC).</p>\n\n<p>Let us see how it works.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image6.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 4 Architecture of the LBC managing the NLB's target groups via TargetGroupBinding custom resources.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 4 shows how the LBC automates the reconfiguration of the NLB\u2019s target groups:</p>\n\n<ol>\n  <li>It first retrieves the desired state described in Kubernetes <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\">custom resources</a> (CR) of type <a href=\"https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/guide/targetgroupbinding/targetgroupbinding\">TargetGroupBinding</a>. There is one such resource per target group to maintain. Each TargetGroupBinding CR associates its respective target group with a Kubernetes service.</li>\n  <li>The LBC then watches over the changes of the Kubernetes services that are referenced in the TargetGroupBinding CRs\u2019 definition, specifically the private IP addresses exposed by their respective <a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#endpoints\">Endpoints resources</a>.</li>\n  <li>When a change is detected, it dynamically updates the corresponding NLB\u2019s target groups with those IP addresses as well as the TCP port of the target containers (<code class=\"language-plaintext highlighter-rouge\">containerPort</code>).</li>\n</ol>\n\n<p>This automated design sets up the NLB\u2019s target groups with IP addresses (<code class=\"language-plaintext highlighter-rouge\">targetType: ip</code>) instead of EC2 instance IDs (<code class=\"language-plaintext highlighter-rouge\">targetType: instance</code>). Although the LBC can handle both target types, the IP address approach is actually more straightforward in our case, since each pod has a routable private IP address in the AWS subnet, thanks to the <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/managing-vpc-cni.html\">AWS Container Networking Interface</a> (CNI) plug-in.</p>\n\n<p>This dynamic NLB configuration design comes with a challenge. Whenever we need to update the Strimzi CR, the rollout of the change to each Kafka pod in a rolling update fashion is happening too fast for the NLB. This is because the NLB inherently takes some time to mark each target as healthy before enabling it. The Kafka brokers that have just been rolled out start advertising their broker-specific endpoints to the Kafka clients via the bootstrap service, but those \nendpoints are actually not immediately available because the NLB is still checking their health. To mitigate this, we have reduced the <code class=\"language-plaintext highlighter-rouge\">HealthCheckIntervalSeconds</code> and <code class=\"language-plaintext highlighter-rouge\">HealthyThresholdCount</code> parameters of each target group to their minimum values of 5 and 2 respectively. This reduces the maximum delay for the NLB to detect that a target has become healthy to 10 seconds. In addition, we have configured the LBC with a <a href=\"https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/deploy/pod_readiness_gate/\">Pod Readiness Gate</a>. This feature makes the Strimzi rolling deployment wait for the health check of the NLB to pass, before marking the current pod as <em>Ready</em> and proceeding with the next pod.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image7.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 5 Steps for a Strimzi rolling deployment with a Pod Readiness Gate. Only one Kafka broker and one NLB listener and target group are shown for simplicity.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 5 shows how the Pod Readiness Gate works during a Strimzi rolling deployment:</p>\n\n<ol>\n  <li>The old Kafka pod is terminated.</li>\n  <li>The new Kafka pod starts up and joins the Kafka cluster. Its individual endpoint for direct access via the NLB is immediately advertised by the Kafka cluster. However, at this stage, it is not reachable, as the target group of the NLB still points to the IP address of the old Kafka pod.</li>\n  <li>The LBC updates the target group of the NLB with the IP address of the new Kafka pod, but the NLB health check has not yet passed, so the traffic is not forwarded to the new Kafka pod just yet.</li>\n  <li>The LBC then waits for the NLB health check to pass, which takes 10 seconds. Once the NLB health check has passed, the NLB resumes forwarding the traffic to the Kafka pod.</li>\n  <li>Finally, the LBC updates the pod readiness gate of the new Kafka pod. This informs Strimzi that it can proceed with the next pod of the rolling deployment.</li>\n</ol>\n\n<h3 id=\"data-persistence-with-ebs\">Data persistence with EBS</h3>\n\n<p>To address the challenge of the residual PV and PVC of the old worker node preventing Kubernetes from mounting the local storage of the new worker node after a node rotation, we adopted <a href=\"https://aws.amazon.com/ebs/\">Elastic Block Store</a> (EBS) volumes instead of NVMe instance store volumes. Contrary to the latter, EBS volumes can conveniently be attached and detached. The trade-off is that their performance is significantly lower.</p>\n\n<p>However, relying on EBS comes with additional benefits:</p>\n\n<ul>\n  <li>The cost per GB is lower, compared to NVMe instance store volumes.</li>\n  <li>Using EBS decouples the size of an instance in terms of CPU and memory from its storage capacity, leading to further cost savings by independently right-sizing the instance type and its storage. Such a separation of concerns also opens the door to new use cases requiring disproportionate amounts of storage.</li>\n  <li>After a worker node rotation, the time needed for the new node to get back in sync is faster, as it only needs to catch up the data that was produced during the downtime. This leads to shorter maintenance operations and higher iteration speed. Incidentally, the associated inter-AZ traffic cost is also lower, since there is less data to transfer among brokers during this time.</li>\n  <li>Increasing the storage capacity is an online operation.</li>\n  <li>Data backup is supported by taking snapshots of EBS volumes.</li>\n</ul>\n\n<p>We have verified with our historical monitoring data that the performance of <a href=\"https://aws.amazon.com/ebs/general-purpose/\">EBS General Purpose 3</a> (gp3) volumes is significantly above our maximum historical values for both throughput and I/O per second (IOPS), and we have successfully benchmarked a test EBS-based Kafka cluster. We have also set up new monitors to be alerted in case we need to \nprovision either additional throughput or IOPS, beyond the baseline of EBS gp3 volumes.</p>\n\n<p>With that, we updated our instance types from storage optimised instances to either general purpose or memory optimised instances. We added the <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html\">Amazon EBS Container Storage Interface (CSI) driver</a> to the Kubernetes cluster and created a new Kubernetes <a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/\">storage class</a> to let the cluster dynamically provision EBS gp3 volumes.</p>\n\n<p>We configured Strimzi to use that storage class to create any new PVCs. This makes Strimzi able to automatically create the EBS volumes it needs, typically when the cluster is first set up, but also to attach/detach the volumes to/from the EC2 instances whenever a Kafka pod is relocated to a different worker node.</p>\n\n<p>Note that the EBS volumes are not part of any ASG <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/launch-templates.html\">Launch Template</a>, nor do they scale automatically with the ASGs.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image3.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 6 Steps for the Strimzi Operator to create an EBS volume and attach it to a new Kafka pod.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 6 illustrates how this works when Strimzi sets up a new Kafka broker, for example the first broker of the cluster in the initial setup:</p>\n\n<ol>\n  <li>The <a href=\"https://strimzi.io/docs/operators/latest/overview#overview-components-cluster-operator-str\">Strimzi Cluster Operator</a> first creates a new PVC, specifying a volume size and EBS gp3 as its storage class. The storage class is configured with the EBS CSI Driver as the volume provisioner, so that volumes are dynamically provisioned <a href=\"https://engineering.grab.com/feed.xml#1\">[1]</a>. However, because it is also set up with <code class=\"language-plaintext highlighter-rouge\">volumeBindingMode: WaitForFirstConsumer</code>, the volume is not yet provisioned until a pod actually claims the PVC.</li>\n  <li>The Strimzi Cluster Operator then creates the Kafka pod, with a reference to the newly created PVC. The pod is scheduled to start, which in turn claims the PVC.</li>\n  <li>This triggers the EBS CSI Controller. As the volume provisioner, it dynamically creates a new EBS volume in the AWS VPC, in the AZ of the worker node where the pod has been scheduled to start.</li>\n  <li>It then attaches the newly created EBS volume to the corresponding EC2 instance.</li>\n  <li>After that, it creates a Kubernetes PV with <a href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#node-affinity\">nodeAffinity</a> and <a href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume\">claimRef</a> specifications, making sure that the PV is reserved for the Kafka broker 1 pod.</li>\n  <li>Lastly, it updates the PVC with the reference of the newly created PV. The PVC is now in <em>Bound</em> state and the Kafka pod can start.</li>\n</ol>\n\n<p>One important point to take note of is that EBS volumes can only be attached to EC2 instances residing in their own AZ. Therefore, when rotating a worker node, the EBS volume can only be re-attached to the new instance if both old and new instances reside in the same AZ. A simple way to guarantee this is to set up one ASG per AZ, instead of a single ASG spanning across 3 AZs.</p>\n\n<p>Also, when such a rotation occurs, the new broker only needs to synchronise the recent data produced during the brief downtime, which is typically an order of magnitude faster than replicating the entire volume (depending on the overall retention period of the hosted Kafka topics).</p>\n\n<table class=\"table\">\n<caption style=\"text-align: center;\">Table 1 Comparison of the resynchronization of the Kafka data after a broker rotation between the initial design and the new design with EBS volumes.</caption>\n<thead>\n  <tr>\n    <th></th>\n    <th>Initial design (NVMe instance store volumes)</th>\n    <th>New design (EBS volumes)</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Data to synchronise</td>\n    <td>All of the data</td>\n    <td>Recent data produced during the brief downtime</td>\n  </tr>\n  <tr>\n    <td>Function of (primarily)</td>\n    <td>Retention period</td>\n    <td>Downtime</td>\n  </tr>\n  <tr>\n    <td>Typical duration</td>\n    <td>Hours</td>\n    <td>Minutes</td>\n  </tr>\n</tbody>\n</table>\n\n<h2 id=\"outcome\">Outcome</h2>\n\n<p>With all that, let us revisit the initial scenario, where a malfunctioning worker node is being replaced by a fresh new node.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image1.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 7 Representation of a worker node termination after implementing the solution. Node C is terminated and replaced by node D. This time, the Kafka broker 3 pod is able to start and serve traffic.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 7 shows the worker node C being terminated and replaced (by the ASG) by a new worker node D, similar to what we have described in the initial problem statement. The worker node D automatically joins the Kubernetes cluster on start-up.</p>\n\n<p>However, this time, a seamless failover takes place:</p>\n\n<ol>\n  <li>The Kafka clients that were in the middle of producing or consuming to/from the partition leaders of Kafka broker 3 are gracefully redirected to Kafka brokers 1 and 2, where Kafka has migrated the leadership of its leader partitions.</li>\n  <li>The target groups of the NLB for both the bootstrap connection and Kafka broker 3 are automatically updated by the LBC. The connectivity between the NLB and Kafka broker 3 is immediately restored.</li>\n  <li>Triggered by the creation of the Kafka broker 3 pod, the Amazon EBS CSI driver running on the worker node D re-attaches the EBS volume 3 that was previously attached to the worker node C, to the worker node D instead. This enables Kubernetes to automatically re-bind the corresponding PV and PVC to Kafka broker 3 pod. With its storage dependency resolved, Kafka broker 3 is able to start successfully and re-join the Kafka cluster. From there, it only needs to catch up with the new data that was produced \nduring its short downtime, by replicating it from Kafka brokers 1 and 2.</li>\n</ol>\n\n<p>With this fault-tolerant design, when an EC2 instance is being retired by AWS, no particular action is required from our end.</p>\n\n<p>Similarly, our EKS version upgrades, as well as any operations that require rotating all worker nodes of the cluster in general, are:</p>\n\n<ul>\n  <li><strong>Simpler and less error-prone</strong>: We only need to rotate each instance in sequence, with no need for manually reconfiguring the target groups of the NLB and deleting the zombie PVCs anymore.</li>\n  <li><strong>Faster</strong>: The time between each instance rotation is limited to the short amount of time it takes for the restarted Kafka broker to catch up with the new data.</li>\n  <li><strong>More cost-efficient</strong>: There is less data to transfer across AZs (which is charged by AWS).</li>\n</ul>\n\n<p>It is worth noting that we have chosen to omit Zookeeper and Cruise Control in this article, for the sake of clarity and simplicity. In reality, all pods in the Kubernetes cluster - including Zookeeper and Cruise Control - now benefit from the same graceful stop, triggered by the AWS termination events and the NTH. Similarly, the EBS CSI driver improves the fault tolerance of any pods that use EBS volumes for persistent storage, which includes the Zookeeper pods.</p>\n\n<h2 id=\"challenges-faced\">Challenges faced</h2>\n\n<p>One challenge that we are facing with this design lies in the EBS volumes\u2019 management.</p>\n\n<p>On the one hand, the size of EBS volumes cannot be increased consecutively before the end of a cooldown period (minimum of 6 hours and can exceed 24 hours in some cases <a href=\"https://engineering.grab.com/feed.xml#2\">[2]</a>). Therefore, when we need to urgently extend some EBS volumes because the size of a Kafka topic is suddenly growing, we need to be relatively generous when sizing the new required capacity and add a comfortable security margin, to make sure that we are not running out of storage in the short run.</p>\n\n<p>On the other hand, shrinking a Kubernetes PV is not a supported operation. This can affect the cost efficiency of our design if we overprovision the storage capacity by too much, or in case the workload of a particular cluster organically diminishes.</p>\n\n<p>One way to mitigate this challenge is to tactically scale the cluster horizontally (ie. adding new brokers) when there is a need for more storage and the existing EBS volumes are stuck in a cooldown period, or when the new storage need is only temporary.</p>\n\n<h2 id=\"whats-next\">What\u2019s next?</h2>\n\n<p>In the future, we can improve the NTH\u2019s capability by utilising webhooks. Upon receiving events from SQS, the NTH can also forward the events to the specified webhook URLs.</p>\n\n<p>This can potentially benefit us in a few ways, e.g.:</p>\n\n<ul>\n  <li>Proactively spinning up a new instance without waiting for the old one to be terminated, whenever a termination event is received. This would shorten the rotation time even further.</li>\n  <li>Sending Slack notifications to Coban engineers to keep them informed of any actions taken by the NTH.</li>\n</ul>\n\n<p>We would need to develop and maintain an application that receives webhook events from the NTH and performs the necessary actions.</p>\n\n<p>In addition, we are also rolling out <a href=\"https://karpenter.sh/\">Karpenter</a> to replace the Kubernetes Cluster Autoscaler, as it is able to spin up new instances slightly faster, helping reduce the four minutes delay a Kafka pod remains in <em>Pending</em> state during a node rotation. Incidentally, Karpenter also removes the need for setting up one ASG by AZ, as it is able to deterministically provision instances in a specific AZ, for example where a particular EBS volume resides.</p>\n\n<p>Lastly, to ensure that the performance of our EBS gp3 volumes is both sufficient and cost-efficient, we want to explore autoscaling their throughput and IOPS beyond the baseline, based on the usage metrics collected by our monitoring stack.</p>\n\n<h2 id=\"references\">References</h2>\n\n<p><a href=\"https://engineering.grab.com/feed.xml#1\" name=\"1\">[1]</a> <a href=\"https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/\">Dynamic Volume Provisioning | Kubernetes</a></p>\n\n<p><a href=\"https://engineering.grab.com/feed.xml#2\" name=\"2\">[2]</a> <a href=\"https://repost.aws/knowledge-center/ebs-volume-stuck-optimizing-on-modification\">Troubleshoot EBS volume stuck in Optimizing state during modification | AWS re:Post</a></p>\n\n<p><small class=\"credits\">We would like to thank our team members and Grab Kubernetes gurus that helped review and improve this blog before publication: Will Ho, Gable Heng, Dewin Goh, Vinnson Lee, Siddharth Pandey, Shi Kai Ng, Quang Minh Tran, Yong Liang Oh, Leon Tay, Tuan Anh Vu. </small></p>\n\n<h1 id=\"join-us\">Join us</h1>\n\n<p>Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.</p>\n\n<p>Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, <a href=\"https://grab.careers/\">join our team</a> today!</p>",
    "summary_detail": {
      "type": "text/html",
      "language": null,
      "base": "https://engineering.grab.com/feed.xml",
      "value": "<h2 id=\"introduction\">Introduction</h2>\n\n<p>Coban - Grab\u2019s real-time data streaming platform - has been operating <a href=\"https://kafka.apache.org/\">Kafka</a> on <a href=\"https://kubernetes.io/\">Kubernetes</a> with <a href=\"https://strimzi.io/\">Strimzi</a> in \nproduction for about two years. In a previous article (<a href=\"https://engineering.grab.com/zero-trust-with-kafka\">Zero trust with Kafka</a>), we explained how we leveraged Strimzi to enhance the security of our data streaming offering.</p>\n\n<p>In this article, we are going to describe how we improved the fault tolerance of our initial design, to the point where we no longer need to intervene if a Kafka broker is unexpectedly terminated.</p>\n\n<h2 id=\"problem-statement\">Problem statement</h2>\n\n<p>We operate Kafka in the AWS Cloud. For the Kafka on Kubernetes design described in this article, we rely on <a href=\"https://aws.amazon.com/eks/\">Amazon Elastic Kubernetes Service</a> (EKS), the managed Kubernetes offering by AWS, with the worker nodes deployed as <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/worker.html\">self-managed nodes</a> on <a href=\"https://aws.amazon.com/ec2/\">Amazon Elastic Compute Cloud</a> (EC2).</p>\n\n<p>To make our operations easier and limit the blast radius of any incidents, we deploy exactly one Kafka cluster for each EKS cluster. We also give a full worker node to each Kafka broker. In terms of storage, we initially relied on EC2 instances with <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ssd-instance-store.html\">non-volatile memory express (NVMe) instance store volumes</a> for \nmaximal I/O performance. Also, each Kafka cluster is accessible beyond its own <a href=\"https://aws.amazon.com/vpc/\">Virtual Private Cloud</a> (VPC) via a <a href=\"https://docs.aws.amazon.com/vpc/latest/privatelink/privatelink-share-your-services.html\">VPC Endpoint Service</a>.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image5.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 1 Initial design of a 3-node Kafka cluster running on Kubernetes.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 1 shows a logical view of our initial design of a 3-node Kafka on Kubernetes cluster, as typically run by Coban. The Zookeeper and Cruise-Control components are not shown for clarity.</p>\n\n<p>There are four Kubernetes services (1): one for the initial connection - referred to as \u201cbootstrap\u201d - that redirects incoming traffic to any Kafka pods, plus one for each Kafka pod, for the clients to target each Kafka broker individually (a requirement to produce or consume from/to a partition that resides on any particular Kafka broker). Four different listeners on the Network Load Balancer (NLB) listening on four different TCP ports, enable the Kafka clients to target either the bootstrap \nservice or any particular Kafka broker they need to reach. This is very similar to what we previously described in <a href=\"https://engineering.grab.com/exposing-kafka-cluster\">Exposing a Kafka Cluster via a VPC Endpoint Service</a>.</p>\n\n<p>Each worker node hosts a single Kafka pod (2). The NVMe instance store volume is used to create a Kubernetes Persistent Volume (PV), attached to a pod via a Kubernetes Persistent Volume Claim (PVC).</p>\n\n<p>Lastly, the worker nodes belong to <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html\">Auto-Scaling Groups</a> (ASG) (3), one by <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones\">Availability Zone</a> (AZ). Strimzi adds in node affinity to make sure that the brokers are evenly distributed across AZs. In this initial design, ASGs are not for auto-scaling though, because we want to keep the size of the cluster under control. We only use ASGs - with a fixed size - to facilitate manual scaling operation and to automatically replace the terminated worker nodes.</p>\n\n<p>With this initial design, let us see what happens in case of such a worker node termination.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image4.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 2 Representation of a worker node termination. Node C is terminated and replaced by node D. However the Kafka broker 3 pod is unable to restart on node D.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 2 shows the worker node C being terminated along with its NVMe instance store volume C, and replaced (by the ASG) by a new worker node D and its new, empty NVMe instance store volume D. On start-up, the worker node D automatically joins the Kubernetes cluster. The Kafka broker 3 pod that was running on the faulty worker node C is scheduled to restart on the new worker node D.</p>\n\n<p>Although the NVMe instance store volume C is terminated along with the worker node C, there is no data loss because all of our Kafka topics are configured with a minimum of three replicas. The data is poised to be copied over from the surviving Kafka brokers 1 and 2 back to Kafka broker 3, as soon as Kafka broker 3 is effectively restarted on the worker node D.</p>\n\n<p>However, there are three fundamental issues with this initial design:</p>\n\n<ol>\n  <li>The Kafka clients that were in the middle of producing or consuming to/from the partition leaders of Kafka broker 3 are suddenly facing connection errors, because the broker was not gracefully demoted beforehand.</li>\n  <li>The target groups of the NLB for both the bootstrap connection and Kafka broker 3 still point to the worker node C. Therefore, the network communication from the NLB to Kafka broker 3 is broken. A manual reconfiguration of the target groups is required.</li>\n  <li>The PVC associating the Kafka broker 3 pod with its instance store PV is unable to automatically switch to the new NVMe instance store volume of the worker node D. Indeed, static provisioning is an intrinsic characteristic of Kubernetes <a href=\"https://kubernetes.io/docs/concepts/storage/volumes/#local\">local volumes</a>. The PVC is still in <em>Bound</em> state, so Kubernetes does not take any action. However, the actual storage beneath the PV does not exist anymore. Without any storage, the Kafka broker 3 pod is unable to start.</li>\n</ol>\n\n<p>At this stage, the Kafka cluster is running in a degraded state with only two out of three brokers, until a Coban engineer intervenes to reconfigure the target groups of the NLB and delete the zombie PVC (this, in turn, triggers its re-creation by Strimzi, this time using the new instance store PV).</p>\n\n<p>In the next section, we will see how we have managed to address the three issues mentioned above to make this design fault-tolerant.</p>\n\n<h2 id=\"solution\">Solution</h2>\n\n<h3 id=\"graceful-kafka-shutdown\">Graceful Kafka shutdown</h3>\n\n<p>To minimise the disruption for the Kafka clients, we leveraged the <a href=\"https://aws-quickstart.github.io/cdk-eks-blueprints/addons/aws-node-termination-handler/\">AWS Node Termination Handler</a> (NTH). This component provided by AWS for Kubernetes environments is able to cordon and drain a worker node that is going to be terminated. This draining, in turn, triggers a graceful shutdown of the Kafka \nprocess by sending a polite <a href=\"https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html\">SIGTERM</a> signal to all pods running on the worker node that is being drained (instead of the brutal <a href=\"https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html\">SIGKILL</a> of a normal termination).</p>\n\n<p>The termination events of interest that are captured by the NTH are:</p>\n\n<ul>\n  <li>Scale-in operations by an ASG.</li>\n  <li>Manual termination of an instance.</li>\n  <li>AWS maintenance events, typically EC2 instances scheduled for upcoming retirement.</li>\n</ul>\n\n<p>This suffices for most of the disruptions our clusters can face in normal times and our common maintenance operations, such as terminating a worker node to refresh it. Only sudden hardware failures (AWS issue events) would fall through the cracks and still trigger errors on the Kafka client side.</p>\n\n<p>The NTH comes in two modes: <a href=\"https://github.com/aws/aws-node-termination-handler#major-features\">Instance Metadata Service (IMDS) and Queue Processor</a>. We chose to go with the latter as it is able to capture a broader range of events, widening the fault tolerance capability.</p>\n\n<h4 id=\"scale-in-operations-by-an-asg\">Scale-in operations by an ASG</h4>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image2.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 3 Architecture of the NTH with the Queue Processor.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 3 shows the NTH with the Queue Processor in action, and how it reacts to a scale-in operation (typically triggered manually, during a maintenance operation):</p>\n\n<ol>\n  <li>As soon as the scale-in operation is triggered, an <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/lifecycle-hooks.html\">Auto Scaling lifecycle hook</a> is invoked to pause the termination of the instance.</li>\n  <li>Simultaneously, an Auto Scaling lifecycle hook event is issued to an <a href=\"https://aws.amazon.com/sqs/\">Amazon Simple Queue Service</a> (SQS) queue. In Fig. 3, we have also materialised EC2 events (e.g. manual termination of an instance, AWS maintenance events, etc.) that transit via <a href=\"https://aws.amazon.com/eventbridge/\">Amazon EventBridge</a> to eventually end up in the same SQS queue. We will discuss EC2 events in the next two sections.</li>\n  <li>The NTH, a pod running in the Kubernetes cluster itself, constantly polls that SQS queue.</li>\n  <li>When a scale-in event pertaining to a worker node of the Kubernetes cluster is read from the SQS queue, the NTH sends to the Kubernetes API the instruction to <a href=\"https://kubernetes.io/docs/concepts/architecture/nodes/#manual-node-administration\">cordon</a> and <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/safely-drain-node/\">drain</a> the impacted worker node.</li>\n  <li>On draining, Kubernetes sends a SIGTERM signal to the Kafka pod residing on the worker node.</li>\n  <li>Upon receiving the SIGTERM signal, the Kafka pod gracefully migrates the leadership of its leader partitions to other brokers of the cluster before shutting down, in a transparent manner for the clients. This behaviour is ensured by the <a href=\"https://kafka.apache.org/documentation/#basic_ops_restarting\"><code class=\"language-plaintext highlighter-rouge\">controlled.shutdown.enable</code></a> parameter of Kafka, which is enabled by default.</li>\n  <li>Once the impacted worker node has been drained, the NTH eventually resumes the termination of the instance.</li>\n</ol>\n\n<p>Strimzi also comes with a <code class=\"language-plaintext highlighter-rouge\">terminationGracePeriodSeconds</code> parameter, which we have set to 180 seconds to give the Kafka pods enough time to migrate all of their partition leaders gracefully on termination. We have verified that this is enough to migrate all partition leaders on our Kafka clusters (about 60 seconds for 600 partition leaders).</p>\n\n<h4 id=\"manual-termination-of-an-instance\">Manual termination of an instance</h4>\n\n<p>The Auto Scaling lifecycle hook that pauses the termination of an instance (Fig. 3, step 1) as well as the corresponding resuming by the NTH (Fig. 3, step 7) are invoked only for ASG scaling events.</p>\n\n<p>In case of a manual termination of an EC2 instance, the termination is captured as an EC2 event that also reaches the NTH. Upon receiving that event, the NTH cordons and drains the impacted worker node. However, the instance is immediately terminated, most likely before the leadership of all of its Kafka partition leaders has had the time to get migrated to other brokers.</p>\n\n<p>To work around this and let a manual termination of an EC2 instance also benefit from the ASG lifecycle hook, the instance must be terminated using the <a href=\"https://docs.aws.amazon.com/cli/latest/reference/autoscaling/terminate-instance-in-auto-scaling-group.html\"><code class=\"language-plaintext highlighter-rouge\">terminate-instance-in-auto-scaling-group</code></a> AWS CLI command.</p>\n\n<h4 id=\"aws-maintenance-events\">AWS maintenance events</h4>\n\n<p>For AWS maintenance events such as instances scheduled for upcoming retirement, the NTH acts immediately when the event is first received (typically adequately in advance). It cordons and drains the soon-to-be-retired worker node, which in turn triggers the SIGTERM signal and the graceful termination of Kafka as described above. At this stage, the impacted instance is not terminated, so the Kafka partition leaders have plenty of time to complete their migration to other brokers.</p>\n\n<p>However, the evicted Kafka pod has nowhere to go. There is a need for spinning up a new worker node for it to be able to eventually restart somewhere.</p>\n\n<p>To make this happen seamlessly, we doubled the maximum size of each of our ASGs and installed the <a href=\"https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/aws/README.md\">Kubernetes Cluster Autoscaler</a>. With that, when such a maintenance event is received:</p>\n\n<ul>\n  <li>The worker node scheduled for retirement is cordoned and drained by the NTH. The state of the impacted Kafka pod becomes <em>Pending</em>.</li>\n  <li>The Kubernetes Cluster Autoscaler comes into play and triggers the corresponding ASG to spin up a new EC2 instance that joins the Kubernetes cluster as a new worker node.</li>\n  <li>The impacted Kafka pod restarts on the new worker node.</li>\n  <li>The Kubernetes Cluster Autoscaler detects that the previous worker node is now under-utilised and terminates it.</li>\n</ul>\n\n<p>In this scenario, the impacted Kafka pod only remains in <em>Pending</em> state for about four minutes in total.</p>\n\n<p>In case of multiple simultaneous AWS maintenance events, the Kubernetes scheduler would honour our <a href=\"https://kubernetes.io/docs/tasks/run-application/configure-pdb/\">PodDisruptionBudget</a> and not evict more than one Kafka pod at a time.</p>\n\n<h3 id=\"dynamic-nlb-configuration\">Dynamic NLB configuration</h3>\n\n<p>To automatically map the NLB\u2019s target groups with a newly spun up EC2 instance, we leveraged the <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/aws-load-balancer-controller.html\">AWS Load Balancer Controller</a> (LBC).</p>\n\n<p>Let us see how it works.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image6.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 4 Architecture of the LBC managing the NLB's target groups via TargetGroupBinding custom resources.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 4 shows how the LBC automates the reconfiguration of the NLB\u2019s target groups:</p>\n\n<ol>\n  <li>It first retrieves the desired state described in Kubernetes <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\">custom resources</a> (CR) of type <a href=\"https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/guide/targetgroupbinding/targetgroupbinding\">TargetGroupBinding</a>. There is one such resource per target group to maintain. Each TargetGroupBinding CR associates its respective target group with a Kubernetes service.</li>\n  <li>The LBC then watches over the changes of the Kubernetes services that are referenced in the TargetGroupBinding CRs\u2019 definition, specifically the private IP addresses exposed by their respective <a href=\"https://kubernetes.io/docs/concepts/services-networking/service/#endpoints\">Endpoints resources</a>.</li>\n  <li>When a change is detected, it dynamically updates the corresponding NLB\u2019s target groups with those IP addresses as well as the TCP port of the target containers (<code class=\"language-plaintext highlighter-rouge\">containerPort</code>).</li>\n</ol>\n\n<p>This automated design sets up the NLB\u2019s target groups with IP addresses (<code class=\"language-plaintext highlighter-rouge\">targetType: ip</code>) instead of EC2 instance IDs (<code class=\"language-plaintext highlighter-rouge\">targetType: instance</code>). Although the LBC can handle both target types, the IP address approach is actually more straightforward in our case, since each pod has a routable private IP address in the AWS subnet, thanks to the <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/managing-vpc-cni.html\">AWS Container Networking Interface</a> (CNI) plug-in.</p>\n\n<p>This dynamic NLB configuration design comes with a challenge. Whenever we need to update the Strimzi CR, the rollout of the change to each Kafka pod in a rolling update fashion is happening too fast for the NLB. This is because the NLB inherently takes some time to mark each target as healthy before enabling it. The Kafka brokers that have just been rolled out start advertising their broker-specific endpoints to the Kafka clients via the bootstrap service, but those \nendpoints are actually not immediately available because the NLB is still checking their health. To mitigate this, we have reduced the <code class=\"language-plaintext highlighter-rouge\">HealthCheckIntervalSeconds</code> and <code class=\"language-plaintext highlighter-rouge\">HealthyThresholdCount</code> parameters of each target group to their minimum values of 5 and 2 respectively. This reduces the maximum delay for the NLB to detect that a target has become healthy to 10 seconds. In addition, we have configured the LBC with a <a href=\"https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/deploy/pod_readiness_gate/\">Pod Readiness Gate</a>. This feature makes the Strimzi rolling deployment wait for the health check of the NLB to pass, before marking the current pod as <em>Ready</em> and proceeding with the next pod.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image7.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 5 Steps for a Strimzi rolling deployment with a Pod Readiness Gate. Only one Kafka broker and one NLB listener and target group are shown for simplicity.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 5 shows how the Pod Readiness Gate works during a Strimzi rolling deployment:</p>\n\n<ol>\n  <li>The old Kafka pod is terminated.</li>\n  <li>The new Kafka pod starts up and joins the Kafka cluster. Its individual endpoint for direct access via the NLB is immediately advertised by the Kafka cluster. However, at this stage, it is not reachable, as the target group of the NLB still points to the IP address of the old Kafka pod.</li>\n  <li>The LBC updates the target group of the NLB with the IP address of the new Kafka pod, but the NLB health check has not yet passed, so the traffic is not forwarded to the new Kafka pod just yet.</li>\n  <li>The LBC then waits for the NLB health check to pass, which takes 10 seconds. Once the NLB health check has passed, the NLB resumes forwarding the traffic to the Kafka pod.</li>\n  <li>Finally, the LBC updates the pod readiness gate of the new Kafka pod. This informs Strimzi that it can proceed with the next pod of the rolling deployment.</li>\n</ol>\n\n<h3 id=\"data-persistence-with-ebs\">Data persistence with EBS</h3>\n\n<p>To address the challenge of the residual PV and PVC of the old worker node preventing Kubernetes from mounting the local storage of the new worker node after a node rotation, we adopted <a href=\"https://aws.amazon.com/ebs/\">Elastic Block Store</a> (EBS) volumes instead of NVMe instance store volumes. Contrary to the latter, EBS volumes can conveniently be attached and detached. The trade-off is that their performance is significantly lower.</p>\n\n<p>However, relying on EBS comes with additional benefits:</p>\n\n<ul>\n  <li>The cost per GB is lower, compared to NVMe instance store volumes.</li>\n  <li>Using EBS decouples the size of an instance in terms of CPU and memory from its storage capacity, leading to further cost savings by independently right-sizing the instance type and its storage. Such a separation of concerns also opens the door to new use cases requiring disproportionate amounts of storage.</li>\n  <li>After a worker node rotation, the time needed for the new node to get back in sync is faster, as it only needs to catch up the data that was produced during the downtime. This leads to shorter maintenance operations and higher iteration speed. Incidentally, the associated inter-AZ traffic cost is also lower, since there is less data to transfer among brokers during this time.</li>\n  <li>Increasing the storage capacity is an online operation.</li>\n  <li>Data backup is supported by taking snapshots of EBS volumes.</li>\n</ul>\n\n<p>We have verified with our historical monitoring data that the performance of <a href=\"https://aws.amazon.com/ebs/general-purpose/\">EBS General Purpose 3</a> (gp3) volumes is significantly above our maximum historical values for both throughput and I/O per second (IOPS), and we have successfully benchmarked a test EBS-based Kafka cluster. We have also set up new monitors to be alerted in case we need to \nprovision either additional throughput or IOPS, beyond the baseline of EBS gp3 volumes.</p>\n\n<p>With that, we updated our instance types from storage optimised instances to either general purpose or memory optimised instances. We added the <a href=\"https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html\">Amazon EBS Container Storage Interface (CSI) driver</a> to the Kubernetes cluster and created a new Kubernetes <a href=\"https://kubernetes.io/docs/concepts/storage/storage-classes/\">storage class</a> to let the cluster dynamically provision EBS gp3 volumes.</p>\n\n<p>We configured Strimzi to use that storage class to create any new PVCs. This makes Strimzi able to automatically create the EBS volumes it needs, typically when the cluster is first set up, but also to attach/detach the volumes to/from the EC2 instances whenever a Kafka pod is relocated to a different worker node.</p>\n\n<p>Note that the EBS volumes are not part of any ASG <a href=\"https://docs.aws.amazon.com/autoscaling/ec2/userguide/launch-templates.html\">Launch Template</a>, nor do they scale automatically with the ASGs.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image3.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 6 Steps for the Strimzi Operator to create an EBS volume and attach it to a new Kafka pod.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 6 illustrates how this works when Strimzi sets up a new Kafka broker, for example the first broker of the cluster in the initial setup:</p>\n\n<ol>\n  <li>The <a href=\"https://strimzi.io/docs/operators/latest/overview#overview-components-cluster-operator-str\">Strimzi Cluster Operator</a> first creates a new PVC, specifying a volume size and EBS gp3 as its storage class. The storage class is configured with the EBS CSI Driver as the volume provisioner, so that volumes are dynamically provisioned <a href=\"https://engineering.grab.com/feed.xml#1\">[1]</a>. However, because it is also set up with <code class=\"language-plaintext highlighter-rouge\">volumeBindingMode: WaitForFirstConsumer</code>, the volume is not yet provisioned until a pod actually claims the PVC.</li>\n  <li>The Strimzi Cluster Operator then creates the Kafka pod, with a reference to the newly created PVC. The pod is scheduled to start, which in turn claims the PVC.</li>\n  <li>This triggers the EBS CSI Controller. As the volume provisioner, it dynamically creates a new EBS volume in the AWS VPC, in the AZ of the worker node where the pod has been scheduled to start.</li>\n  <li>It then attaches the newly created EBS volume to the corresponding EC2 instance.</li>\n  <li>After that, it creates a Kubernetes PV with <a href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#node-affinity\">nodeAffinity</a> and <a href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume\">claimRef</a> specifications, making sure that the PV is reserved for the Kafka broker 1 pod.</li>\n  <li>Lastly, it updates the PVC with the reference of the newly created PV. The PVC is now in <em>Bound</em> state and the Kafka pod can start.</li>\n</ol>\n\n<p>One important point to take note of is that EBS volumes can only be attached to EC2 instances residing in their own AZ. Therefore, when rotating a worker node, the EBS volume can only be re-attached to the new instance if both old and new instances reside in the same AZ. A simple way to guarantee this is to set up one ASG per AZ, instead of a single ASG spanning across 3 AZs.</p>\n\n<p>Also, when such a rotation occurs, the new broker only needs to synchronise the recent data produced during the brief downtime, which is typically an order of magnitude faster than replicating the entire volume (depending on the overall retention period of the hosted Kafka topics).</p>\n\n<table class=\"table\">\n<caption style=\"text-align: center;\">Table 1 Comparison of the resynchronization of the Kafka data after a broker rotation between the initial design and the new design with EBS volumes.</caption>\n<thead>\n  <tr>\n    <th></th>\n    <th>Initial design (NVMe instance store volumes)</th>\n    <th>New design (EBS volumes)</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Data to synchronise</td>\n    <td>All of the data</td>\n    <td>Recent data produced during the brief downtime</td>\n  </tr>\n  <tr>\n    <td>Function of (primarily)</td>\n    <td>Retention period</td>\n    <td>Downtime</td>\n  </tr>\n  <tr>\n    <td>Typical duration</td>\n    <td>Hours</td>\n    <td>Minutes</td>\n  </tr>\n</tbody>\n</table>\n\n<h2 id=\"outcome\">Outcome</h2>\n\n<p>With all that, let us revisit the initial scenario, where a malfunctioning worker node is being replaced by a fresh new node.</p>\n\n<div class=\"post-image-section\"><figure>\n  <img alt=\"\" src=\"https://engineering.grab.com/img/kafka-on-kubernetes/image1.png\" style=\"width: 80%;\" /><figcaption align=\"middle\">Fig. 7 Representation of a worker node termination after implementing the solution. Node C is terminated and replaced by node D. This time, the Kafka broker 3 pod is able to start and serve traffic.</figcaption>\n  </figure>\n</div>\n\n<p>Fig. 7 shows the worker node C being terminated and replaced (by the ASG) by a new worker node D, similar to what we have described in the initial problem statement. The worker node D automatically joins the Kubernetes cluster on start-up.</p>\n\n<p>However, this time, a seamless failover takes place:</p>\n\n<ol>\n  <li>The Kafka clients that were in the middle of producing or consuming to/from the partition leaders of Kafka broker 3 are gracefully redirected to Kafka brokers 1 and 2, where Kafka has migrated the leadership of its leader partitions.</li>\n  <li>The target groups of the NLB for both the bootstrap connection and Kafka broker 3 are automatically updated by the LBC. The connectivity between the NLB and Kafka broker 3 is immediately restored.</li>\n  <li>Triggered by the creation of the Kafka broker 3 pod, the Amazon EBS CSI driver running on the worker node D re-attaches the EBS volume 3 that was previously attached to the worker node C, to the worker node D instead. This enables Kubernetes to automatically re-bind the corresponding PV and PVC to Kafka broker 3 pod. With its storage dependency resolved, Kafka broker 3 is able to start successfully and re-join the Kafka cluster. From there, it only needs to catch up with the new data that was produced \nduring its short downtime, by replicating it from Kafka brokers 1 and 2.</li>\n</ol>\n\n<p>With this fault-tolerant design, when an EC2 instance is being retired by AWS, no particular action is required from our end.</p>\n\n<p>Similarly, our EKS version upgrades, as well as any operations that require rotating all worker nodes of the cluster in general, are:</p>\n\n<ul>\n  <li><strong>Simpler and less error-prone</strong>: We only need to rotate each instance in sequence, with no need for manually reconfiguring the target groups of the NLB and deleting the zombie PVCs anymore.</li>\n  <li><strong>Faster</strong>: The time between each instance rotation is limited to the short amount of time it takes for the restarted Kafka broker to catch up with the new data.</li>\n  <li><strong>More cost-efficient</strong>: There is less data to transfer across AZs (which is charged by AWS).</li>\n</ul>\n\n<p>It is worth noting that we have chosen to omit Zookeeper and Cruise Control in this article, for the sake of clarity and simplicity. In reality, all pods in the Kubernetes cluster - including Zookeeper and Cruise Control - now benefit from the same graceful stop, triggered by the AWS termination events and the NTH. Similarly, the EBS CSI driver improves the fault tolerance of any pods that use EBS volumes for persistent storage, which includes the Zookeeper pods.</p>\n\n<h2 id=\"challenges-faced\">Challenges faced</h2>\n\n<p>One challenge that we are facing with this design lies in the EBS volumes\u2019 management.</p>\n\n<p>On the one hand, the size of EBS volumes cannot be increased consecutively before the end of a cooldown period (minimum of 6 hours and can exceed 24 hours in some cases <a href=\"https://engineering.grab.com/feed.xml#2\">[2]</a>). Therefore, when we need to urgently extend some EBS volumes because the size of a Kafka topic is suddenly growing, we need to be relatively generous when sizing the new required capacity and add a comfortable security margin, to make sure that we are not running out of storage in the short run.</p>\n\n<p>On the other hand, shrinking a Kubernetes PV is not a supported operation. This can affect the cost efficiency of our design if we overprovision the storage capacity by too much, or in case the workload of a particular cluster organically diminishes.</p>\n\n<p>One way to mitigate this challenge is to tactically scale the cluster horizontally (ie. adding new brokers) when there is a need for more storage and the existing EBS volumes are stuck in a cooldown period, or when the new storage need is only temporary.</p>\n\n<h2 id=\"whats-next\">What\u2019s next?</h2>\n\n<p>In the future, we can improve the NTH\u2019s capability by utilising webhooks. Upon receiving events from SQS, the NTH can also forward the events to the specified webhook URLs.</p>\n\n<p>This can potentially benefit us in a few ways, e.g.:</p>\n\n<ul>\n  <li>Proactively spinning up a new instance without waiting for the old one to be terminated, whenever a termination event is received. This would shorten the rotation time even further.</li>\n  <li>Sending Slack notifications to Coban engineers to keep them informed of any actions taken by the NTH.</li>\n</ul>\n\n<p>We would need to develop and maintain an application that receives webhook events from the NTH and performs the necessary actions.</p>\n\n<p>In addition, we are also rolling out <a href=\"https://karpenter.sh/\">Karpenter</a> to replace the Kubernetes Cluster Autoscaler, as it is able to spin up new instances slightly faster, helping reduce the four minutes delay a Kafka pod remains in <em>Pending</em> state during a node rotation. Incidentally, Karpenter also removes the need for setting up one ASG by AZ, as it is able to deterministically provision instances in a specific AZ, for example where a particular EBS volume resides.</p>\n\n<p>Lastly, to ensure that the performance of our EBS gp3 volumes is both sufficient and cost-efficient, we want to explore autoscaling their throughput and IOPS beyond the baseline, based on the usage metrics collected by our monitoring stack.</p>\n\n<h2 id=\"references\">References</h2>\n\n<p><a href=\"https://engineering.grab.com/feed.xml#1\" name=\"1\">[1]</a> <a href=\"https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/\">Dynamic Volume Provisioning | Kubernetes</a></p>\n\n<p><a href=\"https://engineering.grab.com/feed.xml#2\" name=\"2\">[2]</a> <a href=\"https://repost.aws/knowledge-center/ebs-volume-stuck-optimizing-on-modification\">Troubleshoot EBS volume stuck in Optimizing state during modification | AWS re:Post</a></p>\n\n<p><small class=\"credits\">We would like to thank our team members and Grab Kubernetes gurus that helped review and improve this blog before publication: Will Ho, Gable Heng, Dewin Goh, Vinnson Lee, Siddharth Pandey, Shi Kai Ng, Quang Minh Tran, Yong Liang Oh, Leon Tay, Tuan Anh Vu. </small></p>\n\n<h1 id=\"join-us\">Join us</h1>\n\n<p>Grab is the leading superapp platform in Southeast Asia, providing everyday services that matter to consumers. More than just a ride-hailing and food delivery app, Grab offers a wide range of on-demand services in the region, including mobility, food, package and grocery delivery services, mobile payments, and financial services across 428 cities in eight countries.</p>\n\n<p>Powered by technology and driven by heart, our mission is to drive Southeast Asia forward by creating economic empowerment for everyone. If this mission speaks to you, <a href=\"https://grab.careers/\">join our team</a> today!</p>"
    },
    "published": "Tue, 26 Dec 2023 00:10:10 +0000",
    "published_parsed": [
      2023,
      12,
      26,
      0,
      10,
      10,
      1,
      360,
      0
    ],
    "links": [
      {
        "rel": "alternate",
        "type": "text/html",
        "href": "https://engineering.grab.com/kafka-on-kubernetes"
      }
    ],
    "link": "https://engineering.grab.com/kafka-on-kubernetes",
    "id": "https://engineering.grab.com/kafka-on-kubernetes",
    "guidislink": false,
    "tags": [
      {
        "term": "Kafka",
        "scheme": null,
        "label": null
      },
      {
        "term": "Kubernetes",
        "scheme": null,
        "label": null
      },
      {
        "term": "AWS",
        "scheme": null,
        "label": null
      },
      {
        "term": "Data Streaming",
        "scheme": null,
        "label": null
      },
      {
        "term": "Engineering",
        "scheme": null,
        "label": null
      },
      {
        "term": "Data Science",
        "scheme": null,
        "label": null
      }
    ]
  }
}