{
  "company": "Google Online Security",
  "title": "Google Online Security",
  "xmlUrl": "https://security.googleblog.com/feeds/posts/default",
  "htmlUrl": "https://security.googleblog.com/",
  "content": "\n\n\n\n\nGoogle Online Security Blog: Hardening cellular basebands in Android\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Security Blog\n          \n\n\n\nThe latest news and insights from Google on security and safety on the Internet\n\n\n\n\n\n\n\n\n\n\n\n\n\nHardening cellular basebands in Android\n\n\n\n\n\nDecember 12, 2023\n\n\n\n\n\n\n\nPosted by Ivan Lozano and Roger Piqueras Jover\n\nAndroid\u2019s defense-in-depth strategy applies not only to the Android OS running on the Application Processor (AP) but also the firmware that runs on devices. We particularly prioritize hardening the cellular baseband given its unique combination of running in an elevated privilege and parsing untrusted inputs that are remotely delivered into the device.\n\n\nThis post covers how to use two high-value sanitizers which can prevent specific classes of vulnerabilities found within the baseband. They are architecture agnostic, suitable for bare-metal deployment, and should be enabled in existing C/C++ code bases to mitigate unknown vulnerabilities. Beyond security, addressing the issues uncovered by these sanitizers improves code health and overall stability, reducing resources spent addressing bugs in the future.\n\nAn increasingly popular attack surface\n\nAs we outlined previously, security research focused on the baseband has highlighted a consistent lack of exploit mitigations in firmware. Baseband Remote Code Execution (RCE) exploits have their own categorization in well-known third-party marketplaces with a relatively low payout. This suggests baseband bugs may potentially be abundant and/or not too complex to find and exploit, and their prominent inclusion in the marketplace demonstrates that they are useful.\n\n\nBaseband security and exploitation has been a recurring theme in security conferences for the last decade. Researchers have also made a dent in this area in well-known exploitation contests. Most recently, this area has become prominent enough that it is  common to find practical baseband exploitation trainings in top security conferences.\n\n\nAcknowledging this trend, combined with the severity and apparent abundance of these vulnerabilities, last year we introduced updates to the severity guidelines of Android\u2019s Vulnerability Rewards Program (VRP). For example, we consider vulnerabilities allowing Remote Code Execution (RCE) in the cellular baseband to be of CRITICAL severity.\n\nMitigating Vulnerability Root Causes with Sanitizers\n\nCommon classes of vulnerabilities can be mitigated through the use of sanitizers provided by Clang-based toolchains. These sanitizers insert runtime checks against common classes of vulnerabilities. GCC-based toolchains may also provide some level of support for these flags as well, but will not be considered further in this post. We encourage you to check your toolchain\u2019s documentation.\n\n\nTwo sanitizers included in Undefined Behavior Sanitizer (UBSan) will be our focus \u2013 Integer Overflow Sanitizer (IntSan) and BoundsSanitizer (BoundSan). These have been widely deployed in Android userspace for years following a data-driven approach. These two are well suited for bare-metal environments such as the baseband since they do not require support from the OS or specific architecture features, and so are generally supported for all Clang targets.\n\nInteger Overflow Sanitizer (IntSan)\n\nIntSan causes signed and unsigned integer overflows to abort execution unless the overflow is made explicit. While unsigned integer overflows are technically defined behavior, it can often lead to unintentional behavior and vulnerabilities \u2013 especially when they\u2019re used to index into arrays.\n\n\nAs both intentional and unintentional overflows are likely present in most code bases, IntSan may require refactoring and annotating the code base to prevent intentional or benign overflows from trapping (which we consider a false positive for our purposes). Overflows which need to be addressed can be uncovered via testing (see the Deploying Sanitizers section)\n\nBoundsSanitizer (BoundSan)\n\nBoundSan inserts instrumentation to perform bounds checks around some array accesses. These checks are only added if the compiler cannot prove at compile time that the access will be safe and if the size of the array will be known at runtime, so that it can be checked against. Note that this will not cover all array accesses as the size of the array may not be known at runtime, such as function arguments which are arrays.\n\n\nAs long as the code is correctly written C/C++, BoundSan should produce no false positives. Any violations discovered when first enabling BoundSan is at least a bug, if not a vulnerability. Resolving even those which aren\u2019t exploitable can greatly improve stability and code quality.\n\nModernize your toolchains\n\nAdopting modern mitigations also means adopting (and maintaining) modern toolchains. The benefits of this go beyond utilizing sanitizers however. Maintaining an old toolchain is not free and entails hidden opportunity costs. Toolchains contain bugs which are addressed in subsequent releases. Newer toolchains bring new performance optimizations, valuable in the highly constrained bare-metal environment that basebands operate in. Security issues can even exist in the generated code of out-of-date compilers.\n\n\nMaintaining a modern up-to-date toolchain for the baseband entails some costs in terms of maintenance, especially at first if the toolchain is particularly old, but over time the benefits, as outlined above, outweigh the costs.\n\nWhere to apply sanitizers\n\nBoth BoundSan and IntSan have a measurable performance overhead. Although we were able to significantly reduce this overhead in the past (for example to less than 1% in media codecs), even very small increases in CPU load can have a substantial impact in some environments.\n\n\nEnabling sanitizers over the entire codebase provides the most benefit, but enabling them in security-critical attack surfaces can serve as a first step in an incremental deployment. For example:\n\n\nFunctions parsing messages delivered over the air in 2G, 3G, 4G, and 5G (especially functions handling pre-authentication messages that can be injected with a false/malicious base station)\n\nLibraries encoding/decoding complex formats (e.g. ASN.1, XML, DNS, etc\u2026)\n\nIMS, TCP and IP stacks\n\nMessaging functions (SMS, MMS)\n\n\n\nIn the particular case of 2G, the best strategy is to disable the stack altogether by supporting Android\u2019s \u201c2G toggle\u201d. However, 2G is still a necessary mobile access technology in certain parts of the world and some users might need to have this legacy protocol enabled.\n\nDeploying Sanitizers\n\nHaving a clear plan for deployment of sanitizers saves a lot of time and effort. We think of the deployment process as having three stages:\n\n\nDetecting (and fixing) violations\n\nMeasuring and reducing overhead\n\nSoaking in pre-production\n\n\n\nWe also introduce two modes in which sanitizers should be run: diagnostics mode and trapping mode. These will be discussed in the following sections, but briefly: diagnostics mode recovers from violations and provides valuable debug information, while trapping mode actively mitigates vulnerabilities by trapping execution on violations.\n\nDetecting (and Fixing) Violations\n\nTo successfully ship these sanitizers, any benign integer overflows must be made explicit and accidental out-of-bounds accesses must be addressed. These will have to be uncovered through testing. The higher the code coverage your tests provide, the more issues you can uncover at this stage and the easier deployment will be later on.\n\n\nTo diagnose violations uncovered in testing, sanitizers can emit calls to runtime handlers with debug information such as the file, line number, and values leading to the violation. Sanitizers can optionally continue execution after a violation has occurred, allowing multiple violations to be discovered in a single test run. We refer to using the sanitizers in this way as running them in \u201cdiagnostics mode\u201d. Diagnostics mode is not intended for production as it provides no security benefits and adds high overhead.\n\n\nDiagnostics mode for the sanitizers can be set using the following flags:\n\n-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-recover=all\n\nSince Clang does not provide a UBSan runtime for bare-metal targets, a runtime will need to be defined and provided at link time:\n\n// integer overflow handlers\n__ubsan_handle_add_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_sub_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_mul_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_divrem_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_negate_overflow(OverflowData *data, ValueHandle old_val)\n// boundsan handler\n__ubsan_handle_out_of_bounds_overflow(OverflowData *data, ValueHandle old_val)\n\nAs an example, see the default Clang implementation; the Linux Kernels implementation may also be illustrative.\n\n\nWith the runtime defined, enable the sanitizer over the entire baseband codebase and run all available tests to uncover and address any violations. Vulnerabilities should be patched, and overflows should either be refactored or made explicit through the use of checked arithmetic builtins which do not trigger sanitizer violations. Certain functions which are expected to have intentional overflows (such as cryptographic functions) can be preemptively excluded from sanitization (see next section).\n\n\nAside from uncovering security vulnerabilities, this stage is highly effective at uncovering code quality and stability bugs that could result in instability on user devices.\n\n\nOnce violations have been addressed and tests are no longer uncovering new violations, the next stage can begin.\n\nMeasuring and Reducing Overhead\n\nOnce shallow violations have been addressed, benchmarks can be run and the overhead from the sanitizers (performance, code size, memory footprint) can be measured.\n\n\nMeasuring overhead must be done using production flags \u2013 namely \u201ctrapping mode\u201d, where violations cause execution to abort. The diagnostics runtime used in the first stage carries significant overhead and is not indicative of the actual performance sanitizer overhead.\n\n\nTrapping mode can be enabled using the following flags:\n\n-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-trap=all\n\nMost of the overhead is likely due to a small handful of \u201chot functions\u201d, for example those with tight long-running loops. Fine-grained per-function performance metrics (similar to what Simpleperf provides for Android), allows comparing metrics before and after sanitizers and provides the easiest means to identify hot functions. These functions can either be refactored or, after manual inspection to verify that they are safe, have sanitization disabled.\n\n\nSanitizers can be disabled either inline in the source or through the use of ignorelists and the -fsanitize-ignorelist flag.\n\n\nThe physical layer code, with its extremely tight performance margins and lower chance of exploitable vulnerabilities, may be a good candidate to disable sanitization wholesale if initial performance seems prohibitive.\n\nSoaking in Pre-production\n\nWith overhead minimized and shallow bugs resolved, the final stage is enabling the sanitizers in trapping mode to mitigate vulnerabilities.\n\n\nWe strongly recommend a long period of internal soak in pre-production with test populations to uncover any remaining violations not discovered in testing. The more thorough the test coverage and length of the soak period, the less risk there will be from undiscovered violations.\n\n\nAs above, the configuration for trapping mode is as follows:\n\n-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-trap=all\n\nHaving infrastructure in place to collect bug reports which result from any undiscovered violations can help minimize the risk they present.\n\nTransitioning to Memory Safe Languages\n\nThe benefits from deploying sanitizers in your existing code base are tangible, however ultimately they address only the lowest hanging fruit and will not result in a code base free of vulnerabilities. Other classes of memory safety vulnerabilities remain unaddressed by these sanitizers. A longer term solution is to begin transitioning today to memory-safe languages such as Rust.\n\n\nRust is ready for bare-metal environments such as the baseband, and we are already using it in other bare-metal components in Android. There is no need to rewrite everything in Rust, as Rust provides a strong C FFI support and easily interfaces with existing C codebases. Just writing new code in Rust can rapidly reduce the number of memory safety vulnerabilities. Rewrites should be limited/prioritized only for the most critical components, such as complex parsers handling untrusted data.\n\n\nThe Android team has developed a Rust training meant to help experienced developers quickly ramp up Rust fundamentals. An entire day for bare-metal Rust is included, and the course has been translated to a number of different languages.\n\n\nWhile the Rust compiler may not explicitly support your bare-metal target, because it is a front-end for LLVM, any target supported by LLVM can be supported in Rust through custom target definitions.\n\nRaising the Bar\n\nAs the high-level operating system becomes a more difficult target for attackers to successfully exploit, we expect that lower level components such as the baseband will attract more attention. By using modern toolchains and deploying exploit mitigation technologies, the bar for attacking the baseband can be raised as well. If you have any questions, let us know \u2013 we\u2019re here to help!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                        Google\n                      \n\n\nLabels:\n\n\n\nandroid\n\n\n                                ,\n                              \n\nandroid security\n\n\n\n\n\n\n\nNo comments\n                      :\n                    \n\n\n\n\n\n\nPost a Comment\n\n\n\n\n\n\n\n\n\n\n\n                      \ue88a\n                    \n\n\n\n\n                          \ue5c4\n                        \n\n\n\n\n\n                          \ue5c8\n                        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLabels\n\n\n                      \ue5c5\n                    \n\n\n\n\n\n#sharethemicincyber\n\n\n\n\n#supplychain #security #opensource\n\n\n\n\nandroid\n\n\n\n\nandroid security\n\n\n\n\nandroid tr\n\n\n\n\napp security\n\n\n\n\nbig data\n\n\n\n\nbiometrics\n\n\n\n\nblackhat\n\n\n\n\nC++\n\n\n\n\nchrome\n\n\n\n\nchrome enterprise\n\n\n\n\nchrome security\n\n\n\n\nconnected devices\n\n\n\n\nCTF\n\n\n\n\ndiversity\n\n\n\n\nencryption\n\n\n\n\nfederated learning\n\n\n\n\nfuzzing\n\n\n\n\nGboard\n\n\n\n\ngoogle play\n\n\n\n\ngoogle play protect\n\n\n\n\nhacking\n\n\n\n\ninteroperability\n\n\n\n\niot security\n\n\n\n\nkubernetes\n\n\n\n\nlinux kernel\n\n\n\n\nmemory safety\n\n\n\n\nOpen Source\n\n\n\n\npha family highlights\n\n\n\n\npixel\n\n\n\n\nprivacy\n\n\n\n\nprivate compute core\n\n\n\n\nRowhammer\n\n\n\n\nrust\n\n\n\n\nSecurity\n\n\n\n\nsecurity rewards program\n\n\n\n\nsigstore\n\n\n\n\nspyware\n\n\n\n\nsupply chain\n\n\n\n\ntargeted spyware\n\n\n\n\ntensor\n\n\n\n\nTitan M2\n\n\n\n\nVDP\n\n\n\n\nvulnerabilities\n\n\n\n\nworkshop\n\n\n\n\n\n\n\n\n                      \ue2c7\n                    \n\nArchive\n\n\n                      \ue5c5\n                    \n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2024\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c7\n                      \n                      \u00a0\n                      \n\n\n\n2023\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2022\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2021\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2020\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2019\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2018\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2017\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2016\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2015\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2014\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2013\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2012\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\nJan\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2011\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2010\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nApr\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2009\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2008\n\n\n\n\n\n\n\nDec\n\n\n\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nAug\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\nFeb\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                    \ue5c5\n                  \n\n\n\n\n                        \ue5c5\n                      \n                      \u00a0\n                    \n\n\n\n2007\n\n\n\n\n\n\n\nNov\n\n\n\n\n\n\n\n\n\n\nOct\n\n\n\n\n\n\n\n\n\n\nSep\n\n\n\n\n\n\n\n\n\n\nJul\n\n\n\n\n\n\n\n\n\n\nJun\n\n\n\n\n\n\n\n\n\n\nMay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeed\n\n\n\n\n\n\n\n\n\n\n\nFollow @google\n\n\n\nFollow\n\n\n\n\n\nGive us feedback in our Product Forums.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n              Google\n            \n\n\n\n              Privacy\n            \n\n\n\n              Terms\n            \n\n\n\n\n\n\n\n\n\n",
  "latestPost": {
    "id": "tag:blogger.com,1999:blog-1176949257541686127.post-2267894734490098363",
    "guidislink": true,
    "link": "http://security.googleblog.com/2023/12/hardening-cellular-basebands-in-android.html",
    "published": "2023-12-12T12:00:00.000-05:00",
    "published_parsed": [
      2023,
      12,
      12,
      17,
      0,
      0,
      1,
      346,
      0
    ],
    "updated": "2023-12-12T12:00:09.520-05:00",
    "updated_parsed": [
      2023,
      12,
      12,
      17,
      0,
      9,
      1,
      346,
      0
    ],
    "tags": [
      {
        "term": "android",
        "scheme": "http://www.blogger.com/atom/ns#",
        "label": null
      },
      {
        "term": "android security",
        "scheme": "http://www.blogger.com/atom/ns#",
        "label": null
      }
    ],
    "title": "Hardening cellular basebands in Android",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "http://feeds.feedburner.com/GoogleOnlineSecurityBlog",
      "value": "Hardening cellular basebands in Android"
    },
    "content": [
      {
        "type": "text/html",
        "language": null,
        "base": "http://feeds.feedburner.com/GoogleOnlineSecurityBlog",
        "value": "<span class=\"byline-author\">Posted by Ivan Lozano and Roger Piqueras Jover</span>\n\n<p>\nAndroid\u2019s defense-in-depth strategy applies not only to the Android OS running on the Application Processor (AP) but also the firmware that runs on devices. We particularly <a href=\"https://security.googleblog.com/2023/02/hardening-firmware-across-android.html\">prioritize hardening the cellular baseband</a> given its unique combination of running in an elevated privilege and parsing untrusted inputs that are remotely delivered into the device.\n</p>\n<p>\nThis post covers how to use two high-value sanitizers which can prevent specific classes of vulnerabilities found within the baseband. They are architecture agnostic, suitable for bare-metal deployment, and should be enabled in existing C/C++ code bases to mitigate unknown vulnerabilities. Beyond security, addressing the issues uncovered by these sanitizers improves code health and overall stability, reducing resources spent addressing bugs in the future.\n</p>\n<h1>An increasingly popular attack surface</h1>\n\n\n<p>\nAs we <a href=\"https://security.googleblog.com/2023/02/hardening-firmware-across-android.html\">outlined previously</a>, security research focused on the baseband has highlighted a consistent lack of exploit mitigations in firmware. Baseband Remote Code Execution (RCE) exploits <a href=\"https://www.zerodium.com/images/zerodium_prices_mobiles.png\">have their own categorization</a> in well-known third-party marketplaces with a relatively low payout. This suggests baseband bugs may potentially be abundant and/or not too complex to find and exploit, and their prominent inclusion in the marketplace demonstrates that they are useful.\n</p>\n<p>\nBaseband security and exploitation has been a <a href=\"https://www.usenix.org/system/files/conference/woot12/woot12-final24.pdf\">recurring</a> <a href=\"https://www.blackhat.com/docs/us-14/materials/us-14-Lindh-Attacking-Mobile-Broadband-Modems-Like-A-Criminal-Would.pdf\">theme</a> in <a href=\"https://vimeo.com/showcase/4562410/video/214013463\">security</a> <a href=\"https://speakerdeck.com/marcograss/exploitation-of-a-modern-smartphone-baseband\">conferences</a> <a href=\"https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Over-The-Air-Baseband-Exploit-Gaining-Remote-Code-Execution-On-5G-Smartphones.pdf\">for the last decade</a>. Researchers have also made a dent in this area in <a href=\"https://www.forbes.com/sites/daveywinder/2019/11/10/samsung-galaxy-s10-hacked-twice/?sh=54b24bb25bd7\">well-known exploitation contests</a>. Most recently, this area has become prominent enough that it is  common to find practical baseband exploitation <a href=\"https://milano.securitybsides.it/baseband-exploitation.html\">trainings</a> in <a href=\"https://hardwear.io/usa-2023/training/reverse-engineering-emulation-dynamic-testing-cellular-baseband-firmware.php\">top</a> <a href=\"https://www.offensivecon.org/trainings/2023/baseband-exploitation.html\">security</a> <a href=\"https://www.hexacon.fr/trainer/ribeiro_burke/\">conferences</a>.\n</p>\n<p>\nAcknowledging this trend, combined with the severity and apparent abundance of these vulnerabilities, last year we introduced updates to the <a href=\"https://source.android.com/docs/security/overview/updates-resources#severity\">severity guidelines</a> of Android\u2019s Vulnerability Rewards Program (VRP). For example, we consider vulnerabilities allowing Remote Code Execution (RCE) in the cellular baseband to be of CRITICAL severity.\n</p>\n<h1>Mitigating Vulnerability Root Causes with Sanitizers</h1>\n\n\n<p>\nCommon classes of vulnerabilities can be mitigated through the use of sanitizers provided by <a href=\"https://clang.llvm.org/\">Clang-based toolchains</a>. These sanitizers insert runtime checks against common classes of vulnerabilities. GCC-based toolchains may also provide some level of support for these flags as well, but will not be considered further in this post. We encourage you to check your toolchain\u2019s documentation.\n</p>\n<p>\nTwo sanitizers included in <a href=\"https://source.android.com/docs/security/test/ubsan\">Undefined Behavior Sanitizer</a> (UBSan) will be our focus \u2013 <a href=\"https://source.android.com/docs/security/test/intsan\">Integer Overflow Sanitizer</a> (IntSan) and <a href=\"https://source.android.com/docs/security/test/bounds-sanitizer\">BoundsSanitizer</a> (BoundSan). These have been <a href=\"https://android-developers.googleblog.com/2016/05/hardening-media-stack.html\">widely deployed</a> in <a href=\"https://android-developers.googleblog.com/2018/06/compiler-based-security-mitigations-in.html\">Android userspace</a> <a href=\"https://android-developers.googleblog.com/2019/05/queue-hardening-enhancements.html\">for years</a> following <a href=\"https://security.googleblog.com/2021/01/data-driven-security-hardening-in.html\">a data-driven approach</a>. These two are well suited for bare-metal environments such as the baseband since they do not require support from the OS or specific architecture features, and so are generally supported for all Clang targets.\n</p>\n<h2>Integer Overflow Sanitizer (IntSan)</h2>\n\n\n<p>\nIntSan causes signed and unsigned integer overflows to abort execution unless the overflow is made explicit. While unsigned integer overflows are technically defined behavior, it can often lead to unintentional behavior and vulnerabilities \u2013 especially when they\u2019re used to index into arrays.\n</p>\n<p>\nAs both intentional and unintentional overflows are likely present in most code bases, IntSan may require refactoring and annotating the code base to prevent intentional or benign overflows from trapping (which we consider a false positive for our purposes). Overflows which need to be addressed can be uncovered via testing (see the Deploying Sanitizers section)\n</p>\n<h2>BoundsSanitizer (BoundSan)</h2>\n\n\n<p>\nBoundSan inserts instrumentation to perform bounds checks around some array accesses. These checks are only added if the compiler cannot prove at compile time that the access will be safe and if the size of the array will be known at runtime, so that it can be checked against. Note that this will not cover all array accesses as the size of the array may not be known at runtime, such as function arguments which are arrays.\n</p>\n<p>\nAs long as the code is correctly written C/C++, BoundSan should produce no false positives. Any violations discovered when first enabling BoundSan is at least a bug, if not a vulnerability. Resolving even those which aren\u2019t exploitable can greatly improve stability and code quality.\n</p>\n<h2>Modernize your toolchains</h2>\n\n\n<p>\nAdopting modern mitigations also means adopting (and maintaining) modern toolchains. The benefits of this go beyond utilizing sanitizers however. Maintaining an old toolchain is not free and entails hidden opportunity costs. Toolchains contain bugs which are addressed in <a href=\"https://releases.llvm.org/17.0.1/tools/clang/docs/ReleaseNotes.html#bug-fixes-in-this-version\">subsequent releases</a>. Newer toolchains bring new <a href=\"https://releases.llvm.org/17.0.1/tools/clang/docs/ReleaseNotes.html#bug-fixes-in-this-version:~:text=Improved%20code%20generation,MS%20C%2B%2B%20ABI.\">performance optimizations</a>, valuable in the highly constrained bare-metal environment that basebands operate in. <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-12886\">Security</a> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-4039\">issues</a> can even exist in the generated code of out-of-date compilers.\n</p>\n<p>\nMaintaining a modern up-to-date toolchain for the baseband entails some costs in terms of maintenance, especially at first if the toolchain is particularly old, but over time the benefits, as outlined above, outweigh the costs.\n</p>\n<h1>Where to apply sanitizers</h1>\n\n\n<p>\nBoth BoundSan and IntSan have a measurable performance overhead. Although we were able to significantly reduce this overhead in the past (<a href=\"https://security.googleblog.com/2019/05/queue-hardening-enhancements.html\">for example to less than 1% in media codecs</a>), even very small increases in CPU load can have a substantial impact in some environments.\n</p>\n<p>\nEnabling sanitizers over the entire codebase provides the most benefit, but enabling them in security-critical attack surfaces can serve as a first step in an incremental deployment. For example:\n</p>\n<ul>\n\n<li>Functions parsing messages delivered over the air in 2G, 3G, 4G, and 5G (especially functions handling pre-authentication messages that can be injected with a false/malicious base station)\n\n<li>Libraries encoding/decoding complex formats (e.g. ASN.1, XML, DNS, etc\u2026)\n\n<li>IMS, TCP and IP stacks\n\n<li>Messaging functions (SMS, MMS)\n</li>\n</ul>\n<p>\nIn the particular case of 2G, the best strategy is to disable the stack altogether by supporting Android\u2019s \u201c<a href=\"https://source.android.com/docs/setup/about/android-12-release#2g-toggle\">2G toggle</a>\u201d. However, 2G is still a necessary mobile access technology in certain parts of the world and some users might need to have this legacy protocol enabled.\n</p>\n<h1>Deploying Sanitizers</h1>\n\n\n<p>\nHaving a clear plan for deployment of sanitizers saves a lot of time and effort. We think of the deployment process as having three stages:\n</p>\n<ul>\n\n<li>Detecting (and fixing) violations\n\n<li>Measuring and reducing overhead\n\n<li>Soaking in pre-production\n</li>\n</ul>\n<p>\nWe also introduce two modes in which sanitizers should be run: <strong>diagnostics mode</strong> and <strong>trapping mode</strong>. These will be discussed in the following sections, but briefly: diagnostics mode recovers from violations and provides valuable debug information, while trapping mode actively mitigates vulnerabilities by trapping execution on violations.\n</p>\n<h2>Detecting (and Fixing) Violations</h2>\n\n\n<p>\nTo successfully ship these sanitizers, any benign integer overflows must be made explicit and accidental out-of-bounds accesses must be addressed. These will have to be uncovered through testing. The higher the code coverage your tests provide, the more issues you can uncover at this stage and the easier deployment will be later on.\n</p>\n<p>\nTo diagnose violations uncovered in testing, sanitizers can emit calls to runtime handlers with debug information such as the file, line number, and values leading to the violation. Sanitizers can optionally continue execution after a violation has occurred, allowing multiple violations to be discovered in a single test run. We refer to using the sanitizers in this way as running them in \u201c<strong>diagnostics mode</strong>\u201d. Diagnostics mode is not intended for production as it provides no security benefits and adds high overhead.\n</p>\n<p>\nDiagnostics mode for the sanitizers can be set using the following flags:\n</p>\n\n\n\n<pre class=\"prettyprint\">-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-recover=all</pre>\n\n\n<p>\nSince Clang does not provide a UBSan runtime for bare-metal targets, a runtime will need to be defined and provided at link time:\n</p>\n\n\n\n<pre class=\"prettyprint\">// integer overflow handlers\n__ubsan_handle_add_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_sub_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_mul_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_divrem_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_negate_overflow(OverflowData *data, ValueHandle old_val)\n// boundsan handler\n__ubsan_handle_out_of_bounds_overflow(OverflowData *data, ValueHandle old_val)</pre>\n\n\n<p>\nAs an example, see the <a href=\"https://cs.android.com/android-llvm/toolchain/llvm-project/+/master:compiler-rt/lib/ubsan/ubsan_handlers.cc\">default Clang implementation</a>; the Linux Kernels <a href=\"https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/lib/ubsan.c;l=335?\">implementation</a> may also be illustrative.\n</p>\n<p>\nWith the runtime defined, enable the sanitizer over the entire baseband codebase and run all available tests to uncover and address any violations. Vulnerabilities should be patched, and overflows should either be refactored or made explicit through the use of <a href=\"https://clang.llvm.org/docs/LanguageExtensions.html#checked-arithmetic-builtins\">checked arithmetic builtins</a> which do not trigger sanitizer violations. Certain functions which are expected to have intentional overflows (such as cryptographic functions) can be preemptively excluded from sanitization (see next section).\n</p>\n<p>\nAside from uncovering security vulnerabilities, this stage is highly effective at uncovering code quality and stability bugs that could result in instability on user devices.\n</p>\n<p>\nOnce violations have been addressed and tests are no longer uncovering new violations, the next stage can begin.\n</p>\n<h2>Measuring and Reducing Overhead</h2>\n\n\n<p>\nOnce shallow violations have been addressed, benchmarks can be run and the overhead from the sanitizers (performance, code size, memory footprint) can be measured.\n</p>\n<p>\nMeasuring overhead must be done using production flags \u2013 namely <strong>\u201ctrapping mode\u201d</strong>, where violations cause execution to abort. The diagnostics runtime used in the first stage carries significant overhead and is not indicative of the actual performance sanitizer overhead.\n</p>\n<p>\nTrapping mode can be enabled using the following flags:\n</p>\n\n\n\n<pre class=\"prettyprint\">-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-trap=all</pre>\n\n\n<p>\nMost of the overhead is likely due to a small handful of \u201chot functions\u201d, for example those with tight long-running loops. Fine-grained per-function performance metrics (similar to what <a href=\"https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md\">Simpleperf</a> provides for Android), allows comparing metrics before and after sanitizers and provides the easiest means to identify hot functions. These functions can either be refactored or, after manual inspection to verify that they are safe, have sanitization disabled.\n</p>\n<p>\nSanitizers can be disabled either <a href=\"https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#disabling-instrumentation-with-attribute-no-sanitize-undefined\">inline in the source</a> or through the use of <a href=\"https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#suppressing-errors-in-recompiled-code-ignorelist\">ignorelists</a> and the -fsanitize-ignorelist flag.\n</p>\n<p>\nThe physical layer code, with its extremely tight performance margins and lower chance of exploitable vulnerabilities, may be a good candidate to disable sanitization wholesale if initial performance seems prohibitive.\n</p>\n<h2>Soaking in Pre-production</h2>\n\n\n<p>\nWith overhead minimized and shallow bugs resolved, the final stage is enabling the sanitizers in trapping mode to mitigate vulnerabilities.\n</p>\n<p>\nWe strongly recommend a long period of internal soak in pre-production with test populations to uncover any remaining violations not discovered in testing. The more thorough the test coverage and length of the soak period, the less risk there will be from undiscovered violations.\n</p>\n<p>\nAs above, the configuration for trapping mode is as follows:\n</p>\n\n\n\n<pre class=\"prettyprint\">-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-trap=all</pre>\n\n\n<p>\nHaving infrastructure in place to collect bug reports which result from any undiscovered violations can help minimize the risk they present.\n</p>\n<h1>Transitioning to Memory Safe Languages</h1>\n\n\n<p>\nThe benefits from deploying sanitizers in your existing code base are tangible, however ultimately they address only the lowest hanging fruit and will not result in a code base free of vulnerabilities. Other classes of memory safety vulnerabilities remain unaddressed by these sanitizers. A longer term solution is to begin transitioning <em>today</em> to memory-safe languages such as Rust.\n</p>\n<p>\n<a href=\"https://security.googleblog.com/2023/10/bare-metal-rust-in-android.html\">Rust is ready for bare-metal environments</a> such as the baseband, and we are already using it in other bare-metal components in Android. There is no need to rewrite everything in Rust, as Rust provides a strong C FFI support and easily interfaces with existing C codebases. <a href=\"https://security.googleblog.com/2021/04/rust-in-android-platform.html#:~:text=But%20what%20about%20all%20that%20existing%20C%2B%2B%3F\">Just writing new code in Rust</a> can rapidly <a href=\"https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html\">reduce the number of memory safety vulnerabilities</a>. Rewrites should be limited/prioritized only for the most critical components, such as complex parsers handling untrusted data.\n</p>\n<p>\nThe Android team has developed a <a href=\"https://google.github.io/comprehensive-rust/\">Rust training</a> meant to help experienced developers quickly ramp up Rust fundamentals. An entire day for <a href=\"https://google.github.io/comprehensive-rust/bare-metal.html\">bare-metal Rust</a> is included, and the course has been translated to a number of different languages.\n</p>\n<p>\nWhile the Rust compiler may not explicitly support your bare-metal target, because it is a front-end for LLVM, any target supported by LLVM can be supported in Rust through <a href=\"https://docs.rust-embedded.org/embedonomicon/custom-target.html\">custom target definitions</a>.\n</p>\n<h1>Raising the Bar</h1>\n\n\n<p>\nAs the high-level operating system becomes a more difficult target for attackers to successfully exploit, we expect that lower level components such as the baseband will attract more attention. By using modern toolchains and deploying exploit mitigation technologies, the bar for attacking the baseband can be raised as well. If you have any questions, let us know \u2013 we\u2019re here to help!\n</p>"
      }
    ],
    "summary": "<span class=\"byline-author\">Posted by Ivan Lozano and Roger Piqueras Jover</span>\n\n<p>\nAndroid\u2019s defense-in-depth strategy applies not only to the Android OS running on the Application Processor (AP) but also the firmware that runs on devices. We particularly <a href=\"https://security.googleblog.com/2023/02/hardening-firmware-across-android.html\">prioritize hardening the cellular baseband</a> given its unique combination of running in an elevated privilege and parsing untrusted inputs that are remotely delivered into the device.\n</p>\n<p>\nThis post covers how to use two high-value sanitizers which can prevent specific classes of vulnerabilities found within the baseband. They are architecture agnostic, suitable for bare-metal deployment, and should be enabled in existing C/C++ code bases to mitigate unknown vulnerabilities. Beyond security, addressing the issues uncovered by these sanitizers improves code health and overall stability, reducing resources spent addressing bugs in the future.\n</p>\n<h1>An increasingly popular attack surface</h1>\n\n\n<p>\nAs we <a href=\"https://security.googleblog.com/2023/02/hardening-firmware-across-android.html\">outlined previously</a>, security research focused on the baseband has highlighted a consistent lack of exploit mitigations in firmware. Baseband Remote Code Execution (RCE) exploits <a href=\"https://www.zerodium.com/images/zerodium_prices_mobiles.png\">have their own categorization</a> in well-known third-party marketplaces with a relatively low payout. This suggests baseband bugs may potentially be abundant and/or not too complex to find and exploit, and their prominent inclusion in the marketplace demonstrates that they are useful.\n</p>\n<p>\nBaseband security and exploitation has been a <a href=\"https://www.usenix.org/system/files/conference/woot12/woot12-final24.pdf\">recurring</a> <a href=\"https://www.blackhat.com/docs/us-14/materials/us-14-Lindh-Attacking-Mobile-Broadband-Modems-Like-A-Criminal-Would.pdf\">theme</a> in <a href=\"https://vimeo.com/showcase/4562410/video/214013463\">security</a> <a href=\"https://speakerdeck.com/marcograss/exploitation-of-a-modern-smartphone-baseband\">conferences</a> <a href=\"https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Over-The-Air-Baseband-Exploit-Gaining-Remote-Code-Execution-On-5G-Smartphones.pdf\">for the last decade</a>. Researchers have also made a dent in this area in <a href=\"https://www.forbes.com/sites/daveywinder/2019/11/10/samsung-galaxy-s10-hacked-twice/?sh=54b24bb25bd7\">well-known exploitation contests</a>. Most recently, this area has become prominent enough that it is  common to find practical baseband exploitation <a href=\"https://milano.securitybsides.it/baseband-exploitation.html\">trainings</a> in <a href=\"https://hardwear.io/usa-2023/training/reverse-engineering-emulation-dynamic-testing-cellular-baseband-firmware.php\">top</a> <a href=\"https://www.offensivecon.org/trainings/2023/baseband-exploitation.html\">security</a> <a href=\"https://www.hexacon.fr/trainer/ribeiro_burke/\">conferences</a>.\n</p>\n<p>\nAcknowledging this trend, combined with the severity and apparent abundance of these vulnerabilities, last year we introduced updates to the <a href=\"https://source.android.com/docs/security/overview/updates-resources#severity\">severity guidelines</a> of Android\u2019s Vulnerability Rewards Program (VRP). For example, we consider vulnerabilities allowing Remote Code Execution (RCE) in the cellular baseband to be of CRITICAL severity.\n</p>\n<h1>Mitigating Vulnerability Root Causes with Sanitizers</h1>\n\n\n<p>\nCommon classes of vulnerabilities can be mitigated through the use of sanitizers provided by <a href=\"https://clang.llvm.org/\">Clang-based toolchains</a>. These sanitizers insert runtime checks against common classes of vulnerabilities. GCC-based toolchains may also provide some level of support for these flags as well, but will not be considered further in this post. We encourage you to check your toolchain\u2019s documentation.\n</p>\n<p>\nTwo sanitizers included in <a href=\"https://source.android.com/docs/security/test/ubsan\">Undefined Behavior Sanitizer</a> (UBSan) will be our focus \u2013 <a href=\"https://source.android.com/docs/security/test/intsan\">Integer Overflow Sanitizer</a> (IntSan) and <a href=\"https://source.android.com/docs/security/test/bounds-sanitizer\">BoundsSanitizer</a> (BoundSan). These have been <a href=\"https://android-developers.googleblog.com/2016/05/hardening-media-stack.html\">widely deployed</a> in <a href=\"https://android-developers.googleblog.com/2018/06/compiler-based-security-mitigations-in.html\">Android userspace</a> <a href=\"https://android-developers.googleblog.com/2019/05/queue-hardening-enhancements.html\">for years</a> following <a href=\"https://security.googleblog.com/2021/01/data-driven-security-hardening-in.html\">a data-driven approach</a>. These two are well suited for bare-metal environments such as the baseband since they do not require support from the OS or specific architecture features, and so are generally supported for all Clang targets.\n</p>\n<h2>Integer Overflow Sanitizer (IntSan)</h2>\n\n\n<p>\nIntSan causes signed and unsigned integer overflows to abort execution unless the overflow is made explicit. While unsigned integer overflows are technically defined behavior, it can often lead to unintentional behavior and vulnerabilities \u2013 especially when they\u2019re used to index into arrays.\n</p>\n<p>\nAs both intentional and unintentional overflows are likely present in most code bases, IntSan may require refactoring and annotating the code base to prevent intentional or benign overflows from trapping (which we consider a false positive for our purposes). Overflows which need to be addressed can be uncovered via testing (see the Deploying Sanitizers section)\n</p>\n<h2>BoundsSanitizer (BoundSan)</h2>\n\n\n<p>\nBoundSan inserts instrumentation to perform bounds checks around some array accesses. These checks are only added if the compiler cannot prove at compile time that the access will be safe and if the size of the array will be known at runtime, so that it can be checked against. Note that this will not cover all array accesses as the size of the array may not be known at runtime, such as function arguments which are arrays.\n</p>\n<p>\nAs long as the code is correctly written C/C++, BoundSan should produce no false positives. Any violations discovered when first enabling BoundSan is at least a bug, if not a vulnerability. Resolving even those which aren\u2019t exploitable can greatly improve stability and code quality.\n</p>\n<h2>Modernize your toolchains</h2>\n\n\n<p>\nAdopting modern mitigations also means adopting (and maintaining) modern toolchains. The benefits of this go beyond utilizing sanitizers however. Maintaining an old toolchain is not free and entails hidden opportunity costs. Toolchains contain bugs which are addressed in <a href=\"https://releases.llvm.org/17.0.1/tools/clang/docs/ReleaseNotes.html#bug-fixes-in-this-version\">subsequent releases</a>. Newer toolchains bring new <a href=\"https://releases.llvm.org/17.0.1/tools/clang/docs/ReleaseNotes.html#bug-fixes-in-this-version:~:text=Improved%20code%20generation,MS%20C%2B%2B%20ABI.\">performance optimizations</a>, valuable in the highly constrained bare-metal environment that basebands operate in. <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-12886\">Security</a> <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-4039\">issues</a> can even exist in the generated code of out-of-date compilers.\n</p>\n<p>\nMaintaining a modern up-to-date toolchain for the baseband entails some costs in terms of maintenance, especially at first if the toolchain is particularly old, but over time the benefits, as outlined above, outweigh the costs.\n</p>\n<h1>Where to apply sanitizers</h1>\n\n\n<p>\nBoth BoundSan and IntSan have a measurable performance overhead. Although we were able to significantly reduce this overhead in the past (<a href=\"https://security.googleblog.com/2019/05/queue-hardening-enhancements.html\">for example to less than 1% in media codecs</a>), even very small increases in CPU load can have a substantial impact in some environments.\n</p>\n<p>\nEnabling sanitizers over the entire codebase provides the most benefit, but enabling them in security-critical attack surfaces can serve as a first step in an incremental deployment. For example:\n</p>\n<ul>\n\n<li>Functions parsing messages delivered over the air in 2G, 3G, 4G, and 5G (especially functions handling pre-authentication messages that can be injected with a false/malicious base station)\n\n<li>Libraries encoding/decoding complex formats (e.g. ASN.1, XML, DNS, etc\u2026)\n\n<li>IMS, TCP and IP stacks\n\n<li>Messaging functions (SMS, MMS)\n</li>\n</ul>\n<p>\nIn the particular case of 2G, the best strategy is to disable the stack altogether by supporting Android\u2019s \u201c<a href=\"https://source.android.com/docs/setup/about/android-12-release#2g-toggle\">2G toggle</a>\u201d. However, 2G is still a necessary mobile access technology in certain parts of the world and some users might need to have this legacy protocol enabled.\n</p>\n<h1>Deploying Sanitizers</h1>\n\n\n<p>\nHaving a clear plan for deployment of sanitizers saves a lot of time and effort. We think of the deployment process as having three stages:\n</p>\n<ul>\n\n<li>Detecting (and fixing) violations\n\n<li>Measuring and reducing overhead\n\n<li>Soaking in pre-production\n</li>\n</ul>\n<p>\nWe also introduce two modes in which sanitizers should be run: <strong>diagnostics mode</strong> and <strong>trapping mode</strong>. These will be discussed in the following sections, but briefly: diagnostics mode recovers from violations and provides valuable debug information, while trapping mode actively mitigates vulnerabilities by trapping execution on violations.\n</p>\n<h2>Detecting (and Fixing) Violations</h2>\n\n\n<p>\nTo successfully ship these sanitizers, any benign integer overflows must be made explicit and accidental out-of-bounds accesses must be addressed. These will have to be uncovered through testing. The higher the code coverage your tests provide, the more issues you can uncover at this stage and the easier deployment will be later on.\n</p>\n<p>\nTo diagnose violations uncovered in testing, sanitizers can emit calls to runtime handlers with debug information such as the file, line number, and values leading to the violation. Sanitizers can optionally continue execution after a violation has occurred, allowing multiple violations to be discovered in a single test run. We refer to using the sanitizers in this way as running them in \u201c<strong>diagnostics mode</strong>\u201d. Diagnostics mode is not intended for production as it provides no security benefits and adds high overhead.\n</p>\n<p>\nDiagnostics mode for the sanitizers can be set using the following flags:\n</p>\n\n\n\n<pre class=\"prettyprint\">-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-recover=all</pre>\n\n\n<p>\nSince Clang does not provide a UBSan runtime for bare-metal targets, a runtime will need to be defined and provided at link time:\n</p>\n\n\n\n<pre class=\"prettyprint\">// integer overflow handlers\n__ubsan_handle_add_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_sub_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_mul_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_divrem_overflow(OverflowData *data, ValueHandle lhs, ValueHandle rhs)\n__ubsan_handle_negate_overflow(OverflowData *data, ValueHandle old_val)\n// boundsan handler\n__ubsan_handle_out_of_bounds_overflow(OverflowData *data, ValueHandle old_val)</pre>\n\n\n<p>\nAs an example, see the <a href=\"https://cs.android.com/android-llvm/toolchain/llvm-project/+/master:compiler-rt/lib/ubsan/ubsan_handlers.cc\">default Clang implementation</a>; the Linux Kernels <a href=\"https://cs.android.com/android/kernel/superproject/+/common-android-mainline:common/lib/ubsan.c;l=335?\">implementation</a> may also be illustrative.\n</p>\n<p>\nWith the runtime defined, enable the sanitizer over the entire baseband codebase and run all available tests to uncover and address any violations. Vulnerabilities should be patched, and overflows should either be refactored or made explicit through the use of <a href=\"https://clang.llvm.org/docs/LanguageExtensions.html#checked-arithmetic-builtins\">checked arithmetic builtins</a> which do not trigger sanitizer violations. Certain functions which are expected to have intentional overflows (such as cryptographic functions) can be preemptively excluded from sanitization (see next section).\n</p>\n<p>\nAside from uncovering security vulnerabilities, this stage is highly effective at uncovering code quality and stability bugs that could result in instability on user devices.\n</p>\n<p>\nOnce violations have been addressed and tests are no longer uncovering new violations, the next stage can begin.\n</p>\n<h2>Measuring and Reducing Overhead</h2>\n\n\n<p>\nOnce shallow violations have been addressed, benchmarks can be run and the overhead from the sanitizers (performance, code size, memory footprint) can be measured.\n</p>\n<p>\nMeasuring overhead must be done using production flags \u2013 namely <strong>\u201ctrapping mode\u201d</strong>, where violations cause execution to abort. The diagnostics runtime used in the first stage carries significant overhead and is not indicative of the actual performance sanitizer overhead.\n</p>\n<p>\nTrapping mode can be enabled using the following flags:\n</p>\n\n\n\n<pre class=\"prettyprint\">-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-trap=all</pre>\n\n\n<p>\nMost of the overhead is likely due to a small handful of \u201chot functions\u201d, for example those with tight long-running loops. Fine-grained per-function performance metrics (similar to what <a href=\"https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md\">Simpleperf</a> provides for Android), allows comparing metrics before and after sanitizers and provides the easiest means to identify hot functions. These functions can either be refactored or, after manual inspection to verify that they are safe, have sanitization disabled.\n</p>\n<p>\nSanitizers can be disabled either <a href=\"https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#disabling-instrumentation-with-attribute-no-sanitize-undefined\">inline in the source</a> or through the use of <a href=\"https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#suppressing-errors-in-recompiled-code-ignorelist\">ignorelists</a> and the -fsanitize-ignorelist flag.\n</p>\n<p>\nThe physical layer code, with its extremely tight performance margins and lower chance of exploitable vulnerabilities, may be a good candidate to disable sanitization wholesale if initial performance seems prohibitive.\n</p>\n<h2>Soaking in Pre-production</h2>\n\n\n<p>\nWith overhead minimized and shallow bugs resolved, the final stage is enabling the sanitizers in trapping mode to mitigate vulnerabilities.\n</p>\n<p>\nWe strongly recommend a long period of internal soak in pre-production with test populations to uncover any remaining violations not discovered in testing. The more thorough the test coverage and length of the soak period, the less risk there will be from undiscovered violations.\n</p>\n<p>\nAs above, the configuration for trapping mode is as follows:\n</p>\n\n\n\n<pre class=\"prettyprint\">-fsanitize=signed-integer-overflow,unsigned-integer-overflow,bounds -fsanitize-trap=all</pre>\n\n\n<p>\nHaving infrastructure in place to collect bug reports which result from any undiscovered violations can help minimize the risk they present.\n</p>\n<h1>Transitioning to Memory Safe Languages</h1>\n\n\n<p>\nThe benefits from deploying sanitizers in your existing code base are tangible, however ultimately they address only the lowest hanging fruit and will not result in a code base free of vulnerabilities. Other classes of memory safety vulnerabilities remain unaddressed by these sanitizers. A longer term solution is to begin transitioning <em>today</em> to memory-safe languages such as Rust.\n</p>\n<p>\n<a href=\"https://security.googleblog.com/2023/10/bare-metal-rust-in-android.html\">Rust is ready for bare-metal environments</a> such as the baseband, and we are already using it in other bare-metal components in Android. There is no need to rewrite everything in Rust, as Rust provides a strong C FFI support and easily interfaces with existing C codebases. <a href=\"https://security.googleblog.com/2021/04/rust-in-android-platform.html#:~:text=But%20what%20about%20all%20that%20existing%20C%2B%2B%3F\">Just writing new code in Rust</a> can rapidly <a href=\"https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html\">reduce the number of memory safety vulnerabilities</a>. Rewrites should be limited/prioritized only for the most critical components, such as complex parsers handling untrusted data.\n</p>\n<p>\nThe Android team has developed a <a href=\"https://google.github.io/comprehensive-rust/\">Rust training</a> meant to help experienced developers quickly ramp up Rust fundamentals. An entire day for <a href=\"https://google.github.io/comprehensive-rust/bare-metal.html\">bare-metal Rust</a> is included, and the course has been translated to a number of different languages.\n</p>\n<p>\nWhile the Rust compiler may not explicitly support your bare-metal target, because it is a front-end for LLVM, any target supported by LLVM can be supported in Rust through <a href=\"https://docs.rust-embedded.org/embedonomicon/custom-target.html\">custom target definitions</a>.\n</p>\n<h1>Raising the Bar</h1>\n\n\n<p>\nAs the high-level operating system becomes a more difficult target for attackers to successfully exploit, we expect that lower level components such as the baseband will attract more attention. By using modern toolchains and deploying exploit mitigation technologies, the bar for attacking the baseband can be raised as well. If you have any questions, let us know \u2013 we\u2019re here to help!\n</p>",
    "links": [
      {
        "href": "http://security.googleblog.com/feeds/2267894734490098363/comments/default",
        "rel": "replies",
        "title": "Post Comments",
        "type": "application/atom+xml"
      },
      {
        "href": "http://www.blogger.com/comment.g?blogID=1176949257541686127&postID=2267894734490098363&isPopup=true",
        "rel": "replies",
        "title": "0 Comments",
        "type": "text/html"
      },
      {
        "href": "http://www.blogger.com/feeds/1176949257541686127/posts/default/2267894734490098363",
        "rel": "edit",
        "type": "application/atom+xml"
      },
      {
        "href": "http://www.blogger.com/feeds/1176949257541686127/posts/default/2267894734490098363",
        "rel": "self",
        "type": "application/atom+xml"
      },
      {
        "href": "http://security.googleblog.com/2023/12/hardening-cellular-basebands-in-android.html",
        "rel": "alternate",
        "title": "Hardening cellular basebands in Android",
        "type": "text/html"
      }
    ],
    "authors": [
      {
        "name": "Edward Fernandez",
        "href": "http://www.blogger.com/profile/03784424747198152685",
        "email": "noreply@blogger.com"
      }
    ],
    "author_detail": {
      "name": "Edward Fernandez",
      "href": "http://www.blogger.com/profile/03784424747198152685",
      "email": "noreply@blogger.com"
    },
    "href": "http://www.blogger.com/profile/03784424747198152685",
    "author": "Edward Fernandez (noreply@blogger.com)",
    "gd_image": {
      "height": "16",
      "rel": "http://schemas.google.com/g/2005#thumbnail",
      "src": "https://img1.blogblog.com/img/b16-rounded.gif",
      "width": "16"
    },
    "thr_total": "0"
  }
}