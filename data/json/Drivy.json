{
  "company": "Drivy",
  "title": "Drivy",
  "xmlUrl": "https://drivy.engineering/feed.xml",
  "htmlUrl": "https://drivy.engineering/",
  "content": "\n\n\n\n\n\n\nJPEG and EXIF Data Manipulation in Javascript | Getaround Tech\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHome\n\n\nAbout\n\n\nOpen-source\n\nJobs\n\n\n\n\n\n\n\n\n      JPEG and EXIF Data Manipulation in Javascript\n    \n\n      September 11, 2023 \u2013 \n        C\u00e9dric Patchane\n         \u2013\n      15-minute read\n\n\n\nThe Exchangeable Image File Format (EXIF) is a standard that specifies formats for images and sounds. It stores technical details through metadata, data that describes other data, such as the camera make and model and the date and time the image was taken.\nInitially, EXIF was used for two image formats, JPEG and TIFF. But today, other file formats such as PNG, WEBP, or HEIC also support EXIF for metadata.\nThis article will focus on the JPEG format. In the first part, we will explore its structure before seeing how to read and update associated metadata through Javascript in a browser environment.\nBefore moving on, it is essential to review some key concepts:\n\ud83d\udccc What is the 0x notation?\n0x indicates that the following number is in hexadecimal format, which uses a base-16 number system (as opposed to the base-10 decimal system). This notation is case-insensitive, meaning that 0XFF and 0xff are exactly the same.\n\ud83d\udccc What is a bit or a byte?\nIn computer science, a bit is the smallest and the most basic unit of information. It is a binary digit (base 2) representing 0 or 1. A byte (or octet) is a group of eight bits. Since there are 256 possible combinations of 8 bits, a byte can be expressed as a hexadecimal number. For example:\n\nThe byte 0x00 represents 0 in decimal and corresponds to 0000 0000 in binary, which is the minimum 8-bit value.\nThe byte 0xD8 represents 216 and corresponds to 1101 1000.\nThe byte 0xFF represents 255 and corresponds to 1111 1111, which is the maximum 8-bit value.\n\nFor multiple-byte words, the hex numbers are just combined: 0xFFD8 is a two-byte word, and 0x45786966 is a four-byte word.\n\ud83d\udccc What is Endianness?\nThis is how a set of bytes is stored in memory. In big-endian, the most significant byte (leftmost) comes first, while in little-endian, the least significant byte (rightmost) comes first.\nFor example, let\u2019s consider the two-byte word 0x0124. In a big-endian system, it will be written as 01 24, whereas in a little-endian one, it will be written as 24 01. Knowing whether an image has been written on a big or little-endian device is essential to read its data correctly.\nThe EXIF segment in the JPEG structure\nSegment delimitations\nThe structure of a JPEG image is divided into parts marked by two-byte markers, always starting with a 0xFF byte. Below is a list of key markers found in the pages 20/21 of the JPEG compression specification:\n\n0xFFD8: SOI (Start of Image); indicates the beginning of the image structure.\n0xFFE*n*: APPn (Application-related tags); following the SOI marker, with n between 0 and F (full list). For example, APP11 (or 0xFFEB) is for HDR data, APP13 (or 0xFFED) for Photoshop and APP1 (or 0xFFE1) for EXIF.\n0xFFDA: SOS (Start of Scan); indicates the beginning of the image-related data.\n0xFFD9: EOI (End of Image); indicates the end of the image.\n\nThe first four file bytes, here FF D8 FF E0 for JPEG, are also known as magic numbers and are used by software to identify the file type.\nSegment size\nThe size of a segment can be determined by reading the two bytes following its marker. For example, if the segment starts with FFE1 0124 XXXXXXX, then the APP1 segment size is 292 bytes, with 0124 being the size\u2019s hexadecimal representation.\nIFD: Image File Directory\nData in JPEG structure is grouped into directories called IFDs. For example, IDF0 is located in the APP1 segment, and IFDExif is a sub-IFD of IDF0.\nThe IFD dataset includes a two-byte word indicating the number of tags, followed by the tags data and ending with the four-byte offset of the next IFD (or 0 if none).\nIFD Tag\nA tag, like all EXIF tags, is a twelve-byte length sequence made up of:\n\nTag ID (bytes 0-1): A two-byte word identifying the tag\nTag type (bytes 2-3): A two-byte word indicating the type. For example, a value of 1 for a BYTE (one-byte integer), 3 for a SHORT (two-byte integer), or 4 for a LONG (four-byte integer). For further details, see the pages 25 and 26 of the JPEG compression specification.\nTag count (bytes 4-7): A four-byte word indicating the number of values (usually 1)\nTag value or value offset (bytes 8-11): For SHORT values, two bytes are read; for LONG values, four bytes are read. If the value is longer than four bytes (e.g., RATIONAL type), these four bytes store the offset needed to reach the actual value.\n\n\n\n\n    IFD tag example: the ExifImageWidth tag\n  \n\nLocate the EXIF part\nFrom image to bytes\nTime to code! The FileReader API is here used to read the image as a buffer. Then it is transformed into a DataView for easier byte manipulation.\nThe next step is to examine the start of the JPEG structure, which should be the SOI marker:\n// Where the final image with updated metadata will be stored\nlet finalImageBlob = null\n\nconst reader = new FileReader()\nreader.addEventListener(\"load\", ({ target }) => {\n  if (!target) throw new Error(\"no blob found\")\n  const { result: buffer } = target\n  if (!buffer || typeof buffer === \"string\") throw new Error(\"not a valid JPEG\")\n\n  const view = new DataView(buffer)\n  let offset = 0\n  const SOI = 0xFFD8\n  if (view.getUint16(offset) !== SOI) throw new Error(\"not a valid JPEG\")\n  // Here will happen the image metadata manipulation\n})\n// Image given as a Blob, but readAsArrayBuffer can also take a File\nreader.readAsArrayBuffer(imageBlob)\nNote: The getUint16 function in Javascript is used to read two bytes (2*8 = 16bits), and there is a similar function for four bytes, getUint32.\nSegments reading\nFrom here can begin the loop through the image data to locate the EXIF section. The EXIF segment uses the APP1 marker followed by a special six-byte ASCII code Exif (0x457869660000) immediately following the APP1 size data.\nReaching SOS marker is reached means reaching the start of the image data so the end of the metadata section.\nconst SOS = 0xFFDA\nconst APP1 = 0xFFE1\n// Skip the last two bytes 0000 and just read the four first bytes\nconst EXIF = 0x45786966\n\nlet marker = null\n// The first two bytes (offset 0-1) was the SOI marker\noffset += 2\nwhile (marker !== SOS) {\n  marker = view.getUint16(offset)\n  const size = view.getUint16(offset + 2)\n  if (marker === APP1 && view.getUint32(offset + 4) === EXIF) {\n    // EXIF segment found!\n    // Following code will be here\n  }\n  // Skip the entire segment (header of 2 bytes + size of the segment)\n  offset += 2 + size\n}\nThe last thing to do here is to determine which is the endianness used to encode that image. In the JPEG structure, the endianness is provided thanks to the two-bytes word following the Exif special word. If the word is 0x4949, it means it\u2019s little endian, otherwise it is 0x4D4D for big endian. This endianness data must be followed by the two bytes 0x002A (42 in decimal).\nNote: From now on, always provide the endianness to the getUint16/getUint32 functions to correctly read the bytes.\nconst LITTLE_ENDIAN = 0x4949\nconst BIG_ENDIAN = 0x4d4d\n\n// The APP1 here is at the very beginning of the file\n// So at this point offset = 2,\n// + 10 to skip to the bytes after the Exif word\noffset += 10\n\nlet isLittleEndian = null\nif (view.getUint16(offset) === LITTLE_ENDIAN) isLittleEndian = true\nif (view.getUint16(offset) === BIG_ENDIAN) isLittleEndian = false\nif (!isLittleEndian) throw new Error(\"invalid endian\")\n// From now, the endianness must be specify each time bytes are read\n// The 42 word\nif (view.getUint16(offset + 2, isLittleEndian) !== 0x2a) throw new Error(\"invalid endian\")\nIf APP1 appears at the very beginning of the image structure (which is usually the case), then the structure should be as follows:\n\n\n\n    JPEG starting structure\n  \n\nRead and replace EXIF tags\nAll the necessary information are now known to search for the EXIF tags:\n\nOrientation, located in the IFD IFD0\nExifImageWidth or PixelXDimension tag, located in the IFD IFDExif, provided by the ExifOffset tag of IFD0\nExifImageHeight or PixelYDimension tag, also located in IFDExif\n\nIFD0\nTo locate the IFD0, its offset is given by the 4-byte word immediately after the endianness 42 number.\nThis sequence that includes the endianness two-byte word, 42, and the IFD0 offset four-byte word is commonly referred to as the \u201cTIFF (Tagged Image File Format) Header\u201d:\n\n\n\n    The TIFF header\n  \n\nAt this point, there are two tags that need to be found through the IFD0 data:\n\nThe Orientation tag (hex 0x0112) which is a SHORT value that must be replaced by 1\nThe EXIF specific IFD offset provided by the ExifOffset tag (hex 0x8769) which is a LONG value allowing to find the EXIF IFD tags\n\nAs mentioned earlier, the first two-byte word of the IFD indicates the number of tags in the IFD. Since each tag is 12 bytes long, multiplying the number of tags by 12 gives the size of all the IFD tags, allowing for looping through them.\nconst TAG_ID_EXIF_SUB_IFD_POINTER = 0x8769\nconst TAG_ID_ORIENTATION = 0x0112\nconst newOrientationValue = 1\n\n// Here offset = 12\n// IFD0 offset given by the 4 bytes after 42\nconst ifd0Offset = view.getUint32(offset + 4, isLittleEndian)\nconst ifd0TagsCount = view.getUint16(offset + ifd0Offset, isLittleEndian)\n// IFD0 ends after the two-byte tags count word + all the tags\nconst endOfIFD0TagsOffset = offset + ifd0Offset + 2 + ifd0TagsCount * 12\n\nfor (\n  let i = offset + ifd0Offset + 2;\n  i < endOfIFD0TagsOffset;\n  i += 12\n) {\n  // First 2 bytes = tag type\n  const tagId = view.getUint16(i, isLittleEndian)\n\n  // If Orientation tag\n  if (tagId === TAG_ID_ORIENTATION) {\n    // Skipping the 2 bytes tag type and 4 bytes tag count\n    // Type is SHORT, so 2 bytes to write\n    view.setUint16(i + 8, newOrientationValue, isLittleEndian)\n  }\n\n  // If ExifIFD offset tag\n  if (tagId === TAG_ID_EXIF_SUB_IFD_POINTER) {\n    // Type is LONG, so 4 bytes to read\n    exifSubIfdOffset = view.getUint32(i + 8, isLittleEndian)\n  }\n}\nNote: Following the same logic as for reading, the setUint16/setUint32 functions are used to respectively write two or four bytes.\nEXIF Sub-IFD\nOnce the offset of the EXIF sub-IFD is found, a new loop must be executed through that IFD\u2019s data to find the remaining height and width tags.\nHere is information about the two tags that need to be replaced:\n\nExifImageWidth or PixelXDimension tag (hex 0xa002), a LONG value that must be replaced by 1920\nExifImageHeight or PixelYDimension tag (hex 0xa003), a LONG value that must be replaced by 1080\n\nAs a reminder of what was previously stated, the IFD tag is composed of 2 bytes for the type, 4 for the count, and 4 for the value.\nconst TAG_ID_EXIF_IMAGE_WIDTH = 0xa002\nconst TAG_ID_EXIF_IMAGE_HEIGHT = 0xa003\nconst newWidthValue = 1920\nconst newHeightValue = 1080\n\nif (exifSubIfdOffset) {\n  const exifSubIfdTagsCount = view.getUint16(offset + exifSubIfdOffset, isLittleEndian)\n// This IFD also ends after the two-byte tags count word + all the tags\n  const endOfExifSubIfdTagsOffset =\n    offset +\n    exifSubIfdOffset +\n    2 +\n    exifSubIfdTagsCount * 12\n  for (\n    let i = offset + exifSubIfdOffset + 2;\n    i < endOfExifSubIfdTagsOffset;\n    i += 12\n  ) {\n    // First 2 bytes = tag type\n    const tagId = view.getUint16(i, isLittleEndian)\n\n    // Skipping the 2 bytes tag type and 4 bytes tag count\n    // The two types are LONG, so 4 bytes to write\n    if (tagId === TAG_ID_EXIF_IMAGE_WIDTH) {\n      view.setUint32(i + 8, newWidthValue, isLittleEndian)\n    } else if (tagId === TAG_ID_EXIF_IMAGE_HEIGHT) {\n      view.setUint32(i + 8, newHeightValue, isLittleEndian)\n    }\n  }\n}\nWrite back the image\nGetting the final image is as simple as building a new Blob from the updated buffer data:\nfinalImageBlob = new Blob(view)\nIn the end, the updated blob can be converted to a file or downloaded, depending on the application\u2019s needs.\nConclusion\nThis article covers the basics of reading and updating tags, but you can expand the code by adding more tags. All the hex codes for the tags can be found on exiftools.org or this tags reference site.\nIt\u2019s worth noting that there are existing libraries like exif-js or piexifjs for manipulating EXIF data, but they may be larger than what is needed here and seems not being actively maintained.\nIf you want to see the full code used to write this article, feel free to check out this gist.\n\n\n\n\n        Did you enjoy this post? Join Getaround's engineering team!\n      \n\n        View openings\n      \n\n\n\n\n\n        \u00ab\u00a0Babel, JavaScript Transpiling And Polyfills\n      \n\n\n\n\n\n\n\n      \u00a9 2023 \n      Getaround\n       \u2013 Powered by\n      Jekyll\n\n\n\n\n\n",
  "latestPost": {
    "title": "JPEG and EXIF Data Manipulation in Javascript",
    "title_detail": {
      "type": "text/plain",
      "language": null,
      "base": "https://getaround.tech/feed.xml",
      "value": "JPEG and EXIF Data Manipulation in Javascript"
    },
    "authors": [
      {
        "name": "C\u00e9dric Patchane"
      }
    ],
    "author": "C\u00e9dric Patchane",
    "author_detail": {
      "name": "C\u00e9dric Patchane"
    },
    "summary": "<p>The <strong>E</strong>xchangeable <strong>I</strong>mage <strong>F</strong>ile <strong>F</strong>ormat (EXIF) is a standard that specifies formats for images and sounds. It stores technical details through metadata, data that describes other data, such as the camera make and model and the date and time the image was taken.</p>\n\n<p>Initially, EXIF was used for two image formats, JPEG and TIFF. But today, other file formats such as PNG, WEBP, or HEIC also support EXIF for metadata.</p>\n\n<p>This article will focus on the JPEG format. In the first part, we will explore its structure before seeing how to read and update associated metadata through Javascript in a browser environment.</p>\n\n<p>Before moving on, it is essential to review some key concepts:</p>\n\n<p><strong>\ud83d\udccc What is the <code class=\"language-plaintext highlighter-rouge\">0x</code> notation?</strong>\n<code class=\"language-plaintext highlighter-rouge\">0x</code> indicates that the following number is in hexadecimal format, which uses a base-16 number system (as opposed to the base-10 decimal system). This notation is case-insensitive, meaning that <code class=\"language-plaintext highlighter-rouge\">0XFF</code> and <code class=\"language-plaintext highlighter-rouge\">0xff</code> are exactly the same.</p>\n\n<p><strong>\ud83d\udccc What is a bit or a byte?</strong>\nIn computer science, a bit is the smallest and the most basic unit of information. It is a binary digit (base 2) representing 0 or 1. A byte (or octet) is a group of eight bits. Since there are 256 possible combinations of 8 bits, a byte can be expressed as a hexadecimal number. For example:</p>\n\n<ul>\n  <li>The byte <code class=\"language-plaintext highlighter-rouge\">0x00</code> represents <code class=\"language-plaintext highlighter-rouge\">0</code> in decimal and corresponds to <code class=\"language-plaintext highlighter-rouge\">0000 0000</code> in binary, which is the minimum 8-bit value.</li>\n  <li>The byte <code class=\"language-plaintext highlighter-rouge\">0xD8</code> represents <code class=\"language-plaintext highlighter-rouge\">216</code> and corresponds to <code class=\"language-plaintext highlighter-rouge\">1101 1000</code>.</li>\n  <li>The byte <code class=\"language-plaintext highlighter-rouge\">0xFF</code> represents <code class=\"language-plaintext highlighter-rouge\">255</code> and corresponds to <code class=\"language-plaintext highlighter-rouge\">1111 1111</code>, which is the maximum 8-bit value.</li>\n</ul>\n\n<p>For multiple-byte words, the hex numbers are just combined: <code class=\"language-plaintext highlighter-rouge\">0xFFD8</code> is a two-byte word, and <code class=\"language-plaintext highlighter-rouge\">0x45786966</code> is a four-byte word.</p>\n\n<p><strong>\ud83d\udccc What is Endianness?</strong>\nThis is how a set of bytes is stored in memory. In big-endian, the most significant byte (leftmost) comes first, while in little-endian, the least significant byte (rightmost) comes first.</p>\n\n<p>For example, let\u2019s consider the two-byte word <code class=\"language-plaintext highlighter-rouge\">0x0124</code>. In a big-endian system, it will be written as <code class=\"language-plaintext highlighter-rouge\">01 24</code>, whereas in a little-endian one, it will be written as <code class=\"language-plaintext highlighter-rouge\">24 01</code>. Knowing whether an image has been written on a big or little-endian device is essential to read its data correctly.</p>\n\n<h2 id=\"the-exif-segment-in-the-jpeg-structure\">The EXIF segment in the JPEG structure</h2>\n\n<h3 id=\"segment-delimitations\">Segment delimitations</h3>\n\n<p>The structure of a JPEG image is divided into parts marked by two-byte markers, always starting with a <code class=\"language-plaintext highlighter-rouge\">0xFF</code> byte. Below is a list of key markers found in the pages 20/21 of the <a href=\"https://www.cipa.jp/std/documents/e/DC-008-2012_E.pdf\">JPEG compression specification</a>:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">0xFFD8</code>: <strong>SOI</strong> (Start of Image); indicates the beginning of the image structure.</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">0xFFE*n*</code>: <strong>APPn</strong> (Application-related tags); following the <strong>SOI</strong> marker, with <code class=\"language-plaintext highlighter-rouge\">n</code> between <code class=\"language-plaintext highlighter-rouge\">0</code> and <code class=\"language-plaintext highlighter-rouge\">F</code> (<a href=\"https://exiftool.org/TagNames/JPEG.html\">full list</a>). For example, <strong>APP11</strong> (or <code class=\"language-plaintext highlighter-rouge\">0xFFEB</code>) is for HDR data, <strong>APP13</strong> (or <code class=\"language-plaintext highlighter-rouge\">0xFFED</code>) for Photoshop and <strong>APP1</strong> (or <code class=\"language-plaintext highlighter-rouge\">0xFFE1</code>) for EXIF.</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">0xFFDA</code>: <strong>SOS</strong> (Start of Scan); indicates the beginning of the image-related data.</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">0xFFD9</code>: <strong>EOI</strong> (End of Image); indicates the end of the image.</li>\n</ul>\n\n<p>The first four file bytes, here <code class=\"language-plaintext highlighter-rouge\">FF D8 FF E0</code> for JPEG, are also known as <a href=\"https://en.wikipedia.org/wiki/List_of_file_signatures\">magic numbers</a> and are used by software to identify the file type.</p>\n\n<h3 id=\"segment-size\">Segment size</h3>\n\n<p>The size of a segment can be determined by reading the two bytes following its marker. For example, if the segment starts with <code class=\"language-plaintext highlighter-rouge\">FFE1 0124 XXXXXXX</code>, then the APP1 segment size is 292 bytes, with <code class=\"language-plaintext highlighter-rouge\">0124</code> being the size\u2019s hexadecimal representation.</p>\n\n<h3 id=\"ifd-image-file-directory\">IFD: Image File Directory</h3>\n\n<p>Data in JPEG structure is grouped into directories called IFDs. For example, <code class=\"language-plaintext highlighter-rouge\">IDF0</code> is located in the <code class=\"language-plaintext highlighter-rouge\">APP1</code> segment, and <code class=\"language-plaintext highlighter-rouge\">IFDExif</code> is a sub-IFD of <code class=\"language-plaintext highlighter-rouge\">IDF0</code>.</p>\n\n<p>The IFD dataset includes a two-byte word indicating the number of tags, followed by the tags data and ending with the four-byte offset of the next IFD (or 0 if none).</p>\n\n<h3 id=\"ifd-tag\">IFD Tag</h3>\n\n<p>A tag, like all EXIF tags, is a twelve-byte length sequence made up of:</p>\n\n<ul>\n  <li>Tag ID (bytes 0-1): A two-byte word identifying the tag</li>\n  <li>Tag type (bytes 2-3): A two-byte word indicating the type. For example, a value of <code class=\"language-plaintext highlighter-rouge\">1</code> for a <code class=\"language-plaintext highlighter-rouge\">BYTE</code> (one-byte integer), <code class=\"language-plaintext highlighter-rouge\">3</code> for a <code class=\"language-plaintext highlighter-rouge\">SHORT</code> (two-byte integer), or <code class=\"language-plaintext highlighter-rouge\">4</code> for a <code class=\"language-plaintext highlighter-rouge\">LONG</code> (four-byte integer). For further details, see the pages 25 and 26 of the <a href=\"https://www.cipa.jp/std/documents/e/DC-008-2012_E.pdf\">JPEG compression specification</a>.</li>\n  <li>Tag count (bytes 4-7): A four-byte word indicating the number of values (usually 1)</li>\n  <li>Tag value or value offset (bytes 8-11): For <code class=\"language-plaintext highlighter-rouge\">SHORT</code> values, two bytes are read; for <code class=\"language-plaintext highlighter-rouge\">LONG</code> values, four bytes are read. If the value is longer than four bytes (e.g., <code class=\"language-plaintext highlighter-rouge\">RATIONAL</code> type), these four bytes store the offset needed to reach the actual value.</li>\n</ul>\n\n<figure>\n  <img alt=\"IFD tag example: the ExifImageWidth tag\" src=\"https://getaround.tech/assets/posts/2023-09-11-exif-data-manipulation-javascript/exif_ifd_tag.png\" />\n  <figcaption>\n    IFD tag example: the ExifImageWidth tag\n  </figcaption>\n</figure>\n\n<h2 id=\"locate-the-exif-part\">Locate the EXIF part</h2>\n\n<h3 id=\"from-image-to-bytes\">From image to bytes</h3>\n<p>Time to code! The <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\"><code class=\"language-plaintext highlighter-rouge\">FileReader</code></a> API is here used to read the image as a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code class=\"language-plaintext highlighter-rouge\">buffer</code></a>. Then it is transformed into a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\"><code class=\"language-plaintext highlighter-rouge\">DataView</code></a> for easier byte manipulation.</p>\n\n<p>The next step is to examine the start of the JPEG structure, which should be the <strong>SOI</strong> marker:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"c1\">// Where the final image with updated metadata will be stored</span>\n<span class=\"kd\">let</span> <span class=\"nx\">finalImageBlob</span> <span class=\"o\">=</span> <span class=\"kc\">null</span>\n\n<span class=\"kd\">const</span> <span class=\"nx\">reader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">FileReader</span><span class=\"p\">()</span>\n<span class=\"nx\">reader</span><span class=\"p\">.</span><span class=\"nx\">addEventListener</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">load</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"p\">({</span> <span class=\"nx\">target</span> <span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">target</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">no blob found</span><span class=\"dl\">\"</span><span class=\"p\">)</span>\n  <span class=\"kd\">const</span> <span class=\"p\">{</span> <span class=\"na\">result</span><span class=\"p\">:</span> <span class=\"nx\">buffer</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">target</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">buffer</span> <span class=\"o\">||</span> <span class=\"k\">typeof</span> <span class=\"nx\">buffer</span> <span class=\"o\">===</span> <span class=\"dl\">\"</span><span class=\"s2\">string</span><span class=\"dl\">\"</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">not a valid JPEG</span><span class=\"dl\">\"</span><span class=\"p\">)</span>\n\n  <span class=\"kd\">const</span> <span class=\"nx\">view</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">DataView</span><span class=\"p\">(</span><span class=\"nx\">buffer</span><span class=\"p\">)</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">offset</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">SOI</span> <span class=\"o\">=</span> <span class=\"mh\">0xFFD8</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span><span class=\"p\">)</span> <span class=\"o\">!==</span> <span class=\"nx\">SOI</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">not a valid JPEG</span><span class=\"dl\">\"</span><span class=\"p\">)</span>\n  <span class=\"c1\">// Here will happen the image metadata manipulation</span>\n<span class=\"p\">})</span>\n<span class=\"c1\">// Image given as a Blob, but readAsArrayBuffer can also take a File</span>\n<span class=\"nx\">reader</span><span class=\"p\">.</span><span class=\"nx\">readAsArrayBuffer</span><span class=\"p\">(</span><span class=\"nx\">imageBlob</span><span class=\"p\">)</span></code></pre></figure>\n\n<p><strong>Note:</strong> The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint16\"><code class=\"language-plaintext highlighter-rouge\">getUint16</code></a> function in Javascript is used to read two bytes (2*8 = 16bits), and there is a similar function for four bytes, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32\"><code class=\"language-plaintext highlighter-rouge\">getUint32</code></a>.</p>\n\n<h3 id=\"segments-reading\">Segments reading</h3>\n<p>From here can begin the loop through the image data to locate the EXIF section. The EXIF segment uses the <code class=\"language-plaintext highlighter-rouge\">APP1</code> marker followed by a special six-byte ASCII code <code class=\"language-plaintext highlighter-rouge\">Exif</code> (<code class=\"language-plaintext highlighter-rouge\">0x457869660000</code>) immediately following the <code class=\"language-plaintext highlighter-rouge\">APP1</code> size data.</p>\n\n<p>Reaching <strong>SOS</strong> marker is reached means reaching the start of the image data so the end of the metadata section.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">SOS</span> <span class=\"o\">=</span> <span class=\"mh\">0xFFDA</span>\n<span class=\"kd\">const</span> <span class=\"nx\">APP1</span> <span class=\"o\">=</span> <span class=\"mh\">0xFFE1</span>\n<span class=\"c1\">// Skip the last two bytes 0000 and just read the four first bytes</span>\n<span class=\"kd\">const</span> <span class=\"nx\">EXIF</span> <span class=\"o\">=</span> <span class=\"mh\">0x45786966</span>\n\n<span class=\"kd\">let</span> <span class=\"nx\">marker</span> <span class=\"o\">=</span> <span class=\"kc\">null</span>\n<span class=\"c1\">// The first two bytes (offset 0-1) was the SOI marker</span>\n<span class=\"nx\">offset</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nx\">marker</span> <span class=\"o\">!==</span> <span class=\"nx\">SOS</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">marker</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span><span class=\"p\">)</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">size</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">marker</span> <span class=\"o\">===</span> <span class=\"nx\">APP1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint32</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"o\">===</span> <span class=\"nx\">EXIF</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// EXIF segment found!</span>\n    <span class=\"c1\">// Following code will be here</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// Skip the entire segment (header of 2 bytes + size of the segment)</span>\n  <span class=\"nx\">offset</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"nx\">size</span>\n<span class=\"p\">}</span></code></pre></figure>\n\n<p>The last thing to do here is to determine which is the endianness used to encode that image. In the JPEG structure, the endianness is provided thanks to the two-bytes word following the <code class=\"language-plaintext highlighter-rouge\">Exif</code> special word. If the word is <code class=\"language-plaintext highlighter-rouge\">0x4949</code>, it means it\u2019s little endian, otherwise it is <code class=\"language-plaintext highlighter-rouge\">0x4D4D</code> for big endian. This endianness data must be followed by the two bytes <code class=\"language-plaintext highlighter-rouge\">0x002A</code> (42 in decimal).</p>\n\n<p><strong>Note:</strong> From now on, always provide the endianness to the <code class=\"language-plaintext highlighter-rouge\">getUint16</code>/<code class=\"language-plaintext highlighter-rouge\">getUint32</code> functions to correctly read the bytes.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">LITTLE_ENDIAN</span> <span class=\"o\">=</span> <span class=\"mh\">0x4949</span>\n<span class=\"kd\">const</span> <span class=\"nx\">BIG_ENDIAN</span> <span class=\"o\">=</span> <span class=\"mh\">0x4d4d</span>\n\n<span class=\"c1\">// The APP1 here is at the very beginning of the file</span>\n<span class=\"c1\">// So at this point offset = 2,</span>\n<span class=\"c1\">// + 10 to skip to the bytes after the Exif word</span>\n<span class=\"nx\">offset</span> <span class=\"o\">+=</span> <span class=\"mi\">10</span>\n\n<span class=\"kd\">let</span> <span class=\"nx\">isLittleEndian</span> <span class=\"o\">=</span> <span class=\"kc\">null</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span><span class=\"p\">)</span> <span class=\"o\">===</span> <span class=\"nx\">LITTLE_ENDIAN</span><span class=\"p\">)</span> <span class=\"nx\">isLittleEndian</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span><span class=\"p\">)</span> <span class=\"o\">===</span> <span class=\"nx\">BIG_ENDIAN</span><span class=\"p\">)</span> <span class=\"nx\">isLittleEndian</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">invalid endian</span><span class=\"dl\">\"</span><span class=\"p\">)</span>\n<span class=\"c1\">// From now, the endianness must be specify each time bytes are read</span>\n<span class=\"c1\">// The 42 word</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span> <span class=\"o\">!==</span> <span class=\"mh\">0x2a</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">invalid endian</span><span class=\"dl\">\"</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>If APP1 appears at the very beginning of the image structure (which is usually the case), then the structure should be as follows:</p>\n<figure>\n  <img alt=\"JPEG starting structure\" src=\"https://getaround.tech/assets/posts/2023-09-11-exif-data-manipulation-javascript/exif_markers.png\" />\n  <figcaption>\n    JPEG starting structure\n  </figcaption>\n</figure>\n\n<h2 id=\"read-and-replace-exif-tags\">Read and replace EXIF tags</h2>\n\n<p>All the necessary information are now known to search for the EXIF tags:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">Orientation</code>, located in the IFD <code class=\"language-plaintext highlighter-rouge\">IFD0</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">ExifImageWidth</code> or <code class=\"language-plaintext highlighter-rouge\">PixelXDimension</code> tag, located in the IFD <code class=\"language-plaintext highlighter-rouge\">IFDExif</code>, provided by the <code class=\"language-plaintext highlighter-rouge\">ExifOffset</code> tag of <code class=\"language-plaintext highlighter-rouge\">IFD0</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">ExifImageHeight</code> or <code class=\"language-plaintext highlighter-rouge\">PixelYDimension</code> tag, also located in <code class=\"language-plaintext highlighter-rouge\">IFDExif</code></li>\n</ul>\n\n<h3 id=\"ifd0\">IFD0</h3>\n\n<p>To locate the <code class=\"language-plaintext highlighter-rouge\">IFD0</code>, its offset is given by the 4-byte word immediately after the endianness <code class=\"language-plaintext highlighter-rouge\">42</code> number.</p>\n\n<p>This sequence that includes the endianness two-byte word, <code class=\"language-plaintext highlighter-rouge\">42</code>, and the <code class=\"language-plaintext highlighter-rouge\">IFD0</code> offset four-byte word is commonly referred to as the \u201cTIFF (<strong>T</strong>agged <strong>I</strong>mage <strong>F</strong>ile <strong>F</strong>ormat) Header\u201d:</p>\n\n<figure>\n  <img alt=\"The TIFF header\" src=\"https://getaround.tech/assets/posts/2023-09-11-exif-data-manipulation-javascript/exif_TIFF_header.png\" />\n  <figcaption>\n    The TIFF header\n  </figcaption>\n</figure>\n\n<p>At this point, there are two tags that need to be found through the <code class=\"language-plaintext highlighter-rouge\">IFD0</code> data:</p>\n\n<ul>\n  <li>The <a href=\"https://www.awaresystems.be/imaging/tiff/tifftags/orientation.html\"><code class=\"language-plaintext highlighter-rouge\">Orientation</code></a> tag (hex <code class=\"language-plaintext highlighter-rouge\">0x0112</code>) which is a <code class=\"language-plaintext highlighter-rouge\">SHORT</code> value that must be replaced by <code class=\"language-plaintext highlighter-rouge\">1</code></li>\n  <li>The EXIF specific IFD offset provided by the <a href=\"https://www.awaresystems.be/imaging/tiff/tifftags/exififd.html\"><code class=\"language-plaintext highlighter-rouge\">ExifOffset</code></a> tag (hex <code class=\"language-plaintext highlighter-rouge\">0x8769</code>) which is a <code class=\"language-plaintext highlighter-rouge\">LONG</code> value allowing to find the EXIF IFD tags</li>\n</ul>\n\n<p>As mentioned earlier, the first two-byte word of the IFD indicates the number of tags in the IFD. Since each tag is 12 bytes long, multiplying the number of tags by 12 gives the size of all the IFD tags, allowing for looping through them.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">TAG_ID_EXIF_SUB_IFD_POINTER</span> <span class=\"o\">=</span> <span class=\"mh\">0x8769</span>\n<span class=\"kd\">const</span> <span class=\"nx\">TAG_ID_ORIENTATION</span> <span class=\"o\">=</span> <span class=\"mh\">0x0112</span>\n<span class=\"kd\">const</span> <span class=\"nx\">newOrientationValue</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">// Here offset = 12</span>\n<span class=\"c1\">// IFD0 offset given by the 4 bytes after 42</span>\n<span class=\"kd\">const</span> <span class=\"nx\">ifd0Offset</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint32</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n<span class=\"kd\">const</span> <span class=\"nx\">ifd0TagsCount</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">ifd0Offset</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n<span class=\"c1\">// IFD0 ends after the two-byte tags count word + all the tags</span>\n<span class=\"kd\">const</span> <span class=\"nx\">endOfIFD0TagsOffset</span> <span class=\"o\">=</span> <span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">ifd0Offset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"nx\">ifd0TagsCount</span> <span class=\"o\">*</span> <span class=\"mi\">12</span>\n\n<span class=\"k\">for</span> <span class=\"p\">(</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">ifd0Offset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n  <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">endOfIFD0TagsOffset</span><span class=\"p\">;</span>\n  <span class=\"nx\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">12</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// First 2 bytes = tag type</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">tagId</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">i</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n\n  <span class=\"c1\">// If Orientation tag</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">tagId</span> <span class=\"o\">===</span> <span class=\"nx\">TAG_ID_ORIENTATION</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Skipping the 2 bytes tag type and 4 bytes tag count</span>\n    <span class=\"c1\">// Type is SHORT, so 2 bytes to write</span>\n    <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">setUint16</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nx\">newOrientationValue</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// If ExifIFD offset tag</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">tagId</span> <span class=\"o\">===</span> <span class=\"nx\">TAG_ID_EXIF_SUB_IFD_POINTER</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Type is LONG, so 4 bytes to read</span>\n    <span class=\"nx\">exifSubIfdOffset</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint32</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></figure>\n\n<p><strong>Note:</strong> Following the same logic as for reading, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint16\"><code class=\"language-plaintext highlighter-rouge\">setUint16</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint32\"><code class=\"language-plaintext highlighter-rouge\">setUint32</code></a> functions are used to respectively write two or four bytes.</p>\n\n<h3 id=\"exif-sub-ifd\">EXIF Sub-IFD</h3>\n\n<p>Once the offset of the EXIF sub-IFD is found, a new loop must be executed through that IFD\u2019s data to find the remaining height and width tags.</p>\n\n<p>Here is information about the two tags that need to be replaced:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ExifImageWidth</code> or <code class=\"language-plaintext highlighter-rouge\">PixelXDimension</code> tag (hex <code class=\"language-plaintext highlighter-rouge\">0xa002</code>), a <code class=\"language-plaintext highlighter-rouge\">LONG</code> value that must be replaced by <code class=\"language-plaintext highlighter-rouge\">1920</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">ExifImageHeight</code> or <code class=\"language-plaintext highlighter-rouge\">PixelYDimension</code> tag (hex <code class=\"language-plaintext highlighter-rouge\">0xa003</code>), a <code class=\"language-plaintext highlighter-rouge\">LONG</code> value that must be replaced by <code class=\"language-plaintext highlighter-rouge\">1080</code></li>\n</ul>\n\n<p>As a reminder of what was previously stated, the IFD tag is composed of 2 bytes for the type, 4 for the count, and 4 for the value.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">TAG_ID_EXIF_IMAGE_WIDTH</span> <span class=\"o\">=</span> <span class=\"mh\">0xa002</span>\n<span class=\"kd\">const</span> <span class=\"nx\">TAG_ID_EXIF_IMAGE_HEIGHT</span> <span class=\"o\">=</span> <span class=\"mh\">0xa003</span>\n<span class=\"kd\">const</span> <span class=\"nx\">newWidthValue</span> <span class=\"o\">=</span> <span class=\"mi\">1920</span>\n<span class=\"kd\">const</span> <span class=\"nx\">newHeightValue</span> <span class=\"o\">=</span> <span class=\"mi\">1080</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">exifSubIfdOffset</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">exifSubIfdTagsCount</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">exifSubIfdOffset</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n<span class=\"c1\">// This IFD also ends after the two-byte tags count word + all the tags</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">endOfExifSubIfdTagsOffset</span> <span class=\"o\">=</span>\n    <span class=\"nx\">offset</span> <span class=\"o\">+</span>\n    <span class=\"nx\">exifSubIfdOffset</span> <span class=\"o\">+</span>\n    <span class=\"mi\">2</span> <span class=\"o\">+</span>\n    <span class=\"nx\">exifSubIfdTagsCount</span> <span class=\"o\">*</span> <span class=\"mi\">12</span>\n  <span class=\"k\">for</span> <span class=\"p\">(</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">exifSubIfdOffset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">endOfExifSubIfdTagsOffset</span><span class=\"p\">;</span>\n    <span class=\"nx\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">12</span>\n  <span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// First 2 bytes = tag type</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">tagId</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">i</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">// Skipping the 2 bytes tag type and 4 bytes tag count</span>\n    <span class=\"c1\">// The two types are LONG, so 4 bytes to write</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">tagId</span> <span class=\"o\">===</span> <span class=\"nx\">TAG_ID_EXIF_IMAGE_WIDTH</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">setUint32</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nx\">newWidthValue</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">tagId</span> <span class=\"o\">===</span> <span class=\"nx\">TAG_ID_EXIF_IMAGE_HEIGHT</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">setUint32</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nx\">newHeightValue</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></figure>\n\n<h3 id=\"write-back-the-image\">Write back the image</h3>\n\n<p>Getting the final image is as simple as building a new Blob from the updated buffer data:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"nx\">finalImageBlob</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Blob</span><span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>In the end, the updated blob can be converted to a file or downloaded, depending on the application\u2019s needs.</p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>This article covers the basics of reading and updating tags, but you can expand the code by adding more tags. All the hex codes for the tags can be found on <a href=\"https://exiftool.org/TagNames/EXIF.html\">exiftools.org</a> or <a href=\"https://www.awaresystems.be/imaging/tiff/tifftags.html\">this tags reference site</a>.</p>\n\n<p>It\u2019s worth noting that there are existing libraries like <a href=\"https://github.com/exif-js/exif-js/issues/266#issuecomment-1333686536\"><code class=\"language-plaintext highlighter-rouge\">exif-js</code></a> or <a href=\"https://github.com/hMatoba/piexifjs/issues/78\"><code class=\"language-plaintext highlighter-rouge\">piexifjs</code></a> for manipulating EXIF data, but they may be larger than what is needed here and seems not being actively maintained.</p>\n\n<p>If you want to see the full code used to write this article, feel free to check out <a href=\"https://gist.github.com/CPatchane/bcd523298e64b1fa813cfae82b0f2b42\">this gist</a>.</p>",
    "summary_detail": {
      "type": "text/html",
      "language": null,
      "base": "https://getaround.tech/feed.xml",
      "value": "<p>The <strong>E</strong>xchangeable <strong>I</strong>mage <strong>F</strong>ile <strong>F</strong>ormat (EXIF) is a standard that specifies formats for images and sounds. It stores technical details through metadata, data that describes other data, such as the camera make and model and the date and time the image was taken.</p>\n\n<p>Initially, EXIF was used for two image formats, JPEG and TIFF. But today, other file formats such as PNG, WEBP, or HEIC also support EXIF for metadata.</p>\n\n<p>This article will focus on the JPEG format. In the first part, we will explore its structure before seeing how to read and update associated metadata through Javascript in a browser environment.</p>\n\n<p>Before moving on, it is essential to review some key concepts:</p>\n\n<p><strong>\ud83d\udccc What is the <code class=\"language-plaintext highlighter-rouge\">0x</code> notation?</strong>\n<code class=\"language-plaintext highlighter-rouge\">0x</code> indicates that the following number is in hexadecimal format, which uses a base-16 number system (as opposed to the base-10 decimal system). This notation is case-insensitive, meaning that <code class=\"language-plaintext highlighter-rouge\">0XFF</code> and <code class=\"language-plaintext highlighter-rouge\">0xff</code> are exactly the same.</p>\n\n<p><strong>\ud83d\udccc What is a bit or a byte?</strong>\nIn computer science, a bit is the smallest and the most basic unit of information. It is a binary digit (base 2) representing 0 or 1. A byte (or octet) is a group of eight bits. Since there are 256 possible combinations of 8 bits, a byte can be expressed as a hexadecimal number. For example:</p>\n\n<ul>\n  <li>The byte <code class=\"language-plaintext highlighter-rouge\">0x00</code> represents <code class=\"language-plaintext highlighter-rouge\">0</code> in decimal and corresponds to <code class=\"language-plaintext highlighter-rouge\">0000 0000</code> in binary, which is the minimum 8-bit value.</li>\n  <li>The byte <code class=\"language-plaintext highlighter-rouge\">0xD8</code> represents <code class=\"language-plaintext highlighter-rouge\">216</code> and corresponds to <code class=\"language-plaintext highlighter-rouge\">1101 1000</code>.</li>\n  <li>The byte <code class=\"language-plaintext highlighter-rouge\">0xFF</code> represents <code class=\"language-plaintext highlighter-rouge\">255</code> and corresponds to <code class=\"language-plaintext highlighter-rouge\">1111 1111</code>, which is the maximum 8-bit value.</li>\n</ul>\n\n<p>For multiple-byte words, the hex numbers are just combined: <code class=\"language-plaintext highlighter-rouge\">0xFFD8</code> is a two-byte word, and <code class=\"language-plaintext highlighter-rouge\">0x45786966</code> is a four-byte word.</p>\n\n<p><strong>\ud83d\udccc What is Endianness?</strong>\nThis is how a set of bytes is stored in memory. In big-endian, the most significant byte (leftmost) comes first, while in little-endian, the least significant byte (rightmost) comes first.</p>\n\n<p>For example, let\u2019s consider the two-byte word <code class=\"language-plaintext highlighter-rouge\">0x0124</code>. In a big-endian system, it will be written as <code class=\"language-plaintext highlighter-rouge\">01 24</code>, whereas in a little-endian one, it will be written as <code class=\"language-plaintext highlighter-rouge\">24 01</code>. Knowing whether an image has been written on a big or little-endian device is essential to read its data correctly.</p>\n\n<h2 id=\"the-exif-segment-in-the-jpeg-structure\">The EXIF segment in the JPEG structure</h2>\n\n<h3 id=\"segment-delimitations\">Segment delimitations</h3>\n\n<p>The structure of a JPEG image is divided into parts marked by two-byte markers, always starting with a <code class=\"language-plaintext highlighter-rouge\">0xFF</code> byte. Below is a list of key markers found in the pages 20/21 of the <a href=\"https://www.cipa.jp/std/documents/e/DC-008-2012_E.pdf\">JPEG compression specification</a>:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">0xFFD8</code>: <strong>SOI</strong> (Start of Image); indicates the beginning of the image structure.</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">0xFFE*n*</code>: <strong>APPn</strong> (Application-related tags); following the <strong>SOI</strong> marker, with <code class=\"language-plaintext highlighter-rouge\">n</code> between <code class=\"language-plaintext highlighter-rouge\">0</code> and <code class=\"language-plaintext highlighter-rouge\">F</code> (<a href=\"https://exiftool.org/TagNames/JPEG.html\">full list</a>). For example, <strong>APP11</strong> (or <code class=\"language-plaintext highlighter-rouge\">0xFFEB</code>) is for HDR data, <strong>APP13</strong> (or <code class=\"language-plaintext highlighter-rouge\">0xFFED</code>) for Photoshop and <strong>APP1</strong> (or <code class=\"language-plaintext highlighter-rouge\">0xFFE1</code>) for EXIF.</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">0xFFDA</code>: <strong>SOS</strong> (Start of Scan); indicates the beginning of the image-related data.</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">0xFFD9</code>: <strong>EOI</strong> (End of Image); indicates the end of the image.</li>\n</ul>\n\n<p>The first four file bytes, here <code class=\"language-plaintext highlighter-rouge\">FF D8 FF E0</code> for JPEG, are also known as <a href=\"https://en.wikipedia.org/wiki/List_of_file_signatures\">magic numbers</a> and are used by software to identify the file type.</p>\n\n<h3 id=\"segment-size\">Segment size</h3>\n\n<p>The size of a segment can be determined by reading the two bytes following its marker. For example, if the segment starts with <code class=\"language-plaintext highlighter-rouge\">FFE1 0124 XXXXXXX</code>, then the APP1 segment size is 292 bytes, with <code class=\"language-plaintext highlighter-rouge\">0124</code> being the size\u2019s hexadecimal representation.</p>\n\n<h3 id=\"ifd-image-file-directory\">IFD: Image File Directory</h3>\n\n<p>Data in JPEG structure is grouped into directories called IFDs. For example, <code class=\"language-plaintext highlighter-rouge\">IDF0</code> is located in the <code class=\"language-plaintext highlighter-rouge\">APP1</code> segment, and <code class=\"language-plaintext highlighter-rouge\">IFDExif</code> is a sub-IFD of <code class=\"language-plaintext highlighter-rouge\">IDF0</code>.</p>\n\n<p>The IFD dataset includes a two-byte word indicating the number of tags, followed by the tags data and ending with the four-byte offset of the next IFD (or 0 if none).</p>\n\n<h3 id=\"ifd-tag\">IFD Tag</h3>\n\n<p>A tag, like all EXIF tags, is a twelve-byte length sequence made up of:</p>\n\n<ul>\n  <li>Tag ID (bytes 0-1): A two-byte word identifying the tag</li>\n  <li>Tag type (bytes 2-3): A two-byte word indicating the type. For example, a value of <code class=\"language-plaintext highlighter-rouge\">1</code> for a <code class=\"language-plaintext highlighter-rouge\">BYTE</code> (one-byte integer), <code class=\"language-plaintext highlighter-rouge\">3</code> for a <code class=\"language-plaintext highlighter-rouge\">SHORT</code> (two-byte integer), or <code class=\"language-plaintext highlighter-rouge\">4</code> for a <code class=\"language-plaintext highlighter-rouge\">LONG</code> (four-byte integer). For further details, see the pages 25 and 26 of the <a href=\"https://www.cipa.jp/std/documents/e/DC-008-2012_E.pdf\">JPEG compression specification</a>.</li>\n  <li>Tag count (bytes 4-7): A four-byte word indicating the number of values (usually 1)</li>\n  <li>Tag value or value offset (bytes 8-11): For <code class=\"language-plaintext highlighter-rouge\">SHORT</code> values, two bytes are read; for <code class=\"language-plaintext highlighter-rouge\">LONG</code> values, four bytes are read. If the value is longer than four bytes (e.g., <code class=\"language-plaintext highlighter-rouge\">RATIONAL</code> type), these four bytes store the offset needed to reach the actual value.</li>\n</ul>\n\n<figure>\n  <img alt=\"IFD tag example: the ExifImageWidth tag\" src=\"https://getaround.tech/assets/posts/2023-09-11-exif-data-manipulation-javascript/exif_ifd_tag.png\" />\n  <figcaption>\n    IFD tag example: the ExifImageWidth tag\n  </figcaption>\n</figure>\n\n<h2 id=\"locate-the-exif-part\">Locate the EXIF part</h2>\n\n<h3 id=\"from-image-to-bytes\">From image to bytes</h3>\n<p>Time to code! The <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader\"><code class=\"language-plaintext highlighter-rouge\">FileReader</code></a> API is here used to read the image as a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code class=\"language-plaintext highlighter-rouge\">buffer</code></a>. Then it is transformed into a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\"><code class=\"language-plaintext highlighter-rouge\">DataView</code></a> for easier byte manipulation.</p>\n\n<p>The next step is to examine the start of the JPEG structure, which should be the <strong>SOI</strong> marker:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"c1\">// Where the final image with updated metadata will be stored</span>\n<span class=\"kd\">let</span> <span class=\"nx\">finalImageBlob</span> <span class=\"o\">=</span> <span class=\"kc\">null</span>\n\n<span class=\"kd\">const</span> <span class=\"nx\">reader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">FileReader</span><span class=\"p\">()</span>\n<span class=\"nx\">reader</span><span class=\"p\">.</span><span class=\"nx\">addEventListener</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">load</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"p\">({</span> <span class=\"nx\">target</span> <span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">target</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">no blob found</span><span class=\"dl\">\"</span><span class=\"p\">)</span>\n  <span class=\"kd\">const</span> <span class=\"p\">{</span> <span class=\"na\">result</span><span class=\"p\">:</span> <span class=\"nx\">buffer</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">target</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">buffer</span> <span class=\"o\">||</span> <span class=\"k\">typeof</span> <span class=\"nx\">buffer</span> <span class=\"o\">===</span> <span class=\"dl\">\"</span><span class=\"s2\">string</span><span class=\"dl\">\"</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">not a valid JPEG</span><span class=\"dl\">\"</span><span class=\"p\">)</span>\n\n  <span class=\"kd\">const</span> <span class=\"nx\">view</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">DataView</span><span class=\"p\">(</span><span class=\"nx\">buffer</span><span class=\"p\">)</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">offset</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">SOI</span> <span class=\"o\">=</span> <span class=\"mh\">0xFFD8</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span><span class=\"p\">)</span> <span class=\"o\">!==</span> <span class=\"nx\">SOI</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">not a valid JPEG</span><span class=\"dl\">\"</span><span class=\"p\">)</span>\n  <span class=\"c1\">// Here will happen the image metadata manipulation</span>\n<span class=\"p\">})</span>\n<span class=\"c1\">// Image given as a Blob, but readAsArrayBuffer can also take a File</span>\n<span class=\"nx\">reader</span><span class=\"p\">.</span><span class=\"nx\">readAsArrayBuffer</span><span class=\"p\">(</span><span class=\"nx\">imageBlob</span><span class=\"p\">)</span></code></pre></figure>\n\n<p><strong>Note:</strong> The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint16\"><code class=\"language-plaintext highlighter-rouge\">getUint16</code></a> function in Javascript is used to read two bytes (2*8 = 16bits), and there is a similar function for four bytes, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32\"><code class=\"language-plaintext highlighter-rouge\">getUint32</code></a>.</p>\n\n<h3 id=\"segments-reading\">Segments reading</h3>\n<p>From here can begin the loop through the image data to locate the EXIF section. The EXIF segment uses the <code class=\"language-plaintext highlighter-rouge\">APP1</code> marker followed by a special six-byte ASCII code <code class=\"language-plaintext highlighter-rouge\">Exif</code> (<code class=\"language-plaintext highlighter-rouge\">0x457869660000</code>) immediately following the <code class=\"language-plaintext highlighter-rouge\">APP1</code> size data.</p>\n\n<p>Reaching <strong>SOS</strong> marker is reached means reaching the start of the image data so the end of the metadata section.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">SOS</span> <span class=\"o\">=</span> <span class=\"mh\">0xFFDA</span>\n<span class=\"kd\">const</span> <span class=\"nx\">APP1</span> <span class=\"o\">=</span> <span class=\"mh\">0xFFE1</span>\n<span class=\"c1\">// Skip the last two bytes 0000 and just read the four first bytes</span>\n<span class=\"kd\">const</span> <span class=\"nx\">EXIF</span> <span class=\"o\">=</span> <span class=\"mh\">0x45786966</span>\n\n<span class=\"kd\">let</span> <span class=\"nx\">marker</span> <span class=\"o\">=</span> <span class=\"kc\">null</span>\n<span class=\"c1\">// The first two bytes (offset 0-1) was the SOI marker</span>\n<span class=\"nx\">offset</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nx\">marker</span> <span class=\"o\">!==</span> <span class=\"nx\">SOS</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">marker</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span><span class=\"p\">)</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">size</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">marker</span> <span class=\"o\">===</span> <span class=\"nx\">APP1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint32</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"o\">===</span> <span class=\"nx\">EXIF</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// EXIF segment found!</span>\n    <span class=\"c1\">// Following code will be here</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">// Skip the entire segment (header of 2 bytes + size of the segment)</span>\n  <span class=\"nx\">offset</span> <span class=\"o\">+=</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"nx\">size</span>\n<span class=\"p\">}</span></code></pre></figure>\n\n<p>The last thing to do here is to determine which is the endianness used to encode that image. In the JPEG structure, the endianness is provided thanks to the two-bytes word following the <code class=\"language-plaintext highlighter-rouge\">Exif</code> special word. If the word is <code class=\"language-plaintext highlighter-rouge\">0x4949</code>, it means it\u2019s little endian, otherwise it is <code class=\"language-plaintext highlighter-rouge\">0x4D4D</code> for big endian. This endianness data must be followed by the two bytes <code class=\"language-plaintext highlighter-rouge\">0x002A</code> (42 in decimal).</p>\n\n<p><strong>Note:</strong> From now on, always provide the endianness to the <code class=\"language-plaintext highlighter-rouge\">getUint16</code>/<code class=\"language-plaintext highlighter-rouge\">getUint32</code> functions to correctly read the bytes.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">LITTLE_ENDIAN</span> <span class=\"o\">=</span> <span class=\"mh\">0x4949</span>\n<span class=\"kd\">const</span> <span class=\"nx\">BIG_ENDIAN</span> <span class=\"o\">=</span> <span class=\"mh\">0x4d4d</span>\n\n<span class=\"c1\">// The APP1 here is at the very beginning of the file</span>\n<span class=\"c1\">// So at this point offset = 2,</span>\n<span class=\"c1\">// + 10 to skip to the bytes after the Exif word</span>\n<span class=\"nx\">offset</span> <span class=\"o\">+=</span> <span class=\"mi\">10</span>\n\n<span class=\"kd\">let</span> <span class=\"nx\">isLittleEndian</span> <span class=\"o\">=</span> <span class=\"kc\">null</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span><span class=\"p\">)</span> <span class=\"o\">===</span> <span class=\"nx\">LITTLE_ENDIAN</span><span class=\"p\">)</span> <span class=\"nx\">isLittleEndian</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span><span class=\"p\">)</span> <span class=\"o\">===</span> <span class=\"nx\">BIG_ENDIAN</span><span class=\"p\">)</span> <span class=\"nx\">isLittleEndian</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">invalid endian</span><span class=\"dl\">\"</span><span class=\"p\">)</span>\n<span class=\"c1\">// From now, the endianness must be specify each time bytes are read</span>\n<span class=\"c1\">// The 42 word</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span> <span class=\"o\">!==</span> <span class=\"mh\">0x2a</span><span class=\"p\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">invalid endian</span><span class=\"dl\">\"</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>If APP1 appears at the very beginning of the image structure (which is usually the case), then the structure should be as follows:</p>\n<figure>\n  <img alt=\"JPEG starting structure\" src=\"https://getaround.tech/assets/posts/2023-09-11-exif-data-manipulation-javascript/exif_markers.png\" />\n  <figcaption>\n    JPEG starting structure\n  </figcaption>\n</figure>\n\n<h2 id=\"read-and-replace-exif-tags\">Read and replace EXIF tags</h2>\n\n<p>All the necessary information are now known to search for the EXIF tags:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">Orientation</code>, located in the IFD <code class=\"language-plaintext highlighter-rouge\">IFD0</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">ExifImageWidth</code> or <code class=\"language-plaintext highlighter-rouge\">PixelXDimension</code> tag, located in the IFD <code class=\"language-plaintext highlighter-rouge\">IFDExif</code>, provided by the <code class=\"language-plaintext highlighter-rouge\">ExifOffset</code> tag of <code class=\"language-plaintext highlighter-rouge\">IFD0</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">ExifImageHeight</code> or <code class=\"language-plaintext highlighter-rouge\">PixelYDimension</code> tag, also located in <code class=\"language-plaintext highlighter-rouge\">IFDExif</code></li>\n</ul>\n\n<h3 id=\"ifd0\">IFD0</h3>\n\n<p>To locate the <code class=\"language-plaintext highlighter-rouge\">IFD0</code>, its offset is given by the 4-byte word immediately after the endianness <code class=\"language-plaintext highlighter-rouge\">42</code> number.</p>\n\n<p>This sequence that includes the endianness two-byte word, <code class=\"language-plaintext highlighter-rouge\">42</code>, and the <code class=\"language-plaintext highlighter-rouge\">IFD0</code> offset four-byte word is commonly referred to as the \u201cTIFF (<strong>T</strong>agged <strong>I</strong>mage <strong>F</strong>ile <strong>F</strong>ormat) Header\u201d:</p>\n\n<figure>\n  <img alt=\"The TIFF header\" src=\"https://getaround.tech/assets/posts/2023-09-11-exif-data-manipulation-javascript/exif_TIFF_header.png\" />\n  <figcaption>\n    The TIFF header\n  </figcaption>\n</figure>\n\n<p>At this point, there are two tags that need to be found through the <code class=\"language-plaintext highlighter-rouge\">IFD0</code> data:</p>\n\n<ul>\n  <li>The <a href=\"https://www.awaresystems.be/imaging/tiff/tifftags/orientation.html\"><code class=\"language-plaintext highlighter-rouge\">Orientation</code></a> tag (hex <code class=\"language-plaintext highlighter-rouge\">0x0112</code>) which is a <code class=\"language-plaintext highlighter-rouge\">SHORT</code> value that must be replaced by <code class=\"language-plaintext highlighter-rouge\">1</code></li>\n  <li>The EXIF specific IFD offset provided by the <a href=\"https://www.awaresystems.be/imaging/tiff/tifftags/exififd.html\"><code class=\"language-plaintext highlighter-rouge\">ExifOffset</code></a> tag (hex <code class=\"language-plaintext highlighter-rouge\">0x8769</code>) which is a <code class=\"language-plaintext highlighter-rouge\">LONG</code> value allowing to find the EXIF IFD tags</li>\n</ul>\n\n<p>As mentioned earlier, the first two-byte word of the IFD indicates the number of tags in the IFD. Since each tag is 12 bytes long, multiplying the number of tags by 12 gives the size of all the IFD tags, allowing for looping through them.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">TAG_ID_EXIF_SUB_IFD_POINTER</span> <span class=\"o\">=</span> <span class=\"mh\">0x8769</span>\n<span class=\"kd\">const</span> <span class=\"nx\">TAG_ID_ORIENTATION</span> <span class=\"o\">=</span> <span class=\"mh\">0x0112</span>\n<span class=\"kd\">const</span> <span class=\"nx\">newOrientationValue</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">// Here offset = 12</span>\n<span class=\"c1\">// IFD0 offset given by the 4 bytes after 42</span>\n<span class=\"kd\">const</span> <span class=\"nx\">ifd0Offset</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint32</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n<span class=\"kd\">const</span> <span class=\"nx\">ifd0TagsCount</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">ifd0Offset</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n<span class=\"c1\">// IFD0 ends after the two-byte tags count word + all the tags</span>\n<span class=\"kd\">const</span> <span class=\"nx\">endOfIFD0TagsOffset</span> <span class=\"o\">=</span> <span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">ifd0Offset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"nx\">ifd0TagsCount</span> <span class=\"o\">*</span> <span class=\"mi\">12</span>\n\n<span class=\"k\">for</span> <span class=\"p\">(</span>\n  <span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">ifd0Offset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n  <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">endOfIFD0TagsOffset</span><span class=\"p\">;</span>\n  <span class=\"nx\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">12</span>\n<span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// First 2 bytes = tag type</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">tagId</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">i</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n\n  <span class=\"c1\">// If Orientation tag</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">tagId</span> <span class=\"o\">===</span> <span class=\"nx\">TAG_ID_ORIENTATION</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Skipping the 2 bytes tag type and 4 bytes tag count</span>\n    <span class=\"c1\">// Type is SHORT, so 2 bytes to write</span>\n    <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">setUint16</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nx\">newOrientationValue</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// If ExifIFD offset tag</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">tagId</span> <span class=\"o\">===</span> <span class=\"nx\">TAG_ID_EXIF_SUB_IFD_POINTER</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Type is LONG, so 4 bytes to read</span>\n    <span class=\"nx\">exifSubIfdOffset</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint32</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></figure>\n\n<p><strong>Note:</strong> Following the same logic as for reading, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint16\"><code class=\"language-plaintext highlighter-rouge\">setUint16</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint32\"><code class=\"language-plaintext highlighter-rouge\">setUint32</code></a> functions are used to respectively write two or four bytes.</p>\n\n<h3 id=\"exif-sub-ifd\">EXIF Sub-IFD</h3>\n\n<p>Once the offset of the EXIF sub-IFD is found, a new loop must be executed through that IFD\u2019s data to find the remaining height and width tags.</p>\n\n<p>Here is information about the two tags that need to be replaced:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">ExifImageWidth</code> or <code class=\"language-plaintext highlighter-rouge\">PixelXDimension</code> tag (hex <code class=\"language-plaintext highlighter-rouge\">0xa002</code>), a <code class=\"language-plaintext highlighter-rouge\">LONG</code> value that must be replaced by <code class=\"language-plaintext highlighter-rouge\">1920</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">ExifImageHeight</code> or <code class=\"language-plaintext highlighter-rouge\">PixelYDimension</code> tag (hex <code class=\"language-plaintext highlighter-rouge\">0xa003</code>), a <code class=\"language-plaintext highlighter-rouge\">LONG</code> value that must be replaced by <code class=\"language-plaintext highlighter-rouge\">1080</code></li>\n</ul>\n\n<p>As a reminder of what was previously stated, the IFD tag is composed of 2 bytes for the type, 4 for the count, and 4 for the value.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">TAG_ID_EXIF_IMAGE_WIDTH</span> <span class=\"o\">=</span> <span class=\"mh\">0xa002</span>\n<span class=\"kd\">const</span> <span class=\"nx\">TAG_ID_EXIF_IMAGE_HEIGHT</span> <span class=\"o\">=</span> <span class=\"mh\">0xa003</span>\n<span class=\"kd\">const</span> <span class=\"nx\">newWidthValue</span> <span class=\"o\">=</span> <span class=\"mi\">1920</span>\n<span class=\"kd\">const</span> <span class=\"nx\">newHeightValue</span> <span class=\"o\">=</span> <span class=\"mi\">1080</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">exifSubIfdOffset</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">exifSubIfdTagsCount</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">exifSubIfdOffset</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n<span class=\"c1\">// This IFD also ends after the two-byte tags count word + all the tags</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">endOfExifSubIfdTagsOffset</span> <span class=\"o\">=</span>\n    <span class=\"nx\">offset</span> <span class=\"o\">+</span>\n    <span class=\"nx\">exifSubIfdOffset</span> <span class=\"o\">+</span>\n    <span class=\"mi\">2</span> <span class=\"o\">+</span>\n    <span class=\"nx\">exifSubIfdTagsCount</span> <span class=\"o\">*</span> <span class=\"mi\">12</span>\n  <span class=\"k\">for</span> <span class=\"p\">(</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"nx\">offset</span> <span class=\"o\">+</span> <span class=\"nx\">exifSubIfdOffset</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">endOfExifSubIfdTagsOffset</span><span class=\"p\">;</span>\n    <span class=\"nx\">i</span> <span class=\"o\">+=</span> <span class=\"mi\">12</span>\n  <span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// First 2 bytes = tag type</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">tagId</span> <span class=\"o\">=</span> <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">getUint16</span><span class=\"p\">(</span><span class=\"nx\">i</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n\n    <span class=\"c1\">// Skipping the 2 bytes tag type and 4 bytes tag count</span>\n    <span class=\"c1\">// The two types are LONG, so 4 bytes to write</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">tagId</span> <span class=\"o\">===</span> <span class=\"nx\">TAG_ID_EXIF_IMAGE_WIDTH</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">setUint32</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nx\">newWidthValue</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">tagId</span> <span class=\"o\">===</span> <span class=\"nx\">TAG_ID_EXIF_IMAGE_HEIGHT</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">view</span><span class=\"p\">.</span><span class=\"nx\">setUint32</span><span class=\"p\">(</span><span class=\"nx\">i</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nx\">newHeightValue</span><span class=\"p\">,</span> <span class=\"nx\">isLittleEndian</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></figure>\n\n<h3 id=\"write-back-the-image\">Write back the image</h3>\n\n<p>Getting the final image is as simple as building a new Blob from the updated buffer data:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"nx\">finalImageBlob</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Blob</span><span class=\"p\">(</span><span class=\"nx\">view</span><span class=\"p\">)</span></code></pre></figure>\n\n<p>In the end, the updated blob can be converted to a file or downloaded, depending on the application\u2019s needs.</p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>This article covers the basics of reading and updating tags, but you can expand the code by adding more tags. All the hex codes for the tags can be found on <a href=\"https://exiftool.org/TagNames/EXIF.html\">exiftools.org</a> or <a href=\"https://www.awaresystems.be/imaging/tiff/tifftags.html\">this tags reference site</a>.</p>\n\n<p>It\u2019s worth noting that there are existing libraries like <a href=\"https://github.com/exif-js/exif-js/issues/266#issuecomment-1333686536\"><code class=\"language-plaintext highlighter-rouge\">exif-js</code></a> or <a href=\"https://github.com/hMatoba/piexifjs/issues/78\"><code class=\"language-plaintext highlighter-rouge\">piexifjs</code></a> for manipulating EXIF data, but they may be larger than what is needed here and seems not being actively maintained.</p>\n\n<p>If you want to see the full code used to write this article, feel free to check out <a href=\"https://gist.github.com/CPatchane/bcd523298e64b1fa813cfae82b0f2b42\">this gist</a>.</p>"
    },
    "content": [
      {
        "type": "text/html",
        "language": null,
        "base": "https://getaround.tech/feed.xml",
        "value": "<p>The <strong>E</strong>xchangeable <strong>I</strong>mage <strong>F</strong>ile <strong>F</strong>ormat (EXIF) is a standard that specifies formats for images and sounds. It stores technical details through metadata, data that describes other data, such as the camera make and model and the date and time the image was taken.</p>"
      }
    ],
    "published": "Mon, 11 Sep 2023 00:00:00 +0000",
    "published_parsed": [
      2023,
      9,
      11,
      0,
      0,
      0,
      0,
      254,
      0
    ],
    "links": [
      {
        "rel": "alternate",
        "type": "text/html",
        "href": "https://getaround.tech/exif-data-manipulation-javascript/"
      }
    ],
    "link": "https://getaround.tech/exif-data-manipulation-javascript/",
    "id": "https://getaround.tech/exif-data-manipulation-javascript/",
    "guidislink": false
  }
}